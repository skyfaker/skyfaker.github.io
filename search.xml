<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见排序算法实现与比较——Python版</title>
      <link href="/2019/07/07/sort-algorithms-with-python/"/>
      <url>/2019/07/07/sort-algorithms-with-python/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文用Python实现列几种排序算法（冒泡排序、选择排序、插入排序、二分插入排序、快速排序、优化快速排序，并比较了他们在随机数组上的排序效率。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\times$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>折半插入排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td>$\times$</td></tr></tbody></table><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>本次几个算法均没有返回值，直接对原数组进行操作。</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-cpp"><code class="language-cpp">from time import timeimport numpy as npdef <span class="token function">timer</span><span class="token punctuation">(</span>fc<span class="token punctuation">)</span><span class="token operator">:</span>    def <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">:</span>        before <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">fc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"time: "</span><span class="token punctuation">,</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>before<span class="token punctuation">)</span>    <span class="token keyword">return</span> f# 冒泡排序@timerdef <span class="token function">bubble_sort</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token macro property"># assert type(ls) == list, "参数类型不为List"</span>    j <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>ls<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> j<span class="token operator">></span><span class="token number">0</span><span class="token operator">:</span>        flag <span class="token operator">=</span> True # 如果某一次遍历过程没有发生元素交换，则已经有序，后续不需要再执行了        <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">:</span>            <span class="token keyword">if</span> ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ls<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span>                flag <span class="token operator">=</span> False                ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ls<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ls<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> flag<span class="token operator">:</span><span class="token keyword">return</span>        j<span class="token operator">-</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1-9行，实现了一个装饰器，用来给算法计时。</p><p>11-23行，实现了一个冒泡排序算法，并稍微做了一点优化，一旦每一轮遍历没有改变元素顺序，则表示数组已经有序，后续的循环不需要再执行了。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code># 选择排序@timerdef choose_sort(ls):    for i in range(len(ls)):        tmp = ls[i]        pos = i        for j in range(i+1, len(ls)):            if ls[j]&lt;tmp:                pos = j                tmp = ls[j]        if i!=pos:            ls[i], ls[pos] = ls[pos], ls[i]</code></pre><p>选择排序的思路也很简单，虽然时间复杂度和冒泡排序一样为$O（n^2）$,但是随机情况下，速度大约比冒泡快一倍。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre><code># 插入排序，在近似有序的数组上表现最优@timerdef insert_sort(ls):    for i in range(1, len(ls)):        if ls[i]&lt;ls[i-1]:            tmp = ls[i]            j = i-1            while j&gt;=0 and tmp &lt; ls[j]:                ls[j+1] = ls[j]                j-=1            ls[j+1] = tmp</code></pre><p>插入排序类似于人打扑克牌时对牌进行的排序。速度上比冒泡略快，比选择排序略慢。</p><p>在近似有序的数组上，插入排序的表现是最好的。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><pre><code># 二分插入排序@timerdef binary_insert_sort(ls):    for i in range(1, len(ls)):        tmp = ls[i]        low = 0         high = i-1        while low &lt;= high:            middle = int((low + high) / 2)            if tmp &gt; ls[middle]:                low = middle+1            else:                high = middle-1        for j in range(i, low, -1):            ls[j] = ls[j-1]        ls[low] = tmp</code></pre><p>折半插入排序也叫二分插入排序，使用二分法来寻找插入的位置。在随机情况和最差情况下，表现比普通插入排序好得多，但在近似有序的数组上，表现不如普通插入排序。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code># 快速排序, 为了使用装饰器，多做了一层封装@timerdef quick_sort(ls):    def partition(low, high):        pos = low        tmp = ls[low]        for i in range(low+1, high+1):            if ls[i] &lt; tmp:                pos+=1                if pos!=i:                    ls[pos], ls[i] = ls[i], ls[pos]        ls[pos], ls[low] = ls[low], ls[pos]         return pos    def sort(left, right):        if left &lt; right:            pos = partition(left, right)            sort(left, pos-1)            sort(pos+1,right)    sort(0, len(ls)-1)</code></pre><p>快速排序无愧于它的名字，数据量大的时候效率很高，在大多数计算机上，快速排序表现得都比其他几个排序方法要好。</p><p>但是，我们也得清楚快速排序的缺点。</p><ol><li>快速排序是一个递归算法，需要借助递归栈存储每一层递归调用的指针和参数。所以需要$O(logn)$—$O(n)$ 的空间复杂度。</li><li>快速排序的趟数取决于的递归树的深度。倘若每次快排都可以把数组划分为2个大小相同的数组，递归树的深度可以达到最小$O(logn)$，而对于有序数组，递归树退化为单枝树，递归树的深度达到 $O(n)$，排序时速度退化到简单排序的水平。不仅需要大量的存储空间，还会有“爆栈”的风险。</li><li>数据量小的时候，不适用与快速排序，可以选插入排序。研究表明，数组长度为5—25的时候，使用插入排序要比快速排序至少快10%。</li></ol><h3 id="优化后的快速排序"><a href="#优化后的快速排序" class="headerlink" title="优化后的快速排序"></a>优化后的快速排序</h3><pre><code># 插入排序优化后的快速排序，解决快排在小数据量的排序效率低下问题@timerdef quick_sort_insert(ls):    # 插入排序    def insert_sort(low, high):        for i in range(low+1, high):            if ls[i] &lt; ls[i-1]:                tmp = ls[i]                j = i-1                while j&gt;=0 and tmp &lt; ls[j]:                    ls[j+1] = ls[j]                    j-=1                ls[j+1] = tmp    def partition(low, high):        pos = low        tmp = ls[low]        for i in range(low+1, high+1):            if ls[i] &lt; tmp:                pos+=1                if pos!=i:                    ls[pos], ls[i] = ls[i], ls[pos]        ls[pos], ls[low] = ls[low], ls[pos]         return pos    def sort(left, right):        if left &lt; right-20:            pos = partition(left, right)            sort(left, pos-1)            sort(pos+1,right)        else:            insert_sort(left, right+1)    sort(0, len(ls)-1)</code></pre><p>当数组或者子数组的长度在20以下，使用直接插入排序代替快速排序。另外，我们也可以从数组中随机选择一个数作为基准，而不是总是使用数组的第一个元素作为基准，这样可以避免在近似有序情况下，快速排序的退化问题。</p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>测试方法，随机生成一个长度为1W的数组</p><pre><code># 利用numpy，从0到5W生成一个长度1W的数组ls = np.random.randint(0,50000,10000)</code></pre><p>比较上述几种排序方法的运行时间：</p><pre><code>冒泡排序：31.1s选择排序：15.5s插入排序：22.6s折半插入排序：11.8s快速排序：0.221s插入排序优化后的快速排序：0.177s</code></pre><p><strong>By the way, python自带的list.sort()也是原地排序，对上述数组的排序时间为：0.000996s,比优化后的快速排序还要快百倍，这么快也有可能是因为这个内置方法是用C语言写出来的。</strong></p><p><strong>list.sort()使用的排序方法为Timsort算法，速度非常快，缺点是空间复杂度为 $O(n)$ ，比较耗费内存。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三元组损失模型</title>
      <link href="/2019/06/22/san-yuan-zu-sun-shi-mo-xing/"/>
      <url>/2019/06/22/san-yuan-zu-sun-shi-mo-xing/</url>
      
        <content type="html"><![CDATA[<ul><li><h5 id="论文素材提供：珍珍"><a href="#论文素材提供：珍珍" class="headerlink" title="论文素材提供：珍珍"></a>论文素材提供：珍珍</h5></li></ul><h2 id="三元组损失概述"><a href="#三元组损失概述" class="headerlink" title="三元组损失概述"></a>三元组损失概述</h2><p>三元组损失（Triplet loss）函数是当前应用较为广泛的一种损失函数，最早由Google研究团队在论文《FaceNet：A Unified Embedding for Face Recognition》所提出，常用在人脸识别任务中。目的是做到非同类极相似样本的区分，比如说兄弟二人的区分。</p><p>所以，Triplet loss的优势在于细节区分，即当两个输入相似时，Triplet loss能够更好地对细节进行建模，相当于加入了两个输入差异性差异的度量，学习到输入的更好表示，从而在上述两个任务中有出色的表现。</p><p><img src="tripletloss.png" alt="Triplet loss优化过程"><br>如上图所示，三元组图片输入到具有相同权重的特征提取网络。得到的特征向量再经过运算得到三元组损失（TripletLoss）。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>它的基本思想是：对于设定的三元组(Anchor, Positive, Negative) （Anchor和Positive为同类的不同样本，Anchor与Negative为异类样本），Triplet loss试图学习到一个特征空间，使得在该空间中相同类别的基准样本（Anchor）与 正样本（Positive）距离更近，不同类别的 Anchor 与负样本（Negative）距离更远。其思想与图像识别任务的目标很契合，即给定训练图集和测试图集，判断两张图片是否属于同一类标签。<br><img src="%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="三元组优化思路"></p><p>Triplet loss本质上是属于度量学习（Metric Learning）的范围，其借鉴了度量学习中的经典大间隔最近邻（Large Margin Nearest Neighbors，LMNN）算法。以Triplet loss为训练准则的深度神经网络模型既兼顾了度量学习的朴素性，又拥有神经网络优秀的非线性建模能力，能够在极大程度上简化并且控制模型训练过程。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p><strong>基于Triplet loss的神经网络模型可以很好的对细节进行区分</strong>，尤其是在图像分类任务中，当两个输入很相似的时候，Triplet loss对这两个差异性较小的输入向量可以学习到更好的表示，从而在分类任务中表现出色。</p><p>相比其他分类损失函数，Triplet loss通常能在训练中学习到更好的细微的特征feature，更特别的是Triplet loss能够根据模型训练的需要设定一定的阈值。<br>带Triplet loss的网络结构在进行训练的时候一般都会设置一个阈值margin，设计者可以通过改变margin的值来控制正负样本的距离。同时通过设定指定的阈值，可以在特征进行归一化后，用来判断是否为同一个标签。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然Triplet loss很有效，但也有缺点：三元组的选取导致数据的分布并不一定均匀，所以在模型训练过程表现很不稳定，而且收敛慢，需要根据结果不断调节参数，而且Triplet loss比分类损失更容易过拟合。</p><p>所以，大多数情况下，我们会把这种方法放在模型的预训练过程中，或者和softmax函数（分类损失）结合在一起使用。</p><h3 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h3><p>Triplet loss 由一个三元组&lt;a, p, n&gt;构成，需要三张图片作为输入，如上一段中的图片所示，其中a: anchor 表示基准样本，p: positive 表示与anchor相同类别但不同的正样本，n: negative 表示与基准样本不同类别的负样本。利用生成的每个triplet，模型就能够创建出对应的positive pair &lt;a, p&gt;和negative pair &lt;a, n&gt;。</p><p>Triplet loss的目的是，在一定的距离（margin）上，将positive pair和negative pair分开,通过优化保证嵌入空间（Embedding Space）中类别相同的样本点之间距离足够近，而类别不同的样本点间距离足够远，即基准样本与负样本的距离要远远大于基准样本与正样本间的距离。</p><p>则Triplet loss的思想用欧氏距离形式化表示为：</p><p><strong>$$L = max \lbrace d(a, p)-d(a, n) + margin,\quad 0 \rbrace$$</strong><br>对于阈值margin的设置需要注意选择合适大小的值，理论上来说，较大的margin能够增强模型对不同类样本的区分度，但是如果在训练初期就将margin设置得比较大，则可能会增加模型训练的难度，进而出现网络不收敛的情况。在模型训练初期先使用一个较小的值对网络进行初始化训练，之后再根据测试的结果对margin的值进行适当的增大或缩小，这样可以在保证网络收敛的同时让模型也能拥有一个较好的性能。<br>在这里设样本为 $x$，$f(x)$为映射函数，整个训练集的大小为N，则每个triplet的输入&lt;a, p, n&gt;，对应的Triplet loss形式化表示就可以写作：</p><p>$$ \frac{1}{N} { \sum_i^N[|f(x_i^a) - f(x_i^p)|^2 - |f(x_i^a) - f(x_i^n)|^2 + \alpha]_+}$$</p><p>式中$|f(x_i^a) - f(x_i^p)|^2$表示的是2-范数的平方，其作用是计算欧几里得空间的长度或者向量的模，具体的展开形式为：$$ |\ast|^2 = |v_k|^2$$<br>$v_k$表示的是向量，该式常用于机器学习的正则化中。<br>式中$ [\ast]+ $为合页损失（Hing loss）函数，表示与0取最大值，若式子小于 0,则说明此时的triplet满足损失值的要求，不同类别样本间的距离要远远大于相同类别样本间的距离，由于这样的triplet对神经网络的反向传播和参数更新没有提供帮助，因此将其损失值置为 0。至此我们可以看出，其实Triplet loss的整体优化目标就是一个最小化损失值的问题。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在图像任务中，Triplet loss经常用作样本点在欧氏空间上的距离向量表示，它可以极大地提升深度特征的判别能力。为了使训练更加迅速有效，需要注意设计好训练策略，只选择合适的triplet进行训练，因为一个数据集的triplet组合非常多，全部进行训练的话会大大降低效率。</p><p>基于我们对Triplet loss的定义，一般而言，会将triplet分为三类，如图所示：</p><p><img src="class.png" alt="三类基准样本、正样本和负样本之间的距离关系"></p><p>1、<strong>easy triplets （简单三元组）</strong>: 指在未经过训练的情况下，Triplet loss值已经为0的三元组，此时网络不需要训练学习就满足损失函数的要求。简单的用欧式距离表示为：$d(a, n)$&gt;$d(a, p)$+ margin；</p><p>2、<strong>semi-hard triplets（一般三元组）</strong>: 指负样本与基准样本间的距离大于正样本与基准样本间的距离，但Triplet loss值还没有达到0，此时网络通过恰当的学习可以不断降低损失值。用欧式距离表示为：$d(a, p)$&lt;$d(a, n)$ &lt;$d(a, p)$+margin；</p><p>3、<strong>hard triplets（困难三元组）</strong>: 指负样本与基准样本间的距离小于正样本与基准样本间的距离，这是网络最难学习的样本组，此时的损失值会出现较大的震荡。用欧式距离表示为：$d(a, n)$ &lt;$d(a, p)$。</p><p>由于简单三元组的损失值为0，如果训练网络只能学习到简单的triplets，会导致网络的泛化能力受到限制，网络没有学习到任何特征，对训练任务并没有帮助。因此当一个训练批次中包含大量的easy triplets时，会导致训练网络的收敛速度大大降低。</p><p>  而一般三元组非常适合网络的前期训练，能够帮助训练网络的收敛，并且同时可以得到大量比较有效的统计信息。</p><p>  困难三元组则在网络训练后期起到很好的学习作用，能够帮助提升网络的性能。让网络学习一些很难的样本特征，可以大大提高训练网络的分类能力，尤其是对难以判断的样本的判别能力。</p><p>  因此，在网络的训练中，我们需要注意结合一般三元组和困难三元组，充分利用两者进行训练学习不仅能够加快网络的收敛，同时可以在很大程度上提升网络模型的识别性能。</p><p>但Triplet loss有一个缺点是，当数据集比较大时，训练的triplet数量也会随之变得十分庞大，此时会造成训练任务变得很艰难。而且如果采用随机选取三元组的训练策略，有可能很多次模型从训练集中挑选的三张图片，恰好是比较简单的三元组，计算出的损失值会很不稳定，从而导致模型很难学习到图片的主要特征。因此我们在使用Triplet loss函数时，要注意选取的训练集不宜过大，还要<strong>设计好训练策略</strong>来选择恰当的triplet。</p><h3 id="三元组选取策略"><a href="#三元组选取策略" class="headerlink" title="三元组选取策略"></a>三元组选取策略</h3><p>许多类似的人脸识别、匹配工作都是在大数据集上实现的，这就要求对数据的高效利用。然而大多数样本在训练中后期不再有梯度贡献，例如含有margin的损失函数（triplet loss、softpn(pnnet中的损失函数，改进于triplet loss)），多数样本很容易满足于这个margin，此时损失函数中的loss不再发生变化，导致训练停滞阻塞。在极多identities（类别极多）的数据集中不能足够有效的挖掘困难样本，这就容易陷入局部极小，无法继续更新。</p><p>所以如何有效的进行困难样本挖掘（OHEM）成为了关键，困难样本应该包括同类（匹配样本）中距离较大的和非同类（非匹配样本）中距离较小的样本。</p><p>$$ \frac{1}{N} { \sum_i^N[|f(x_i^a) - f(x_i^p)|^2 - |f(x_i^a) - f(x_i^n)|^2 + \alpha]_+}$$</p><p>对于上述的公式，实际上并没有体现困难挖掘，所以随机选取的样本并不能保证是困难样本，恰恰相反，这样选取的三元组实际上大部分为简单样本。</p><p>并且在大量图片样本下使用triplet loss也并非容易，如何有效的在large-scale情况下高效优化？使用triplet会发现数据量激增，可组合的三元组变多，如果要遍历所有组合是不现实的，或者极其低效。主要有两种方法，一是将triplet loss转为softmax loss（<strong>triplet net一文中，将triplet loss结合了softmax的输出与mse</strong>），另一种是batch OHNM。但是第二种挖掘样本的方法都是直接考虑<strong>在所有的样本空间来sample一个batch</strong>，如果这个batch中有不满足margin的就认为是困难样本。然而这样做并不能保证采样时正好选取了很多很<strong>相似</strong>的样本，而且（a,p,n）图像组一经选取就已经固定，不会再有其他的组合，所以效率较低。所以寻找相似的个体（类别）是提高triplet net的核心关键**。</p><p>　　对于含有10个个体（人）的人脸数据，难以区分的肯定是那些长的很像的个体（比如甲与乙为兄弟二人）。之前的困难挖掘是首先在这些打散的<strong>整体空间</strong>中<strong>随机</strong>设置（a,p,n）三元组然后成批去训练，分错的作为困难样本。这就使得你这些三元组都已经<strong>固定</strong>了，困难样本不一定是真的困难，除非运气好使得三元组中有很多甲、乙中的样本。所以一个想法是首先对于所有样本进行聚类，观察哪些样本比较接近，（甲和乙长得像肯定聚类结果很接近），那么我就在聚好类的<strong>子空间</strong>中选取(a,p)二元组组成batch，n在这个batch中来选取，那么这个负样本n就会是真正的困难样本。</p><h3 id="1-随机选取"><a href="#1-随机选取" class="headerlink" title="1.随机选取"></a>1.随机选取</h3><p>T代表全体样本空间，所以这里的三元组都是<strong>直接从总体样本中</strong>选择的，这也是我们大多数人的做法。</p><p><img src="%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96.png" alt="img"></p><p>看上面这个图示，红色为anchor，浅绿色为positive，天蓝色为negative，深蓝色为hard negative。</p><p>这个方法中所有的匹配对和negative都是在<strong>整体样本</strong>中选取。可见，大多数negative是远离positive匹配对的，尽管训练的时候negative也会被分到一个batch中，但是真正困难的negative很难被选择到。</p><p><strong>总结：在打散的整体样本空间随机选择三元组，并不是最好的选择方式，只是最方便而已。</strong></p><h3 id="2-Triplet-with-Batch-OHNM"><a href="#2-Triplet-with-Batch-OHNM" class="headerlink" title="2.Triplet with Batch OHNM"></a>2.Triplet with Batch OHNM</h3><p><img src="batchOHEM.png" alt="img"></p><p>这个方法是为了在一个batch中尽可能挖掘困难样本，这时negative并非在<strong>整体样本</strong>中选取而是在一个batch中选择。</p><p>看上图公式的第三行，a和p$\in$T，表示从全体样本中选取，x$\in$B，表示x从batch中选取。</p><p>再看第二行，x与$x^a$属于不同类别，一个batch中，这样的x有数个，把每个x都与$x^a$计算相似度，取相似度最小的一个x为$x^n$，再用这个$x^n$与之前的$x^a$和$x^p$计算三元组损失。</p><p>就是说只在全体样本中选取一个batch的三元组，这些样本输入到网络，输出的特征进行比较，训练时在这一个batch的特征中再选择negative来训练。<strong>这就相当于缩小了搜索范围</strong>。从全局搜索变成了局部搜索，所以搜到的困难样本可能性更大。</p><p>举个例子：设batch_size = 4，那么会有&lt;$x_1^a$,$x_1^p$,$x_1$&gt;, &lt;$x_2^a$,$x_2^p$,$x_2$&gt;, &lt;$x_3^a$,$x_3^p$,$x_3$&gt;, &lt;$x_4^a$,$x_4^p$,$x_4$&gt;共4个三元组，这个三元组并不是接下来计算三元组损失的三元组。这12个样本均输入到网络中，得到他们编码后的特征，然后$x_1^a$与$x_1$、$x_2$、$x_3$、$x_3$分别计算相似度，其中最相似的一个作为$x_1^n$，其他组的negative通过同样的计算得到。</p><p>最终，可能用来计算损失的三元组变成了&lt;$x_1^a$,$x_1^p$,$x_2$&gt;, &lt;$x_2^a$,$x_2^p$,$x_2$&gt;, &lt;$x_3^a$,$x_3^p$,$x_1$&gt;, &lt;$x_4^a$,$x_4^p$,$x_3$&gt;，这样，我们就在一个batch内组合得到了最能实现困难样本的三元组。</p><p><img src="batchOHEM%E8%BF%87%E7%A8%8B.png" alt="img"></p><p>首先是<strong>匹配对组成batch</strong>经过网络得到距离后，根据距离判断相似度，再重新组成<strong>三元组batch</strong>，输入到损失函数来优化。</p><p>有一点值得注意，某些情况下，直接选择与anchor<strong>最近</strong>的negative作为困难样本，可能会导致poor training，模型难以训练，应该选择比较近邻的样本。 通俗来说，就是特别相似的三张图反而无法训练，因为它们本来就模糊属于一个类，这样反而造成一种“错误标记”的训练样本，让模型原本训练得比较稳定的权重大幅度改变，反而不利于准确训练。</p><p><strong>总结：在打散的整体样本空间随机选择二元组，在batch中选取合适的negative组成三元组，来计算三元组损失。</strong></p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像分类 </tag>
            
            <tag> 三元组损失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib 可视化</title>
      <link href="/2019/05/20/matplotlib-hui-zhi-san-dian-tu/"/>
      <url>/2019/05/20/matplotlib-hui-zhi-san-dian-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="matplotlib绘制散点图"><a href="#matplotlib绘制散点图" class="headerlink" title="matplotlib绘制散点图"></a>matplotlib绘制散点图</h2><p>上一篇文章，我们通过自编码器，将高维的特征压缩至二维和三维，这样就可以实现可视化效果。</p><ul><li>前排提醒：本文中代码为部分关键代码，全部代码请移步该项目的GitHub：<a href="https://github.com/skyfaker/Autoencoder" target="_blank" rel="noopener">Autoencoder实现降维与可视化</a></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 压缩特征维度至2维</span>encoding_dim <span class="token operator">=</span> <span class="token number">3</span><span class="token comment" spellcheck="true"># this is our input placeholder</span>input_img <span class="token operator">=</span> Input<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">784</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 编码层</span>encoded <span class="token operator">=</span> Dense<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>input_img<span class="token punctuation">)</span>encoded <span class="token operator">=</span> Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span>encoded <span class="token operator">=</span> Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span>encoder_output <span class="token operator">=</span> Dense<span class="token punctuation">(</span>encoding_dim<span class="token punctuation">)</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上面的代码，我们利用全连接神经网络实现了降维，降至二维。</p><p>我们训练好自编码器模型后，从中获取编码模型，接下来我们会用这个编码模型对测试数据进行编码。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># predict &amp; plotting</span>encoded_imgs <span class="token operator">=</span> encoder<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 设置窗口大小</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>encoded_imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> encoded_imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>y_test<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 绘制散点图</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>x_test的初始shape为（10000， 784），10000表示10000张图，784为每张图片的像素点数目（28*28）。经过编码器压缩之后<code>encoder.predict()</code> 变成了（10000，2）</p><p>再利用matplotlib的散点图绘制出只有二个特征的特征向量。</p><p>具体效果如图：</p><p><img src="2d.png" alt="二维的可视化效果"></p><p>可以看出，自编码器的降维效果也是不错的。</p><p>同样的，我们在把特征压缩到三维的时候，可以画出一个三维的散点图。绘制过程稍有点不同。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># predict &amp; plotting</span>encoded_imgs <span class="token operator">=</span> encoder3D<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ax1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>axes<span class="token punctuation">(</span>projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>scatter3D<span class="token punctuation">(</span>encoded_imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> encoded_imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>encoded_imgs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>y_test<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="3d.png" alt="二维的可视化效果"></p><ul><li>下面记录一下散点图的用法</li></ul><p>文档地址：<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html#matplotlib.pyplot.scatter" target="_blank" rel="noopener">scatter文档</a></p><pre class="line-numbers language-python"><code class="language-python">matplotlib<span class="token punctuation">.</span>pyplot<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> s<span class="token operator">=</span>None<span class="token punctuation">,</span> c<span class="token operator">=</span>None<span class="token punctuation">,</span> marker<span class="token operator">=</span>None<span class="token punctuation">,</span> cmap<span class="token operator">=</span>None<span class="token punctuation">,</span> norm<span class="token operator">=</span>None<span class="token punctuation">,</span> vmin<span class="token operator">=</span>None<span class="token punctuation">,</span> vmax<span class="token operator">=</span>None<span class="token punctuation">,</span> alpha<span class="token operator">=</span>None<span class="token punctuation">,</span> linewidths<span class="token operator">=</span>None<span class="token punctuation">,</span> verts<span class="token operator">=</span><span class="token operator">&lt;</span>deprecated parameter<span class="token operator">></span><span class="token punctuation">,</span> edgecolors<span class="token operator">=</span>None<span class="token punctuation">,</span> \<span class="token operator">*</span><span class="token punctuation">,</span> plotnonfinite<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> data<span class="token operator">=</span>None<span class="token punctuation">,</span> \<span class="token operator">*</span>\<span class="token operator">*</span>kwargs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> 点的大小<span class="token punctuation">,</span> 颜色，标记<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 这是最主要的几个用法</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>点的形状属性由marker控制，默认为。， c 控制点的颜色， norm 控制亮度</p>]]></content>
      
      
      <categories>
          
          <category> 工具方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> matplotlib </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络——自编码器（Autoencoder）</title>
      <link href="/2019/04/16/autoencoder/"/>
      <url>/2019/04/16/autoencoder/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络（neural-network）的应用——自编码器（Autoencoder）"><a href="#神经网络（neural-network）的应用——自编码器（Autoencoder）" class="headerlink" title="神经网络（neural network）的应用——自编码器（Autoencoder）"></a>神经网络（neural network）的应用——自编码器（Autoencoder）</h2><h3 id="1-自编码器简介"><a href="#1-自编码器简介" class="headerlink" title="1. 自编码器简介"></a>1. 自编码器简介</h3><p>自编码器（Autoencoder，AE），是一种利用反向传播算法使得输出值等于输入值的神经网络，它先将输入压缩成潜在空间表征，然后通过这种表征来重构输出。</p><p>简单来说，就是可以自动实现编码与解码操作过程的网络模型，并且它的输入 <strong>x</strong> 与标签 <strong>y</strong> 相同，我们通过最小化标签  <strong>y</strong> 与输出 <strong>r</strong> 之间的误差，来优化自编码器模型。</p><p>因此，自编码器由两部分组成：</p><p><strong>编码器</strong>：这部分能将输入压缩成潜在空间表征，可以用编码函数 <strong>h</strong> =f(x)表示。</p><p><strong>解码器</strong>：这部分能重构来自潜在空间表征的输入，可以用解码函数 <strong>r</strong> =g(h)表示。</p><p><img src="1-V_YtxTFUqDrmmu2JqMZ-rA.png" alt></p><p>整个自编码器可以用函数g(f(x)) =  <strong>r</strong> 来描述，其中输出r与原始输入 <strong>x</strong> 相近。</p><p>自编码器原理和各种变换的原理相似，都是将原始特征空间通过编码映射到一个新的编码空间，再由编码空间通过解码映射到解码空间。而当编码变换与解码变换符合某种条件时，解码空间和原始特征空间可以近似一致。</p><p>就像大名鼎鼎的傅里叶变换，通过它，可以把原始时域信号变换为频域信号，并且，频域信号可以通过反变换变换为时域信号。之所以要变换为频域信号，是为了获取原始信号在频域上的特征。同样的，对于自编码器的编码变换，也是为了获取不同角度，不同维度的特征（类似于SVM的核函数）。</p><p>按照Hinton的说法，自编码器的隐含层如果只有一层，其原理类似主成分分析（PCA），如果多个隐含层，每个隐含层都是受限玻尔兹曼机神经网。训练时，相当于先对每两层间进行无监督学习，将整个网络达到理想的初始化分布，最后再通过反向传播算法的有监督学习调整模型权重，这样可以解决网络过深带来的梯度弥散问题。</p><h3 id="2-自编码器的用途"><a href="#2-自编码器的用途" class="headerlink" title="2. 自编码器的用途"></a>2. 自编码器的用途</h3><p>数据可视化，数据降噪和降维被认为是自编码器的几个主要的实际应用。使用适当的维度和稀疏性约束，自编码器可以得到比PCA或其他类似技术更好的数据投影。</p><p>在自编码器中，中间的隐藏表达的维度往往维度比较低，因此可以被用作数据压缩，或者是特征降维。</p><p>不过自编码器原本不是专门用来做数据压缩的，它的作用就是可以作为很多神经网络的预训练，帮助提高模型的准确率。神经网络模型的训练需要大量具有标签的样本，而这样的数据通常是比较少的，更多的是无标签样本，而自编码器自监督的特性可以充分利用这些无标签样本，提前学习到有用的特征。接下来，把自编码器的编码器接入神经网络，进行训练。</p><h4 id="2-1-降维与可视化"><a href="#2-1-降维与可视化" class="headerlink" title="2.1 降维与可视化"></a>2.1 降维与可视化</h4><p>很明显，如果自编码器的只是单纯的将输入复制到输出中，那么它没有用处。所以实际上，我们希望通过训练自编码器将输入映射到 <strong>h</strong> 中，并且使表示函数 <strong>h</strong> 获得原始数据中有用的特征和属性，在这一过程中，输入到 <strong>h</strong> 的映射可以自动的帮助我们筛选特征，降低特征维度。</p><p>而想要让自编码器筛选有用特征，一种方法是约束 <strong>h</strong> 的维度小于 <strong>x</strong> ，在这种情况下，自编码器被称为欠完备（undercomplete）。通过训练不完整的表示，我们迫使自编码器学习训练数据的最有代表性（显著的）的特征。如果给自编码器的容量过大，则它可以复制 <strong>x</strong> 而不去提取关于数据分布的有用信息。</p><p>利用上述的方法，就达到了降维的作用。而当隐藏表达的维度降至三维或者二维时，就可以实现数据的可视化。</p><p>自编码器通过数据自动学习。这意味着在特定类型的输入中，自编码器可以表现出良好的结果，并且不需要任何新的结构，只需适当的训练数据即可。这种结构单一、无需标签的网络使用起来异常简单，并且常常会有不错的表现，所以使用地很广泛。</p><p>下面，看个例子，mnist数据集的二维可视化：</p><p><img src="2d.png" alt="二维可视化效果"></p><p>上图就是mnist数据集经过降维至二维后的可视化效果图。不同颜色的点代表不同的数字。</p><p>同样的，我们也可以降维到三维，形成空间可视化图：</p><p><img src="3d.png" alt="三维可视化效果"></p><p>不过，它也不是没有缺点，首先，自编码器是数据相关的，是在给定的一组数据上进行训练的，因此它将得到与所用训练集数据相似的压缩结果，在这样的数据上表现优异，但就其通用性来说，效果并不好。比如在图像压缩领域，效果比不上JPEG这样的通用压缩技术。</p><h3 id="3-常见的自编码器与代码示例"><a href="#3-常见的自编码器与代码示例" class="headerlink" title="3. 常见的自编码器与代码示例"></a>3. 常见的自编码器与代码示例</h3><h4 id="3-1-简单自编码器和深度自编码器"><a href="#3-1-简单自编码器和深度自编码器" class="headerlink" title="3.1 简单自编码器和深度自编码器"></a>3.1 简单自编码器和深度自编码器</h4><pre><code>from keras.layers import Input, Densefrom keras.models import Modelfrom keras.datasets import mnistimport numpy as npencoding_dim=32input_img = Input(shape=(784,))encoded = Dense(encoding_dim, activation=&#39;relu&#39;)(input_img)decoded = Dense(784, activation=&#39;sigmoid&#39;)(encoded)autoencoder = Model(input_img, decoded)encoder = Model(input_img, encoded)</code></pre><p>上面这种就是自编码器是最简单的形式，其中encoder是编码器，autoencoder是整个自编码器。</p><p>在这种形式中，基本上encoder的神经元个数都要少于输入的维度，因此Encoder在这里起到了降维的功能。</p><p>把<code>encoding_dim=32</code>换成<code>encoding_dim=2</code>或者<code>encoding_dim=3</code>就可以满足上图的可视化数据要求。</p><h4 id="3-2-稀疏自编码器"><a href="#3-2-稀疏自编码器" class="headerlink" title="3.2 稀疏自编码器"></a>3.2 稀疏自编码器</h4><p>除强加一个比输入更低维度的隐藏层外，还有其他一些方法可以限制自编码器的重构。包含正则化项的自编码器不需要通过保持编码器和解码器的浅层和程序的小体量来限制模型容量，而是使用损失函数来鼓励模型取得除了将输入复制到其输出之外的其他属性。在实践中，我们通常会使用稀疏自编码器。</p><p>简而言之，稀疏自编码器就是加入了正则项的自编码器，大部分参数置为0 ，这样做可以会使我们的自编码器学习数据的稀疏表示。</p><pre><code>input_size = 784hidden_size = 64output_size = 784x = Input(shape=(input_size,))# Encoderh = Dense(hidden_size, activation=&#39;relu&#39;, activity_regularizer=regularizers.l1(10e-5))(x)# Decoderr = Dense(output_size, activation=&#39;sigmoid&#39;)(h)autoencoder = Model(input=x, output=r)encoder = Model(input=x, output=h)</code></pre><p>在的隐藏层中，我们添加了一个l1激活值正则化矩阵（activity regularizer），它将在优化阶段对损失函数施加一个惩罚，与普通的自编码器相比，现在的表示方式更加稀疏。</p><h4 id="3-3-卷积自编码器、变分自编码器（VAE）等"><a href="#3-3-卷积自编码器、变分自编码器（VAE）等" class="headerlink" title="3.3 卷积自编码器、变分自编码器（VAE）等"></a>3.3 卷积自编码器、变分自编码器（VAE）等</h4><p>如果输入的是图像，使用卷积神经网络（CNN）作为编码器和解码器是很有意义的。在实际使用中，应用于图像的自动编码器始终是卷积自动编码器 ，因为它们的性能要好得多。</p><p>编码器将由Conv2D和MaxPooling2D层组成（最大池化用于下采样，以减小图像维度，降维），而解码器将由Conv2D和UpSampling2D（增加图像维度，升维）层组成。</p><p>而VAE是一类重要的生成模型（generative model），广泛地用于生成图像，而大名鼎鼎的GAN就是对抗生成模型。原理和实现都比较复杂，用于以后研究。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>自编码器结构并不复杂，数学推导也很简单，有助于对于神经网络的理解。并且面对很多工业问题，比如说有大量的无标注数据，而有标签数据很少的情况下，可以利用自编码器进行预训练。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoEncoder </tag>
            
            <tag> 全连接神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue初见——如何运行一个Vue项目</title>
      <link href="/2019/03/16/how-to-run-a-vue/"/>
      <url>/2019/03/16/how-to-run-a-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="如何运行一个Vue项目"><a href="#如何运行一个Vue项目" class="headerlink" title="如何运行一个Vue项目"></a>如何运行一个Vue项目</h1><p>一开始刚接手项目内的vue.js，或者在GitHub上找到vue.js的开源项目，会发现不知如何运行这个项目。通过查阅网上教程，成功搭建好项目环境，同时对前段工程化有了朦朦胧胧的认知，因此将环境搭建过程分享给大家。</p><h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><p>首先，列出来我们需要的东西：</p><pre><code>node.js环境（npm包管理器）vue-cli 脚手架构建工具cnpm  npm的淘宝镜像</code></pre><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>从node.js官网下载并安装node，安装过程很简单，一路“下一步”就可以了（傻瓜式安装）。<br>安装完成之后，打开命令行工具，输入 <code>node -v</code>，如下图，如果出现相应的版本号，则说明安装成功。</p><p><img src="image-20200216144352886.png" alt="image-20200216144352886"></p><p>npm包管理器直接集成在node中的，所以，不需要额外安装，输入 <code>npm -v</code>就会如下图所示，显示出npm的版本信息。</p><p><img src="image-20200216144500107.png" alt="image-20200216144500107"></p><p>由于有些npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候非常慢，甚至会失败，所有我还需要npm的国内镜像—cnpm。</p><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>在命令行中输入 <code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>，然后等待，安装完成。</p><h3 id="安装webpack（可选）"><a href="#安装webpack（可选）" class="headerlink" title="安装webpack（可选）"></a>安装webpack（可选）</h3><p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。</p><p><code>npm install webpack -g</code></p><h3 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h3><p>在命令行中运行命令 <code>cnpm install -g vue-cli</code> ，然后等待安装完成。(这里使用cnpm来替代npm，以加快速度)</p><h2 id="2-运行项目"><a href="#2-运行项目" class="headerlink" title="2. 运行项目"></a>2. 运行项目</h2><h3 id="从项目的根目录打开cmd"><a href="#从项目的根目录打开cmd" class="headerlink" title="从项目的根目录打开cmd"></a>从项目的根目录打开cmd</h3><p><img src="image-20200216145451354.png" alt="image-20200216145451354"></p><p><img src="image-20200216145519142.png" alt="image-20200216145519142"></p><h3 id="进入项目之后安装依赖"><a href="#进入项目之后安装依赖" class="headerlink" title="进入项目之后安装依赖"></a>进入项目之后安装依赖</h3><p><code>npm install</code>安装项目依赖</p><p>安装完成之后项目里面多了一个文件夹</p><p><img src="image-20200216145948586.png" alt="image-20200216145948586"></p><p>然后运行<code>npm run dev</code></p><p><img src="image-20200216151319536.png" alt="image-20200216151319536"></p><p>复制地址到浏览器就可以打开了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周一道编程题——两个栈实现队列</title>
      <link href="/2019/03/10/yong-liang-ge-zhan-lai-shi-xian-yi-ge-dui-lie.md-yong-liang-ge-zhan-shi-xian-dui-lie/"/>
      <url>/2019/03/10/yong-liang-ge-zhan-lai-shi-xian-yi-ge-dui-lie.md-yong-liang-ge-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>栈的特点是先进后出，队列为先进先出。</p><p>队列的功能只有2个，队尾进，队首出。</p><p>队尾进：这一功能和栈一致。</p><p>队首出：队列中第一个出队元素，在栈中为栈底元素。在栈中，要想取到栈底元素，必须所有元素出栈。而这些元素，只需要输出最后一个，其他的仍然需要保存。所以，我们可以把一个栈的元素依次取出，存入另一个栈。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个栈A，B，A用来接收入队的元素，B用来模拟出队的操作。</p><p>入队时，元素压入栈A，出队时，从栈B的栈顶弹出，如果B中没有元素，则依次取出A的元素压入栈B，再模拟出队操作。</p><p>比如：栈A = [1,2,3,4]，栈B = [ ]。</p><p>模拟入队操作时，元素直接压入栈A。</p><p>模拟出队操作，则需要取出第一个元素1，这时，需要把栈A中元素转到栈B。</p><p>栈A = [ ]，栈B = [ 4, 3, 2, 1]。然后再取出栈B的最后一个元素1。</p><p>下一次出队操作，再次从栈B取出栈顶元素。如果栈B为空，则将栈A所有的元素取出，压入栈B，再执行栈B的弹出栈顶操作。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding:utf-8 -*-</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack_a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack_b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write code here</span>        self<span class="token punctuation">.</span>stack_a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># return xx</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack_b <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack_a <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token keyword">return</span>            self<span class="token punctuation">.</span>stack_b <span class="token operator">=</span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack_a<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>stack_a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack_b<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack_b<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周一道编程题——重建二叉树</title>
      <link href="/2019/03/03/chong-jian-er-cha-shu/"/>
      <url>/2019/03/03/chong-jian-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>根据二叉树的前序遍历和中序遍历重建二叉树，或者计算后序遍历是二叉树的基础操作。</p><p>前序遍历是指先根节点，再左右子节点；中序遍历是指先左子节点，再根节点，最后右子节点；后续遍历是指先左右子节点，再根节点。</p><p>前序遍历和中序遍历可以唯一确定一棵二叉树，所以后序遍历的结果是唯一的。</p><p>一般遇到这样的问题，首选 <strong>递归</strong> 的方法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于前序遍历是先根节点，后子节点，中序遍历为先左后跟。所以结合二者，对于前序遍历的结果，第一位必然是树的根，并且根据这个根，我们可以在中序遍历中找到左子树（根前面的元素）。</p><p>例如题目中的前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。</p><p>可知，前序遍历第一位为1，则1为树根，而在中序中1前面的都是左子树，所以左子树为4，7，2.</p><p>那么，我们就可以把前序和中序遍历划分为根，左子树，右子树。</p><p>前序：｛1 |2，4，7 | 3，5，6，8｝，中序：｛4，7，2 | 1 |5，3，8，6｝</p><p>接下来，只需要使用递归的方法，对左右子树做同样的操作，就可以重建二叉树了。</p><p>实际上，题目中的二叉树长这样：</p><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding:utf-8 -*-</span><span class="token comment" spellcheck="true"># class TreeNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x</span><span class="token comment" spellcheck="true">#         self.left = None</span><span class="token comment" spellcheck="true">#         self.right = None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 返回构造的TreeNode根节点</span>    <span class="token keyword">def</span> <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> tin<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write code here</span>        <span class="token comment" spellcheck="true"># 终止递归的条件</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span>         <span class="token comment" spellcheck="true"># 根节点为前序遍历的第一个节点</span>        root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 因为不含重复的数字，所以可以直接使用列表的index方法</span>        <span class="token comment" spellcheck="true"># 这里需要注意对于原前序和中序列表的截取</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>reConstructBinaryTree<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span>tin<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tin<span class="token punctuation">[</span><span class="token punctuation">:</span>tin<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>reConstructBinaryTree<span class="token punctuation">(</span>pre<span class="token punctuation">[</span>tin<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tin<span class="token punctuation">[</span>tin<span class="token punctuation">.</span>index<span class="token punctuation">(</span>pre<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周一道编程题——反向打印链表</title>
      <link href="/2019/02/24/cong-wei-dao-tou-da-yin-lian-biao/"/>
      <url>/2019/02/24/cong-wei-dao-tou-da-yin-lian-biao/</url>
      
        <content type="html"><![CDATA[<ul><li>前言：题目顺序 不严格按照剑指offer的题目顺序，有些过于简单的，涉及不到算法的，不适合用Python解决的题目，不会被记录。 </li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>本题目中的链表，特指的是单链表。</p><h4 id="单链表定义"><a href="#单链表定义" class="headerlink" title="单链表定义"></a>单链表定义</h4><p>线性表的链式存储结构的特点是用一组<strong>任意</strong>的存储单元存储线性表中的数据元素，这组存储单元可以存放在内存中未被占用的<strong>任意位置</strong>。</p><p><img src="%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表结构图，来源于维基百科"></p><p><strong>数据域</strong>：存储数据元素信息的域，<strong>指针域</strong>：存储直接后继位置的域。指针域中存储的信息成为指针或链。</p><p>链表相比于顺序表，最大特点是某一个节点不仅保存当前节点的数据，还通过指针指示了上一个或者下一个节点的地址（单链表仅指向下一个节点）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>但是因为链表中的元素在内存中是随机存储，并不像顺序表的顺序存储，所以链表不支持随机存取的方式，只能通过指针域的指针决定下一个搜索位置。</p><p>因此，对于单链表来说，按照链表顺序读取的方式，只支持从头结点（或者附加头结点）挨个读取到尾节点，想要逆向读取，需要用到 <strong>递归</strong> 的方法。</p><p>具体流程为：从头结点依次读取节点，如果节点的指针域不为空，即存在后继节点，则将该节点压入递归栈中，直到遇到没有后继节点的尾节点，将尾节点的数据域存入ArrayList中，在依次将栈中的节点弹出，并将弹出节点的数据域追加在ArrayList。</p><p>过程比较简单，就不画图演示了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>逐个遍历节点，并且压入栈的时间复杂度为 $O(n)$ 。</p><p>弹出栈并且追加到ArrayList中的时间复杂度也为$O(n)$。</p><p>所以，总的时间复杂度为$O(n)$。</p><p>空间复杂度，因为需要用到递归栈来存储递归过程中的节点，故空间复杂度为$O(n)$。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><img src="%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.png" alt="双向循环链表节点图"></p><p><img src="%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表结构图"></p><p>如果是双向循环链表的话，每个节点不仅指示下一个节点的地址，还指示了上一个节点的地址，则可以从尾节点反向依次查找，并且由于是循环链表，可以直接从头结点找到尾节点，而不需要把链表轮询一遍。</p><p>则时间复杂度为$O(n)$，空间复杂度为$O(1)$。查找的空间复杂大大降低，不过由于每个节点多了一个指针域，需要消耗更多的存储空间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding:utf-8 -*-</span><span class="token comment" spellcheck="true"># 单链表节点的类定义</span><span class="token comment" spellcheck="true"># class ListNode:</span><span class="token comment" spellcheck="true">#     def __init__(self, x):</span><span class="token comment" spellcheck="true">#         self.val = x  # 数据域</span><span class="token comment" spellcheck="true">#         self.next = None  # 指针域</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span>    <span class="token keyword">def</span> <span class="token function">printListFromTailToHead</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> listNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write code here</span>        <span class="token keyword">if</span> listNode <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 递归运算，返回值用到了Python的特性，列表的+操作为将2个列表拼接在一起。</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>printListFromTailToHead<span class="token punctuation">(</span>listNode<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>listNode<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每周一道编程题——二维数组的查找</title>
      <link href="/2019/02/17/er-wei-shu-zu-zhong-de-cha-zhao/"/>
      <url>/2019/02/17/er-wei-shu-zu-zhong-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h3 id="逐个遍历"><a href="#逐个遍历" class="headerlink" title="逐个遍历"></a>逐个遍历</h3><p>这种题目思路不难，最直接的想法只需要挨个遍历即可。这个方法的问题在于，时间复杂度比较高。</p><h3 id="优化查找"><a href="#优化查找" class="headerlink" title="优化查找"></a>优化查找</h3><p>为了加快搜索速度，就需要用到题目中给的额外信息：<em>“每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序”</em> 。</p><p>我们会尝试着画出这个数组的矩阵形式，以下图为例：</p><p><img src="matrix.png" alt="矩阵A"></p><p>当我们对目标数进行查找的时候会有三种情况：</p><ul><li>当前数比目标数大，则目标数在当前数的左上角</li><li>当前数比目标数小，则目标数在当前数的右下角</li><li>当前数等于目标数，搜索结束</li></ul><p>所以我们对遍历的起点做了一点改变，我们不再是逐行再逐列搜索，而是从左下角（或者右上角）作为起点。</p><p>比如，设要搜索的整数为m，数组A的大小为n*n，我们从左下角开始，m先和左下角的<code>A[n-1][0]</code>做比较，如果m&gt;<code>A[n-1][0]</code>, 则m已经大于第一列的任何数，只需要右移一位，再和<code>A[n-1][1]</code>比较；如果m&lt;<code>A[n-1][0]</code>, 则m已经小于最后一行的任何数，只需要上移一位，再和<code>A[n-2][0]</code>比较。依次迭代，即可找到该整数，当没法上移或者右移且没有找到该数，则说明这个数不在二维数组中。</p><p>从右上角查找的过程也是类似的。</p><p><img src="matrix2.png" alt="查找过程"></p><p>以上面的矩阵A为例，设要查找的数为2.5，则查找过程如上图，最后无法继续移动，则查找结束，该数不存在。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p> 逐行挨个遍历的时间复杂度很简单，为 $O(n^2)$ 。</p><p>优化后的方法，比对的次数最多为2*n - 1，所以算法的复杂度为 $O(n)$。</p><p>从顺序查找的$O(n^2)$ 降低到$O(n)$，优化后时间复杂度为原来的的对数。可以联想到，长度为n的有序一维数组顺序查找，复杂度为$O(n)$，而使用二分法查找的时间复杂度为$O(log_2n)$，同样为原来的对数。</p><p>没错，因为二维数组内部存在了有序关系，所以实际上我们也是用到了二分法的思想。</p><p>具体二维数组的有序性可以参考下面的图：</p><p><img src="matrix_sort.png" alt="二维数组的有序性"></p><p>图中的红色框和蓝色框，表示从二维数组中抽取出来的两个一维数组。（这里采用的是先取列再取行的抽取方法，先取行再取列也是一样的）</p><p>很显然，这些一维数组都是递增有序的。</p><p>对于二维矩阵A，假设我们以左上角作为起点，开始查找，则开始的位置处于递增一维有序数组的开头，而当我们从左下角开始查找，开始的位置处于一维有序数组的中间位置，比对一次后，便可以排除最多n个元素。然后相应地移动到另外一个一维有序数组中进行比对。</p><p>比如上图的矩阵，m先与左下角的4比对，对应的一维有序数组为红色框的数组，m小于4,则比对位置移动至上一行的3，对应的一维有序数组为蓝色框的数组。在这一步过程中，排除掉了最后一行的n个元素。</p><p>相比之下，逐点比对，每一次比对只能排除掉一个元素。因此大大降低列时间复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding:utf-8 -*-</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># array 二维列表</span>    <span class="token keyword">def</span> <span class="token function">Find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># write code here</span>        <span class="token comment" spellcheck="true"># 从右上角开始查找</span>        i <span class="token operator">=</span> <span class="token number">0</span>        j <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>         row <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#获取矩阵的shape</span>        flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">while</span> i<span class="token operator">&lt;</span>row <span class="token operator">and</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target<span class="token operator">></span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token keyword">elif</span> target<span class="token operator">&lt;</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                j<span class="token operator">-=</span><span class="token number">1</span>            <span class="token keyword">elif</span> target <span class="token operator">==</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                flag <span class="token operator">=</span> <span class="token boolean">True</span>                <span class="token keyword">break</span>        <span class="token keyword">return</span> flag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2019/02/16/sort-algorithms/"/>
      <url>/2019/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Blog</title>
      <link href="/2019/02/15/hello-world/"/>
      <url>/2019/02/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前也用过hexo框架生成的博客，当时部署在了国内的coding上面，速度会稳定一些，只是要在你的博客上给coding打个广告。</p><p>GitHub没有这个限制，but访问的时候，可能会遇到图片加载慢的问题。</p><p>其实如果有备案好的域名，也可以直接把静态文件放在七牛云、腾讯上面，还可以获得CDN加速的效果，免费的流量应该也够用。可惜我懒得备案，反正现在博客访问的人也不多，等到以后内容多了，可能又要搬家了吧，maybe。</p><p>放在GitHub上的静态文件，也有一些trick可以加速访问。这个放在TODO里面，以后研究一下吧。</p><p>That’s all！</p><p>Hello world again！</p>]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
