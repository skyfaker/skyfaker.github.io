<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis简介</title>
      <link href="/2024/06/20/redis-jian-jie/"/>
      <url>/2024/06/20/redis-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>Redis（全称为Remote Dictionary Server）是一个开源的高性能键值对存储系统，具有快速、灵活和可扩展的特性。它是一个基于内存的数据结构存储系统，可以用作数据库、缓存和消息代理。</p><h2 id="Redis-的主要特点和用途："><a href="#Redis-的主要特点和用途：" class="headerlink" title="Redis 的主要特点和用途："></a>Redis 的主要特点和用途：</h2><ul><li>高性能：Redis 数据存储在内存中，因此能够提供极快的读写操作。它采用单线程模型和异步 I/O，避免了多线程的竞争和阻塞，从而达到了非常高的性能。</li><li>数据结构多样：Redis 支持多种数据结构，包括字符串（String）、哈希（Hash）、列表（List）、集合（Set）和有序集合（Sorted Set）。</li><li>持久化支持：Redis 提供了两种持久化方式，即快照（Snapshotting）和日志追加（Append-only file，AOF）。快照方式将 Redis 内存数据以二进制格式写入磁盘，而 AOF 则通过追加记录 Redis 的操作命令来实现持久化。</li><li>发布/订阅：Redis 支持发布/订阅模式，可以用作消息代理。发布者将消息发送到指定的频道，订阅者则可以接收和处理这些消息。这种模式在构建实时通信、事件驱动系统和消息队列等场景中非常有用。</li><li>分布式缓存：Redis可以通过主从复制和分片来实现数据的分布式存储和高可用性。主从复制可以将数据复制到多个从节点，实现读写分离和数据备份。而分片则可以将数据分布在多个Redis节点上，实现横向扩展和负载均衡。</li><li>事务支持：Redis 支持事务，开发者可以将多个操作组合成一个原子性的操作序列，保证这些操作要么全部执行成功，要么全部不执行。</li><li>功能丰富：Redis不仅仅是一个简单的缓存，它还提供了许多其他功能，如事务支持、Lua脚本执行、定时任务、原子操作等。这使得开发者可以在Redis中实现更复杂的应用逻辑。</li></ul><h2 id="Redis-与其他-key-value-存储有什么不同？"><a href="#Redis-与其他-key-value-存储有什么不同？" class="headerlink" title="Redis 与其他 key-value 存储有什么不同？"></a>Redis 与其他 key-value 存储有什么不同？</h2><ul><li>Redis 比起其它键值类数据库，值可以包含更复杂的数据类型，并且在数据类型上定义原子操作。Redis 数据类型与基本数据结构密切相关，并直接向程序员公开，无需额外的抽象层。</li><li>Redis 运行在内存中，因此性能极高 – Redis能读的速度是110000次/s，写的速度是81000次/s ，并且可以持久化到磁盘。内存数据库的另一个优点是，与磁盘上的相同数据结构相比，复杂数据结构的内存表示更易于操作，因此 Redis 可以做很多事情而内部复杂性很小。</li></ul><h2 id="Redis-架构"><a href="#Redis-架构" class="headerlink" title="Redis 架构"></a>Redis 架构</h2><p>Redis 主要由有两个程序组成：</p><ul><li>Redis 客户端 redis-cli</li><li>Redis 服务器 redis-server</li></ul><p><code>redis-server</code> 是 <strong>Redis 服务器程序</strong>，也就是启动 Redis 服务的命令。作用是启动 Redis 服务，负责数据的存储和管理。客户端、服务器可以位于同一台计算机或两台不同的计算机中。Redis-server运行后会开启一个 Redis 实例，监听客户端连接，处理读写请求、持久化、订阅发布等功能。</p><p><code>redis-cli</code> 是 <strong>Redis 官方的命令行工具</strong>，用来连接 Redis 服务器并与之交互。你可以用它执行 Redis 命令，比如 <code>get</code>、<code>set</code>、<code>keys</code>、<code>flushall</code> 等。作用是连接 Redis 服务器并发送命令进行调试或操作。</p><p>一般在项目中，我们不会直接使用redis-cli，而是会使用编程语言的redis模块作为客户端，直接和redis-server交互。例如python中，会使用python的redis模块。或者使用celery这样的消息队列模块，将redis-server作为消息后端。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>Redis 官方不建议在 windows 下使用 Redis，所以官网没有 windows 版本可以下载。如果你必须要在windows下使用redis，微软团队维护了开源的 windows 版本。尽管如此，windows系统下更推荐使用wsl +Redis。</p><h3 id="Ubuntu下安装"><a href="#Ubuntu下安装" class="headerlink" title="Ubuntu下安装"></a>Ubuntu下安装</h3><p>在 Ubuntu 系统安装 Redi 可以使用以下命令:</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">sudo</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">apt-get</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">update</span></span><span class="line"><span style="color: #61AFEF">sudo</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">apt-get</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">redis-server</span></span></code></pre></div></div></figure><h4 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">redis-server</span></span></code></pre></div></div></figure><h4 id="查看-redis-是否启动"><a href="#查看-redis-是否启动" class="headerlink" title="查看 redis 是否启动"></a>查看 redis 是否启动</h4><p>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">redis-cli</span></span></code></pre></div></div></figure><p>以上命令将打开以下终端：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">redis</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">127.0</span><span style="color: #98C379">.0.1:637</span><span style="color: #ABB2BF">9&gt;</span></span></code></pre></div></div></figure><p>127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">redis</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">127.0</span><span style="color: #98C379">.0.1:637</span><span style="color: #ABB2BF">9&gt; </span><span style="color: #98C379">ping</span></span><span class="line"><span style="color: #61AFEF">PONG</span></span></code></pre></div></div></figure><p>以上说明我们已经成功安装了redis。</p><h3 id="Docker安装（推荐）"><a href="#Docker安装（推荐）" class="headerlink" title="Docker安装（推荐）"></a>Docker安装（推荐）</h3><h4 id="拉取最新镜像"><a href="#拉取最新镜像" class="headerlink" title="拉取最新镜像"></a>拉取最新镜像</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 拉取官方的最新版本的镜像：</span></span><span class="line"><span style="color: #61AFEF">docker</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pull</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">redis:latest</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 查看是否已安装了 redis：</span></span><span class="line"><span style="color: #61AFEF">docker</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">images</span></span></code></pre></div></div></figure><h4 id="运行redis容器"><a href="#运行redis容器" class="headerlink" title="运行redis容器"></a>运行redis容器</h4><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">docker run -d --name redis-test -p 6379:6379 redis</span></span></code></pre></div></div></figure><h4 id="基于配置文件运行redis容器"><a href="#基于配置文件运行redis容器" class="headerlink" title="基于配置文件运行redis容器"></a>基于配置文件运行redis容器</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf"># 限制redis只能本地访问</span></span><span class="line"><span style="color: #abb2bf"># bind 127.0.0.1 -::1</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">protected-mode yes # 默认 yes，开启保护模式，限制为本地访问</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">daemonize no # 默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方式启动redis失败</span></span><span class="line"><span style="color: #abb2bf"># 【强制建议】 将 daemonize yes 注释起来或 daemonize no设置，因为该配置和docker run中 -d 参数冲突，会导致容器一直启动失败</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">databases 16 # 数据库个数（可选）</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">dir  ./ # 输入本地redis数据库存放文件夹，默认即 ./（可选）</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">appendonly yes # redis持久化，默认：no（可选）</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">logfile &quot;redis.log&quot; # 日志文件，默认 &quot;&quot;。 &quot;redis.log&quot; 对应的物理存储目录: /data/redis/data/redis.log | Specify the log file name. Also the empty string can be used to force . Redis to log on the standard output. Note that if you use standard output for logging but daemonize, logs will be sent to /dev/null</span></span><span class="line"><span style="color: #abb2bf"> </span></span><span class="line"><span style="color: #abb2bf">requirepass 123456 # 设置密码。</span></span></code></pre></div></div></figure><h5 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">docker run \</span></span><span class="line"><span style="color: #abb2bf">--restart always \</span></span><span class="line"><span style="color: #abb2bf">-p 6379:6379 --name redis \</span></span><span class="line"><span style="color: #abb2bf">--privileged=true \</span></span><span class="line"><span style="color: #abb2bf">-v /data/redis/redis.conf:/etc/redis/redis.conf \</span></span><span class="line"><span style="color: #abb2bf">-v /data/redis/data:/data:rw \</span></span><span class="line"><span style="color: #abb2bf">-d redis redis-server /etc/redis/redis.conf \</span></span><span class="line"><span style="color: #abb2bf">--appendonly yes</span></span></code></pre></div></div></figure><blockquote><ul><li><code>-p 6379:6379</code> : 第1个 6379 端口：是指宿主机的映射端口 ; 第2个 6379 端口：是指容器的被映射端口</li><li><code>-d</code> : 后台启动redis</li><li><code>redis-server /etc/redis/redis.conf</code> : 以配置文件启动redis，加载容器内的conf文件。docker 镜像 redis 默认 无配置文件启动。</li><li><code>--appendonly yes</code> : 开启 redis 持久化</li><li><code>--requirepass &quot;123456&quot;</code> : 设置认证密码 【此处没选择这种方式】</li></ul></blockquote><h5 id="检查启动日志"><a href="#检查启动日志" class="headerlink" title="检查启动日志"></a>检查启动日志</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">docker logs redis-test</span></span></code></pre></div></div></figure><h2 id="Python-Redis"><a href="#Python-Redis" class="headerlink" title="Python Redis"></a>Python Redis</h2><h3 id="安装redis模块"><a href="#安装redis模块" class="headerlink" title="安装redis模块"></a>安装redis模块</h3><p>在开始之前，请确保已经安装好了Redis及RedisPy库。</p><p>在此之前，我们已经通过Docker安装并启动了Redis，因此还需要安装python的redis 模块。</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">pip install redis</span></span></code></pre></div></div></figure><p>redis模块提供两个类<code>Redis</code>和<code>StrictRedis</code>来实现Redis的命令操作。官方推荐使用<code>StrictRedis</code>，所以本节中我们也用<code>StrictRedis类</code>的相关方法作演示。</p><h3 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h3><p>现在我们已经在本地安装了Redis并运行在6379端口，密码设置为foobared。那么，可以用如下示例连接Redis并测试：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">from redis import StrictRedis</span></span><span class="line"><span style="color: #abb2bf">redis = StrictRedis(host=&#39;localhost&#39;, port=6379, db=0)  </span></span><span class="line"><span style="color: #abb2bf"># 存在密码的话：可以设定password=&#39;yourpassword&#39;</span></span><span class="line"><span style="color: #abb2bf"># redis 取出的结果默认是字节，可以设定 decode_responses=True 改成字符串。</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">redis.set(&#39;name&#39;, &#39;Bob&#39;)</span></span><span class="line"><span style="color: #abb2bf">print(redis.get(&#39;name&#39;))</span></span></code></pre></div></div></figure><p><img src="https://skyfaker-hexo-blog.oss-cn-shanghai.aliyuncs.com/post-image/redis%E7%AE%80%E4%BB%8B/python-redis.png" style="zoom:50%;" alt="python-redis" /></p><h3 id="redis操作"><a href="#redis操作" class="headerlink" title="redis操作"></a>redis操作</h3><h4 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h4><p>redis是一个键值对存储系统，对于键的常用操作如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th><th style="text-align:left">参数说明</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">示例结果</th></tr></thead><tbody><tr><td style="text-align:left">exists(name)</td><td style="text-align:left">判断一个键是否存在</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.exists(‘name’)</td><td style="text-align:left">是否存在name这个键</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">delete(name)</td><td style="text-align:left">删除一个键</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.delete(‘name’)</td><td style="text-align:left">删除name这个键</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">type(name)</td><td style="text-align:left">判断键类型</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.type(‘name’)</td><td style="text-align:left">判断name这个键类型</td><td style="text-align:left">b’string’</td></tr><tr><td style="text-align:left">keys(pattern)</td><td style="text-align:left">获取所有符合规则的键</td><td style="text-align:left">pattern：匹配规则</td><td style="text-align:left">redis.keys(‘n*’)</td><td style="text-align:left">获取所有以n开头的键</td><td style="text-align:left">[b’name’]</td></tr><tr><td style="text-align:left">randomkey()</td><td style="text-align:left">获取随机的一个键</td><td style="text-align:left"></td><td style="text-align:left">randomkey()</td><td style="text-align:left">获取随机的一个键</td><td style="text-align:left">b’name’</td></tr><tr><td style="text-align:left">rename(src, dst)</td><td style="text-align:left">重命名键</td><td style="text-align:left">src：原键名；dst：新键名</td><td style="text-align:left">redis.rename(‘name’, ‘nickname’)</td><td style="text-align:left">将name重命名为nickname</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">dbsize()</td><td style="text-align:left">获取当前数据库中键的数目</td><td style="text-align:left"></td><td style="text-align:left">dbsize()</td><td style="text-align:left">获取当前数据库中键的数目</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">expire(name, time)</td><td style="text-align:left">设定键的过期时间，单位为秒</td><td style="text-align:left">name：键名；time：秒数</td><td style="text-align:left">redis.expire(‘name’, 2)</td><td style="text-align:left">将name键的过期时间设置为2秒</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">ttl(name)</td><td style="text-align:left">获取键的过期时间，单位为秒，-1表示永久不过期</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.ttl(‘name’)</td><td style="text-align:left">获取name这个键的过期时间</td><td style="text-align:left">-1</td></tr><tr><td style="text-align:left">move(name, db)</td><td style="text-align:left">将键移动到其他数据库</td><td style="text-align:left">name：键名；db：数据库代号</td><td style="text-align:left">move(‘name’, 2)</td><td style="text-align:left">将name移动到2号数据库</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">flushdb()</td><td style="text-align:left">删除当前选择数据库中的所有键</td><td style="text-align:left"></td><td style="text-align:left">flushdb()</td><td style="text-align:left">删除当前选择数据库中的所有键</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">flushall()</td><td style="text-align:left">删除所有数据库中的所有键</td><td style="text-align:left"></td><td style="text-align:left">flushall()</td><td style="text-align:left">删除所有数据库中的所有键</td><td style="text-align:left">True</td></tr></tbody></table></div><h4 id="值操作"><a href="#值操作" class="headerlink" title="值操作"></a>值操作</h4><p>Redis中有以下几种值的类型，每种类型的操作不太一样：</p><ul><li>String: 字符串</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li><li>Hash: 散列</li></ul><h5 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h5><p>Redis最基本的键值对形式存储：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th><th style="text-align:left">参数说明</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">示例结果</th></tr></thead><tbody><tr><td style="text-align:left">set(name, value)</td><td style="text-align:left">给数据库中键为name的string赋予值value</td><td style="text-align:left">name: 键名；value: 值</td><td style="text-align:left">redis.set(‘name’, ‘Bob’)</td><td style="text-align:left">给name这个键的value赋值为Bob</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">get(name)</td><td style="text-align:left">返回数据库中键为name的string的value</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.get(‘name’)</td><td style="text-align:left">返回name这个键的value</td><td style="text-align:left">b’Bob’</td></tr><tr><td style="text-align:left">getset(name, value)</td><td style="text-align:left">给数据库中键为name的string赋予值value并返回上次的value</td><td style="text-align:left">name：键名；value：新值</td><td style="text-align:left">redis.getset(‘name’, ‘Mike’)</td><td style="text-align:left">赋值name为Mike并得到上次的value</td><td style="text-align:left">b’Bob’</td></tr><tr><td style="text-align:left">mget(keys, *args)</td><td style="text-align:left">返回多个键对应的value</td><td style="text-align:left">keys：键的列表</td><td style="text-align:left">redis.mget([‘name’, ‘nickname’])</td><td style="text-align:left">返回name和nickname的value</td><td style="text-align:left">[b’Mike’, b’Miker’]</td></tr><tr><td style="text-align:left">setnx(name, value)</td><td style="text-align:left">如果不存在这个键值对，则更新value，否则不变</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.setnx(‘newname’, ‘James’)</td><td style="text-align:left">如果newname这个键不存在，则设置值为James</td><td style="text-align:left">第一次运行结果是True，第二次运行结果是False</td></tr><tr><td style="text-align:left">setex(name, time, value)</td><td style="text-align:left">设置可以对应的值为string类型的value，并指定此键值对应的有效期</td><td style="text-align:left">name: 键名；time: 有效期； value：值</td><td style="text-align:left">redis.setex(‘name’, 1, ‘James’)</td><td style="text-align:left">将name这个键的值设为James，有效期为1秒</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">setrange(name, offset, value)</td><td style="text-align:left">设置指定键的value值的子字符串</td><td style="text-align:left">name：键名；offset：偏移量；value：值</td><td style="text-align:left">redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’)</td><td style="text-align:left">设置name为Hello字符串，并在index为6的位置补World</td><td style="text-align:left">11，修改后的字符串长度</td></tr><tr><td style="text-align:left">mset(mapping)</td><td style="text-align:left">批量赋值</td><td style="text-align:left">mapping：字典</td><td style="text-align:left">redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’})</td><td style="text-align:left">将name1设为Durant，name2设为James</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">msetnx(mapping)</td><td style="text-align:left">键均不存在时才批量赋值</td><td style="text-align:left">mapping：字典</td><td style="text-align:left">redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’})</td><td style="text-align:left">在name3和name4均不存在的情况下才设置二者值</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">incr(name, amount=1)</td><td style="text-align:left">键为name的value增值操作，默认为1，键不存在则被创建并设为amount</td><td style="text-align:left">name：键名；amount：增长的值</td><td style="text-align:left">redis.incr(‘age’, 1)</td><td style="text-align:left">age对应的值增1，若不存在，则会创建并设置为1</td><td style="text-align:left">1，即修改后的值</td></tr><tr><td style="text-align:left">decr(name, amount=1)</td><td style="text-align:left">键为name的value减值操作，默认为1，键不存在则被创建并将value设置为-amount</td><td style="text-align:left">name：键名； amount：减少的值</td><td style="text-align:left">redis.decr(‘age’, 1)</td><td style="text-align:left">age对应的值减1，若不存在，则会创建并设置为-1</td><td style="text-align:left">-1，即修改后的值</td></tr><tr><td style="text-align:left">append(key, value)</td><td style="text-align:left">键为name的string的值附加value</td><td style="text-align:left">key：键名</td><td style="text-align:left">redis.append(‘nickname’, ‘OK’)</td><td style="text-align:left">向键为nickname的值后追加OK</td><td style="text-align:left">13，即修改后的字符串长度</td></tr><tr><td style="text-align:left">substr(name, start, end=-1)</td><td style="text-align:left">返回键为name的string的子串</td><td style="text-align:left">name：键名；start：起始索引；end：终止索引，默认为-1，表示截取到末尾</td><td style="text-align:left">redis.substr(‘name’, 1, 4)</td><td style="text-align:left">返回键为name的值的字符串，截取索引为1~4的字符</td><td style="text-align:left">b’ello’</td></tr><tr><td style="text-align:left">getrange(key, start, end)</td><td style="text-align:left">获取键的value值从start到end的子字符串</td><td style="text-align:left">key：键名；start：起始索引；end：终止索引</td><td style="text-align:left">redis.getrange(‘name’, 1, 4)</td><td style="text-align:left">返回键为name的值的字符串，截取索引为1~4的字符</td><td style="text-align:left">b’ello’</td></tr></tbody></table></div><h5 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h5><p>Redis还提供了列表存储，列表内的元素可以重复，而且可以从两端存储，用法如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th><th style="text-align:left">参数说明</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">示例结果</th></tr></thead><tbody><tr><td style="text-align:left">rpush(name, *values)</td><td style="text-align:left">在键为name的列表末尾添加值为value的元素，可以传多个</td><td style="text-align:left">name：键名；values：值</td><td style="text-align:left">redis.rpush(‘list’, 1, 2, 3)</td><td style="text-align:left">向键为list的列表尾添加1、2、3</td><td style="text-align:left">3，列表大小</td></tr><tr><td style="text-align:left">lpush(name, *values)</td><td style="text-align:left">在键为name的列表头添加值为value的元素，可以传多个</td><td style="text-align:left">name：键名；values：值</td><td style="text-align:left">redis.lpush(‘list’, 0)</td><td style="text-align:left">向键为list的列表头部添加0</td><td style="text-align:left">4，列表大小</td></tr><tr><td style="text-align:left">llen(name)</td><td style="text-align:left">返回键为name的列表的长度</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.llen(‘list’)</td><td style="text-align:left">返回键为list的列表的长度</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">lrange(name, start, end)</td><td style="text-align:left">返回键为name的列表中start至end之间的元素</td><td style="text-align:left">name：键名；start：起始索引；end：终止索引</td><td style="text-align:left">redis.lrange(‘list’, 1, 3)</td><td style="text-align:left">返回起始索引为1终止索引为3的索引范围对应的列表</td><td style="text-align:left">[b’3’, b’2’, b’1’]</td></tr><tr><td style="text-align:left">ltrim(name, start, end)</td><td style="text-align:left">截取键为name的列表，保留索引为start到end的内容</td><td style="text-align:left">name：键名；start：起始索引；end：终止索引</td><td style="text-align:left">ltrim(‘list’, 1, 3)</td><td style="text-align:left">保留键为list的索引为1到3的元素</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">lindex(name, index)</td><td style="text-align:left">返回键为name的列表中index位置的元素</td><td style="text-align:left">name：键名；index：索引</td><td style="text-align:left">redis.lindex(‘list’, 1)</td><td style="text-align:left">返回键为list的列表索引为1的元素</td><td style="text-align:left">b’2’</td></tr><tr><td style="text-align:left">lset(name, index, value)</td><td style="text-align:left">给键为name的列表中index位置的元素赋值，越界则报错</td><td style="text-align:left">name：键名；index：索引位置；value：值</td><td style="text-align:left">redis.lset(‘list’, 1, 5)</td><td style="text-align:left">将键为list的列表中索引为1的位置赋值为5</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">lrem(name, count, value)</td><td style="text-align:left">删除count个键的列表中值为value的元素</td><td style="text-align:left">name：键名；count：删除个数；value：值</td><td style="text-align:left">redis.lrem(‘list’, 2, 3)</td><td style="text-align:left">将键为list的列表删除两个3</td><td style="text-align:left">1，即删除的个数</td></tr><tr><td style="text-align:left">lpop(name)</td><td style="text-align:left">返回并删除键为name的列表中的首元素</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.lpop(‘list’)</td><td style="text-align:left">返回并删除名为list的列表中的第一个元素</td><td style="text-align:left">b’5’</td></tr><tr><td style="text-align:left">rpop(name)</td><td style="text-align:left">返回并删除键为name的列表中的尾元素</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.rpop(‘list’)</td><td style="text-align:left">返回并删除名为list的列表中的最后一个元素</td><td style="text-align:left">b’2’</td></tr><tr><td style="text-align:left">blpop(keys, timeout=0)</td><td style="text-align:left">返回并删除名称在keys中的list中的首个元素，如果list为空，则会一直阻塞等待，超时或发现可弹出元素为止。</td><td style="text-align:left">keys：键列表；timeout： 超时等待时间，0为一直等待</td><td style="text-align:left">redis.blpop(‘list’)</td><td style="text-align:left">返回并删除键为list的列表中的第一个元素</td><td style="text-align:left">[b’5’]</td></tr><tr><td style="text-align:left">brpop(keys, timeout=0)</td><td style="text-align:left">返回并删除键为name的列表中的尾元素，如果list为空，则会一直阻塞等待，超时或发现可弹出元素为止。</td><td style="text-align:left">keys：键列表；timeout：超时等待时间，0为一直等待</td><td style="text-align:left">redis.brpop(‘list’)</td><td style="text-align:left">返回并删除名为list的列表中的最后一个元素</td><td style="text-align:left">[b’2’]</td></tr><tr><td style="text-align:left">rpoplpush(src, dst)</td><td style="text-align:left">返回并删除名称为src的列表的尾元素，并将该元素添加到名称为dst的列表头部</td><td style="text-align:left">src：源列表的键；dst：目标列表的key</td><td style="text-align:left">redis.rpoplpush(‘list’, ‘list2’)</td><td style="text-align:left">将键为list的列表尾元素删除并将其添加到键为list2的列表头部，然后返回</td><td style="text-align:left">b’2’</td></tr></tbody></table></div><h5 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h5><p>Redis还提供了集合存储，集合中的元素都是不重复的，用法如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">方法</td><td style="text-align:left">作用</td><td style="text-align:left">参数说明</td><td style="text-align:left">示例</td><td style="text-align:left">示例说明</td><td style="text-align:left">示例结果</td></tr><tr><td style="text-align:left">sadd(name, *values)</td><td style="text-align:left">向键为name的集合中添加元素</td><td style="text-align:left">name：键名；values：值，可为多个</td><td style="text-align:left">redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’)</td><td style="text-align:left">向键为tags的集合中添加Book、Tea和Coffee这3个内容</td><td style="text-align:left">3，即插入的数据个数</td></tr><tr><td style="text-align:left">smembers(name)</td><td style="text-align:left">返回键为name的集合的所有元素</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.smembers(‘tags’)</td><td style="text-align:left">返回键为tags的集合的所有元素</td><td style="text-align:left">{b’Pen’, b’Book’, b’Coffee’}</td></tr><tr><td style="text-align:left">srem(name, *values)</td><td style="text-align:left">从键为name的集合中删除元素</td><td style="text-align:left">name：键名；values：值，可为多个</td><td style="text-align:left">redis.srem(‘tags’, ‘Book’)</td><td style="text-align:left">从键为tags的集合中删除Book</td><td style="text-align:left">1，即删除的数据个数</td></tr><tr><td style="text-align:left">spop(name)</td><td style="text-align:left">随机返回并删除键为name的集合中的一个元素</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.spop(‘tags’)</td><td style="text-align:left">从键为tags的集合中随机删除并返回该元素</td><td style="text-align:left">b’Tea’</td></tr><tr><td style="text-align:left">smove(src, dst, value)</td><td style="text-align:left">从src对应的集合中移除元素并将其添加到dst对应的集合中</td><td style="text-align:left">src：源集合；dst：目标集合；value：元素值</td><td style="text-align:left">redis.smove(‘tags’, ‘tags2’, ‘Coffee’)</td><td style="text-align:left">从键为tags的集合中删除元素Coffee并将其添加到键为tags2的集合</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">scard(name)</td><td style="text-align:left">返回键为name的集合的元素个数</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.scard(‘tags’)</td><td style="text-align:left">获取键为tags的集合中的元素个数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">sismember(name, value)</td><td style="text-align:left">测试member是否是键为name的集合的元素</td><td style="text-align:left">name：键值</td><td style="text-align:left">redis.sismember(‘tags’, ‘Book’)</td><td style="text-align:left">判断Book是否是键为tags的集合元素</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">sinter(keys, *args)</td><td style="text-align:left">返回所有给定键的集合的交集</td><td style="text-align:left">keys：键列表</td><td style="text-align:left">redis.sinter([‘tags’, ‘tags2’])</td><td style="text-align:left">返回键为tags的集合和键为tags2的集合的交集</td><td style="text-align:left">{b’Coffee’}</td></tr><tr><td style="text-align:left">sinterstore(dest, keys, *args)</td><td style="text-align:left">求交集并将交集保存到dest的集合</td><td style="text-align:left">dest：结果集合；keys：键列表</td><td style="text-align:left">redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’])</td><td style="text-align:left">求键为tags的集合和键为tags2的集合的交集并将其保存为inttag</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">sunion(keys, *args)</td><td style="text-align:left">返回所有给定键的集合的并集</td><td style="text-align:left">keys：键列表</td><td style="text-align:left">redis.sunion([‘tags’, ‘tags2’])</td><td style="text-align:left">返回键为tags的集合和键为tags2的集合的并集</td><td style="text-align:left">{b’Coffee’, b’Book’, b’Pen’}</td></tr><tr><td style="text-align:left">sunionstore(dest, keys, *args)</td><td style="text-align:left">求并集并将并集保存到dest的集合</td><td style="text-align:left">dest：结果集合；keys：键列表</td><td style="text-align:left">redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’])</td><td style="text-align:left">求键为tags的集合和键为tags2的集合的并集并将其保存为inttag</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">sdiff(keys, *args)</td><td style="text-align:left">返回所有给定键的集合的差集</td><td style="text-align:left">keys：键列表</td><td style="text-align:left">redis.sdiff([‘tags’, ‘tags2’])</td><td style="text-align:left">返回键为tags的集合和键为tags2的集合的差集</td><td style="text-align:left">{b’Book’, b’Pen’}</td></tr><tr><td style="text-align:left">sdiffstore(dest, keys, *args)</td><td style="text-align:left">求差集并将差集保存到dest集合</td><td style="text-align:left">dest：结果集合；keys：键列表</td><td style="text-align:left">redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’])</td><td style="text-align:left">求键为tags的集合和键为tags2的集合的差集并将其保存为inttag`</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">srandmember(name)</td><td style="text-align:left">随机返回键为name的集合中的一个元素，但不删除元素</td><td style="text-align:left">name：键值</td><td style="text-align:left">redis.srandmember(‘tags’)</td><td style="text-align:left">随机返回键为tags的集合中的一个元素</td></tr></tbody></table></div><h5 id="4-有序集合"><a href="#4-有序集合" class="headerlink" title="4. 有序集合"></a>4. 有序集合</h5><p>有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序，其用法总结如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th><th style="text-align:left">参数说明</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">示例结果</th></tr></thead><tbody><tr><td style="text-align:left">zadd(name, <em>args, *</em>kwargs)</td><td style="text-align:left">向键为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序</td><td style="text-align:left">name： 键名；args：可变参数</td><td style="text-align:left">redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’)</td><td style="text-align:left">向键为grade的zset中添加Bob（其score为100），并添加Mike（其score为98）</td><td style="text-align:left">2，即添加的元素个数</td></tr><tr><td style="text-align:left">zrem(name, *values)</td><td style="text-align:left">删除键为name的zset中的元素</td><td style="text-align:left">name：键名；values：元素</td><td style="text-align:left">redis.zrem(‘grade’, ‘Mike’)</td><td style="text-align:left">从键为grade的zset中删除Mike</td><td style="text-align:left">1，即删除的元素个数</td></tr><tr><td style="text-align:left">zincrby(name, value, amount=1)</td><td style="text-align:left">如果在键为name的zset中已经存在元素value，则将该元素的score增加amount；否则向该集合中添加该元素，其score的值为amount</td><td style="text-align:left">name：key名；value：元素；amount：增长的score值</td><td style="text-align:left">redis.zincrby(‘grade’, ‘Bob’, -2)</td><td style="text-align:left">键为grade的zset中Bob的score减2</td><td style="text-align:left">98.0，即修改后的值</td></tr><tr><td style="text-align:left">zrank(name, value)</td><td style="text-align:left">返回键为name的zset中元素的排名，按score从小到大排序，即名次</td><td style="text-align:left">name：键名；value：元素值</td><td style="text-align:left">redis.zrank(‘grade’, ‘Amy’)</td><td style="text-align:left">得到键为grade的zset中Amy的排名</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">zrevrank(name, value)</td><td style="text-align:left">返回键为name的zset中元素的倒数排名（按score从大到小排序），即名次</td><td style="text-align:left">name：键名；value：元素值</td><td style="text-align:left">redis.zrevrank(‘grade’, ‘Amy’)</td><td style="text-align:left">得到键为grade的zset中Amy的倒数排名</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">zrevrange(name, start, end, withscores=False)</td><td style="text-align:left">返回键为name的zset（按score从大到小排序）中index从start到end的所有元素</td><td style="text-align:left">name：键值；start：开始索引；end：结束索引；withscores：是否带score</td><td style="text-align:left">redis.zrevrange(‘grade’, 0, 3)</td><td style="text-align:left">返回键为grade的zset中前四名元素</td><td style="text-align:left">[b’Bob’, b’Mike’, b’Amy’, b’James’]</td></tr><tr><td style="text-align:left">zrangebyscore(name, min, max, start=None, num=None, withscores=False)</td><td style="text-align:left">返回键为name的zset中score在给定区间的元素</td><td style="text-align:left">name：键名；min：最低score；max：最高score； start：起始索引；num：个数；withscores：是否带score</td><td style="text-align:left">redis.zrangebyscore(‘grade’, 80, 95)</td><td style="text-align:left">返回键为grade的zset中score在80和95之间的元素</td><td style="text-align:left">[b’Bob’, b’Mike’, b’Amy’, b’James’]</td></tr><tr><td style="text-align:left">zcount(name, min, max)</td><td style="text-align:left">返回键为name的zset中score在给定区间的数量</td><td style="text-align:left">name：键名；min：最低score；max：最高score</td><td style="text-align:left">redis.zcount(‘grade’, 80, 95)</td><td style="text-align:left">返回键为grade的zset中score在80到95的元素个数</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">zcard(name)</td><td style="text-align:left">返回键为name的zset的元素个数</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.zcard(‘grade’)</td><td style="text-align:left">获取键为grade的zset中元素的个数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">zremrangebyrank(name, min, max)</td><td style="text-align:left">删除键为name的zset中排名在给定区间的元素</td><td style="text-align:left">name：键名；min：最低位次；max：最高位次</td><td style="text-align:left">redis.zremrangebyrank(‘grade’, 0, 0)</td><td style="text-align:left">删除键为grade的zset中排名第一的元素</td><td style="text-align:left">1，即删除的元素个数</td></tr><tr><td style="text-align:left">zremrangebyscore(name, min, max)</td><td style="text-align:left">删除键为name的zset中score在给定区间的元素</td><td style="text-align:left">name：键名；min：最低score；max：最高score</td><td style="text-align:left">redis.zremrangebyscore(‘grade’, 80, 90)</td><td style="text-align:left">删除score在80到90之间的元素</td><td style="text-align:left">1，即删除的元素个数</td></tr></tbody></table></div><h5 id="5-散列"><a href="#5-散列" class="headerlink" title="5. 散列"></a>5. 散列</h5><p>Redis还提供了散列表的数据结构，我们可以用<code>name</code>指定一个散列表的名称，表内存储了各个键值对，用法总结如下表所示。</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th><th style="text-align:left">参数说明</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">示例结果</th></tr></thead><tbody><tr><td style="text-align:left">hset(name, key, value)</td><td style="text-align:left">向键为name的散列表中添加映射</td><td style="text-align:left">name：键名；key：映射键名；value：映射键值</td><td style="text-align:left">hset(‘price’, ‘cake’, 5)</td><td style="text-align:left">向键为price的散列表中添加映射关系，cake的值为5</td><td style="text-align:left">1，即添加的映射个数</td></tr><tr><td style="text-align:left">hsetnx(name, key, value)</td><td style="text-align:left">如果映射键名不存在，则向键为name的散列表中添加映射</td><td style="text-align:left">name：键名；key：映射键名；value：映射键值</td><td style="text-align:left">hsetnx(‘price’, ‘book’, 6)</td><td style="text-align:left">向键为price的散列表中添加映射关系，book的值为6</td><td style="text-align:left">1，即添加的映射个数</td></tr><tr><td style="text-align:left">hget(name, key)</td><td style="text-align:left">返回键为name的散列表中key对应的值</td><td style="text-align:left">name：键名；key：映射键名</td><td style="text-align:left">redis.hget(‘price’, ‘cake’)</td><td style="text-align:left">获取键为price的散列表中键名为cake的值</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">hmget(name, keys, *args)</td><td style="text-align:left">返回键为name的散列表中各个键对应的值</td><td style="text-align:left">name：键名；keys：映射键名列表</td><td style="text-align:left">redis.hmget(‘price’, [‘apple’, ‘orange’])</td><td style="text-align:left">获取键为price的散列表中apple和orange的值</td><td style="text-align:left">[b’3’, b’7’]</td></tr><tr><td style="text-align:left">hmset(name, mapping)</td><td style="text-align:left">向键为name的散列表中批量添加映射</td><td style="text-align:left">name：键名；mapping：映射字典</td><td style="text-align:left">redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6})</td><td style="text-align:left">向键为price的散列表中批量添加映射</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">hincrby(name, key, amount=1)</td><td style="text-align:left">将键为name的散列表中映射的值增加amount</td><td style="text-align:left">name：键名；key：映射键名；amount：增长量</td><td style="text-align:left">redis.hincrby(‘price’, ‘apple’, 3)</td><td style="text-align:left">key为price的散列表中apple的值增加3</td><td style="text-align:left">6，修改后的值</td></tr><tr><td style="text-align:left">hexists(name, key)</td><td style="text-align:left">键为name的散列表中是否存在键名为键的映射</td><td style="text-align:left">name：键名；key：映射键名</td><td style="text-align:left">redis.hexists(‘price’, ‘banana’)</td><td style="text-align:left">键为price的散列表中banana的值是否存在</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">hdel(name, *keys)</td><td style="text-align:left">在键为name的散列表中，删除键名为键的映射</td><td style="text-align:left">name：键名；keys：映射键名</td><td style="text-align:left">redis.hdel(‘price’, ‘banana’)</td><td style="text-align:left">从键为price的散列表中删除键名为banana的映射</td><td style="text-align:left">True</td></tr><tr><td style="text-align:left">hlen(name)</td><td style="text-align:left">从键为name的散列表中获取映射个数</td><td style="text-align:left">name： 键名</td><td style="text-align:left">redis.hlen(‘price’)</td><td style="text-align:left">从键为price的散列表中获取映射个数</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">hkeys(name)</td><td style="text-align:left">从键为name的散列表中获取所有映射键名</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.hkeys(‘price’)</td><td style="text-align:left">从键为price的散列表中获取所有映射键名</td><td style="text-align:left">[b’cake’, b’book’, b’banana’, b’pear’]</td></tr><tr><td style="text-align:left">hvals(name)</td><td style="text-align:left">从键为name的散列表中获取所有映射键值</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.hvals(‘price’)</td><td style="text-align:left">从键为price的散列表中获取所有映射键值</td><td style="text-align:left">[b’5’, b’6’, b’2’, b’6’]</td></tr><tr><td style="text-align:left">hgetall(name)</td><td style="text-align:left">从键为name的散列表中获取所有映射键值对</td><td style="text-align:left">name：键名</td><td style="text-align:left">redis.hgetall(‘price’)</td><td style="text-align:left">从键为price的散列表中获取所有映射键值对</td><td style="text-align:left">{b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’}</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 工具方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uv教程</title>
      <link href="/2024/04/21/uv-jiao-cheng/"/>
      <url>/2024/04/21/uv-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-uv简介"><a href="#一、-uv简介" class="headerlink" title="一、 uv简介"></a>一、 uv简介</h2><p>相比 pip 与 venv 的使用，uv确实有一定的学习门槛。熟悉前端nodejs的同学应该会比较容易上手。</p><p>在介绍uv之前，先简单介绍一下python依赖等概念。</p><h3 id="模块管理、模块依赖管理"><a href="#模块管理、模块依赖管理" class="headerlink" title="模块管理、模块依赖管理"></a>模块管理、模块依赖管理</h3><p>模块是指虚拟环境中安装的第三方模块及其版本。大多数项目对第三方库的版本都是有特定要求，如果对旧版本的项目使用新版本的依赖，可能会报很奇怪的错误。</p><p>当安装第三方模块时，第三方模块可能会安装自己依赖的模块。当安装两个以上模块时，就可能出现第三方模块的依赖出现冲突。这种情况一般是依赖的版本冲突。这种就叫做相关性依赖</p><h3 id="pip-的不足"><a href="#pip-的不足" class="headerlink" title="pip 的不足"></a>pip 的不足</h3><p>pip 是 python 内置的依赖管理工具，它应该会是python开发者最常用的包管理命令。</p><p>而pip最大的不足在于 <code>第三方模块的相关性依赖管理</code> 的能力不足。尤其是在删除第三方模块是的依赖解析。</p><p>举个例子：安装python包A时，A需要先安装B，C。而在删除A时，pip并不知道A和B，C之间的关系，所以只会删除A，而不会处理B，C。</p><h3 id="uv的管理方式"><a href="#uv的管理方式" class="headerlink" title="uv的管理方式"></a>uv的管理方式</h3><p>uv的管理方式类似于poetry，它依靠自动生成的<code>pyproject.toml</code>和<code>uv.lock</code>文件管理依赖。</p><ul><li><code>pyproject.toml</code>：定义项目的主要依赖，包括项目名称、版本、描述、支持的 <code>Python</code> 版本等信息</li><li><code>uv.lock</code>：记录项目的所有依赖，包括依赖的依赖，且跨平台，确保在不同环境下安装的一致性。这个文件不要手动编辑。</li></ul><p>运行初始化命令<code>uv init</code>，会自动创建<code>pyproject.toml</code>文件。需要注意的是，虚拟环境目录<code>.venv</code>和lock文件<code>uv.lock</code>此时不会创建。</p><p>运行<code>uv add &lt;package&gt;</code>， 会做三件事：</p><ol><li>将你指定的package添加到pyproject.toml文件的<code>[dependencies]</code>下面；</li><li>同时修改<code>uv.lock</code>；</li><li>根据<code>uv.lock</code>，更新虚拟环境。</li></ol><p>所以基本上uv的使用过程就是：使用命令修改<code>pyproject.toml</code>，uv自动根据pyproject.toml修改<code>uv.lock</code>，uv根据<code>uv.lock</code>管理依赖。</p><h2 id="二、-uv教程"><a href="#二、-uv教程" class="headerlink" title="二、 uv教程"></a>二、 uv教程</h2><h3 id="（一）安装与环境配置"><a href="#（一）安装与环境配置" class="headerlink" title="（一）安装与环境配置"></a><strong>（一）安装与环境配置</strong></h3><h4 id="1-全平台一键安装（推荐方式）"><a href="#1-全平台一键安装（推荐方式）" class="headerlink" title="1. 全平台一键安装（推荐方式）"></a>1. 全平台一键安装（推荐方式）</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">BASH#</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">使用Astral官方安装脚本</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># On macOS and Linux.</span></span><span class="line"><span style="color: #61AFEF">curl</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-LsSf</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">https://astral.sh/uv/install.sh</span><span style="color: #ABB2BF"> | </span><span style="color: #61AFEF">sh</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># On Windows.</span></span><span class="line"><span style="color: #61AFEF">powershell</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-ExecutionPolicy</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">ByPass</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-c</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span></span></code></pre></div></div></figure><h4 id="2-pip-安装"><a href="#2-pip-安装" class="headerlink" title="2. pip 安装"></a>2. pip 安装</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 将uv安装到当前python环境</span></span><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">uv</span></span></code></pre></div></div></figure><p><em>输出示例</em>：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">✅</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">已安装uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">v0.18.0到</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">/home/user/.local/bin</span><span style="color: #ABB2BF">  </span></span><span class="line"><span style="color: #61AFEF">运行</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span><span style="color: #61AFEF">uv</span><span style="color: #98C379"> </span><span style="color: #D19A66">--version</span><span style="color: #98C379">`</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">验证安装</span></span></code></pre></div></div></figure><h4 id="2-环境变量配置（可选）"><a href="#2-环境变量配置（可选）" class="headerlink" title="2. 环境变量配置（可选）"></a>2. 环境变量配置（可选）</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">BASH#</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">将uv加入PATH（针对zsh/bash）</span></span><span class="line"><span style="color: #56B6C2">echo</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;export PATH=&quot;$HOME/.local/bin:$PATH&quot;&#39;</span><span style="color: #ABB2BF"> &gt;&gt; </span><span style="color: #98C379">~/.zshrc</span><span style="color: #ABB2BF">  </span></span><span class="line"><span style="color: #56B6C2">source</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">~/.zshrc</span></span></code></pre></div></div></figure><h4 id="3-版本升级与维护"><a href="#3-版本升级与维护" class="headerlink" title="3. 版本升级与维护"></a>3. 版本升级与维护</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">BASH#</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">检查更新</span></span><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">self</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">upgrade</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--channel=nightly</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 尝鲜版</span></span><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">self</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">upgrade</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--channel=stable</span><span style="color: #ABB2BF">   </span><span style="color: #7F848E; font-style: italic"># 稳定版</span></span></code></pre></div></div></figure><h4 id="4-uv移除"><a href="#4-uv移除" class="headerlink" title="4. uv移除"></a>4. uv移除</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 清楚缓存和工具（可选）</span></span><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">cache</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">clean</span></span><span class="line"><span style="color: #61AFEF">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;$(</span><span style="color: #61AFEF">uv</span><span style="color: #98C379"> python dir)&quot;</span></span><span class="line"><span style="color: #61AFEF">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;$(</span><span style="color: #61AFEF">uv</span><span style="color: #98C379"> tool dir)&quot;</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 移除</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># On macOS and Linux.</span></span><span class="line"><span style="color: #61AFEF">rm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">~/.local/bin/uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">~/.local/bin/uvx</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">#On windows</span></span><span class="line"><span style="color: #61AFEF">rm</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">$HOME</span><span style="color: #56B6C2">\.</span><span style="color: #98C379">local</span><span style="color: #56B6C2">\b</span><span style="color: #98C379">in</span><span style="color: #56B6C2">\u</span><span style="color: #98C379">v.exe</span></span><span class="line"><span style="color: #61AFEF">rm</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">$HOME</span><span style="color: #56B6C2">\.</span><span style="color: #98C379">local</span><span style="color: #56B6C2">\b</span><span style="color: #98C379">in</span><span style="color: #56B6C2">\u</span><span style="color: #98C379">vx.exe</span></span></code></pre></div></div></figure><hr><h3 id="（二）uv核心语法详解"><a href="#（二）uv核心语法详解" class="headerlink" title="（二）uv核心语法详解"></a><strong>（二）uv核心语法详解</strong></h3><h5 id="1-包管理基础命令"><a href="#1-包管理基础命令" class="headerlink" title="1. 包管理基础命令"></a>1. 包管理基础命令</h5><div class="table-container"><table><thead><tr><th style="text-align:left">命令格式</th><th style="text-align:left">作用描述</th><th style="text-align:left">示例场景</th></tr></thead><tbody><tr><td style="text-align:left">uv init</td><td style="text-align:left">初始化，创建pyproject.toml</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">uv add &lt; package &gt;</td><td style="text-align:left">修改pyproject.toml和uv.lock，安装&lt; package &gt;<br /><code>-r</code>参数可以从文件批量添加包，通常用于基于requirements.txt的pip环境迁移到uv环境</td><td style="text-align:left">uv add transformers<br />uv add -r requirements.txt</td></tr><tr><td style="text-align:left">uv remove &lt; package &gt;</td><td style="text-align:left">移除某个包</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">uv sync</td><td style="text-align:left">根据uv.lock，配置环境，安装uv.lock中所有的依赖</td><td style="text-align:left">拿到一个支持uv的开源项目，按照开源项目配置的环境，配置一个一模一样的本地环境</td></tr><tr><td style="text-align:left">uv lock</td><td style="text-align:left">创建uv.lock（如果没有），根据pyproject.toml更新uv.lock</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">uv export</td><td style="text-align:left">把uv.lock中的配置导出为requirements.txt</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">uv tree</td><td style="text-align:left">以树形列出依赖之间的关系</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">source .venv/bin/activate</td><td style="text-align:left">在命令行激活当前项目uv创建的环境</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">uv pip install</td><td style="text-align:left">uv pip install是uv提供的兼容pip的命令，允许用户继续使用熟悉的pip语法，但底层由uv加速。</td><td style="text-align:left">uv pip install主要用于直接安装包，不会修改pyproject.toml。如果想临时安装某个包而不想记录到配置文件中，就可以用uv pip install。<br /><em>适用场景</em>：临时测试、调试依赖项</td></tr><tr><td style="text-align:left">uv pip sync</td><td style="text-align:left">通过<code>requirements.txt</code> 文件同步环境</td></tr></tbody></table></div><p><strong>高频参数解析</strong>：</p><ul><li>—no-deps: 跳过依赖安装（仅安装主包）</li><li>—index-url: 指定私有PyPI源地址</li><li>—timeout: 设置超时时间（默认120秒）</li><li>—pre: 允许安装预发布版本</li></ul><h5 id="2-虚拟环境管理"><a href="#2-虚拟环境管理" class="headerlink" title="2. 虚拟环境管理"></a>2. 虚拟环境管理</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 创建并激活虚拟环境（兼容venv语法）</span></span><span class="line"><span style="color: #abb2bf">uv venv .venv             # 创建环境目录</span></span><span class="line"><span style="color: #abb2bf">source .venv/bin/activate # 激活环境（Linux/macOS）</span></span><span class="line"><span style="color: #abb2bf">.venv\Scripts\activate    # 激活环境（Windows）</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 导出环境依赖</span></span><span class="line"><span style="color: #abb2bf">uv pip freeze &gt; requirements.txt  # 生成精确版本列表</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 跨平台环境复制</span></span><span class="line"><span style="color: #abb2bf">uv pip sync requirements.txt --python=3.11  # 强制指定Python版本</span></span></code></pre></div></div></figure><h5 id="3-高级依赖控制"><a href="#3-高级依赖控制" class="headerlink" title="3. 高级依赖控制"></a>3. 高级依赖控制</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 版本锁定与更新</span></span><span class="line"><span style="color: #abb2bf">uv lock                   # 生成uv.lock文件（替代poetry.lock）</span></span><span class="line"><span style="color: #abb2bf">uv update                 # 更新所有依赖到最新兼容版本</span></span><span class="line"><span style="color: #abb2bf">uv update &lt;package&gt;       # 指定包更新</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 依赖树分析（可视化冲突解决）</span></span><span class="line"><span style="color: #abb2bf">uv tree --format=graph   # 生成依赖关系图（需安装graphviz）</span></span><span class="line"><span style="color: #abb2bf">uv dep conflicts         # 快速定位版本冲突</span></span></code></pre></div></div></figure><hr><h3 id="（三）性能调优与最佳实践"><a href="#（三）性能调优与最佳实践" class="headerlink" title="（三）性能调优与最佳实践"></a><strong>（三）性能调优与最佳实践</strong></h3><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="1-新环境直接使用uv"><a href="#1-新环境直接使用uv" class="headerlink" title="1. 新环境直接使用uv"></a>1. 新环境直接使用uv</h5><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">init</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 初始化</span></span><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #98C379">packag</span><span style="color: #ABB2BF">e&gt;  </span><span style="color: #7F848E; font-style: italic"># 开发过程中安装包</span></span><span class="line"><span style="color: #61AFEF">uv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">lock</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 锁定配置</span></span></code></pre></div></div></figure><h5 id="2-已有uv项目配置新环境（为开源项目配置环境等）"><a href="#2-已有uv项目配置新环境（为开源项目配置环境等）" class="headerlink" title="2. 已有uv项目配置新环境（为开源项目配置环境等）"></a>2. 已有uv项目配置新环境（为开源项目配置环境等）</h5><ul><li>项目中已有uv环境的包配置</li></ul><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">uv sync  # 根据lock文件安装包</span></span></code></pre></div></div></figure><h5 id="3-pip项目迁移到uv"><a href="#3-pip项目迁移到uv" class="headerlink" title="3. pip项目迁移到uv"></a>3. pip项目迁移到uv</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">uv init</span></span><span class="line"><span style="color: #abb2bf">uv add -r requirements.txt</span></span><span class="line"><span style="color: #abb2bf">uv lock  # 锁定配置</span></span></code></pre></div></div></figure><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h5 id="1-缓存优化技巧"><a href="#1-缓存优化技巧" class="headerlink" title="1. 缓存优化技巧"></a>1. 缓存优化技巧</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 查看缓存统计</span></span><span class="line"><span style="color: #abb2bf">uv cache info  </span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 清理过期缓存（30天前）</span></span><span class="line"><span style="color: #abb2bf">uv cache prune --keep-within 30d</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 指定自定义缓存路径</span></span><span class="line"><span style="color: #abb2bf">export UV_CACHE_DIR=/mnt/ssd_cache/uv  </span></span><span class="line"><span style="color: #abb2bf">uv install --cache-dir /mnt/ssd_cache/uv</span></span></code></pre></div></div></figure><h5 id="2-多线程加速"><a href="#2-多线程加速" class="headerlink" title="2. 多线程加速"></a>2. 多线程加速</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 根据CPU核心数自动分配线程（实测8核提升3倍速度）</span></span><span class="line"><span style="color: #abb2bf">uv install --threads $(nproc)  </span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 限制最大线程数（避免资源争抢）</span></span><span class="line"><span style="color: #abb2bf">uv install --threads 4</span></span></code></pre></div></div></figure><h5 id="3-依赖安装策略对比"><a href="#3-依赖安装策略对比" class="headerlink" title="3. 依赖安装策略对比"></a>3. 依赖安装策略对比</h5><div class="table-container"><table><thead><tr><th style="text-align:left">策略</th><th style="text-align:left">命令参数</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">极速模式</td><td style="text-align:left">—strategy=unpack</td><td style="text-align:left">跳过完整性校验（仅限可信源）</td></tr><tr><td style="text-align:left">安全模式</td><td style="text-align:left">—strategy=copy</td><td style="text-align:left">企业内网严格审计环境</td></tr><tr><td style="text-align:left">空间优化</td><td style="text-align:left">—strategy=link</td><td style="text-align:left">硬盘空间有限时使用符号链接</td></tr></tbody></table></div><hr><h3 id="（四）常见问题排查指南"><a href="#（四）常见问题排查指南" class="headerlink" title="（四）常见问题排查指南"></a><strong>（四）常见问题排查指南</strong></h3><h5 id="问题1：依赖版本冲突"><a href="#问题1：依赖版本冲突" class="headerlink" title="问题1：依赖版本冲突"></a>问题1：依赖版本冲突</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 步骤1：生成冲突报告</span></span><span class="line"><span style="color: #abb2bf">uv dep conflicts --markdown &gt; conflicts.md</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 步骤2：手动指定版本</span></span><span class="line"><span style="color: #abb2bf">uv install &quot;pandas==2.2.0&quot; &quot;numpy&lt;1.25&quot;</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 步骤3：强制覆盖安装（慎用）</span></span><span class="line"><span style="color: #abb2bf">uv install --resolution=highest</span></span></code></pre></div></div></figure><h5 id="问题2：私有仓库认证失败"><a href="#问题2：私有仓库认证失败" class="headerlink" title="问题2：私有仓库认证失败"></a>问题2：私有仓库认证失败</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">TOML# 在项目根目录创建 uv.toml</span></span><span class="line"><span style="color: #abb2bf">[auth.private-repo]</span></span><span class="line"><span style="color: #abb2bf">type = &quot;basic&quot;</span></span><span class="line"><span style="color: #abb2bf">username = &quot;$UV_USER&quot;  # 从环境变量读取</span></span><span class="line"><span style="color: #abb2bf">password = &quot;$UV_TOKEN&quot;</span></span></code></pre></div></div></figure><h5 id="问题3：跨平台环境不一致"><a href="#问题3：跨平台环境不一致" class="headerlink" title="问题3：跨平台环境不一致"></a>问题3：跨平台环境不一致</h5><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BASH# 生成平台锁定文件</span></span><span class="line"><span style="color: #abb2bf">uv lock --platform linux-x86_64 --platform macos-arm64</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf"># 安装时指定目标平台</span></span><span class="line"><span style="color: #abb2bf">uv install --target-platform win-amd64</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python包管理工具深度解析：venv、conda、poetry与uv</title>
      <link href="/2024/04/19/python-bao-guan-li-gong-ju-shen-du-jie-xi-venv-conda-poetry-yu-uv/"/>
      <url>/2024/04/19/python-bao-guan-li-gong-ju-shen-du-jie-xi-venv-conda-poetry-yu-uv/</url>
      
        <content type="html"><![CDATA[<p>Python开发者或多或少都会遇到Python包的依赖问题：</p><ul><li>安装一个新的包时，与已有的包冲突；</li><li>安装一个新的包时，这个包的依赖与现有的包冲突；</li><li>开发时需要许多线上环境不需要的包，必须同时维护两套Requirement；</li><li>打镜像时，安装包速度也很慢，有时要十几分钟。</li></ul><p>在Python开发中，包管理工具的选择直接影响项目的可维护性、依赖隔离和协作效率。本文将从核心功能、适用场景、操作实践等角度，全面解析四大主流工具：<strong>venv</strong>、<strong>conda</strong>、<strong>poetry</strong>和<strong>uv</strong>，并对比其优缺点，助你找到最适合项目的解决方案。</p><hr><h3 id="一、venv：轻量级虚拟环境标准工具"><a href="#一、venv：轻量级虚拟环境标准工具" class="headerlink" title="一、venv：轻量级虚拟环境标准工具"></a>一、venv：轻量级虚拟环境标准工具</h3><p><strong>定位</strong>：Python标准库内置的虚拟环境管理器。</p><p><strong>核心功能</strong>：</p><ul><li>创建独立的Python环境，隔离不同项目的依赖。</li><li>通过命令行工具快速初始化环境（python -m venv myenv）。</li><li>与pip配合使用，实现基础包安装。</li></ul><p><strong>优点</strong>：</p><ol><li><strong>零配置</strong>：无需额外安装，Python 3.3+原生支持。</li><li><strong>轻量化</strong>：仅生成环境目录，资源占用极小。</li><li><strong>跨平台兼容</strong>：Windows/Linux/macOS命令统一。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>依赖管理薄弱</strong>：无法自动解决版本冲突，需手动维护requirements.txt。</li><li><strong>功能单一</strong>：仅提供环境隔离，无打包、发布等扩展能力。</li></ol><p><strong>适用场景</strong>：脚本开发、小型项目、快速原型开发。</p><hr><h3 id="二、conda：跨语言的科学计算生态"><a href="#二、conda：跨语言的科学计算生态" class="headerlink" title="二、conda：跨语言的科学计算生态"></a>二、conda：跨语言的科学计算生态</h3><p><strong>定位</strong>：Anaconda发行的包管理与环境管理工具。</p><p><strong>核心功能</strong>：</p><ul><li>管理Python包及<strong>非Python依赖（如C/C++库）</strong>。</li><li>支持多版本Python环境切换（conda create -n myenv python=3.9）。</li><li>提供预编译二进制包，加速科学计算库安装。</li></ul><p><strong>优点</strong>：</p><ol><li><strong>跨语言支持</strong>：完美适配数据科学、机器学习等复杂依赖场景。</li><li><strong>预编译优化</strong>：避免从源码编译NumPy、TensorFlow等重型库。</li><li><strong>环境导出</strong>：通过environment.yml精确复制环境。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>体积臃肿</strong>：Anaconda默认安装包含大量冗余包。</li><li><strong>社区版延迟</strong>：非商业包更新速度较慢。</li></ol><p><strong>适用场景</strong>：数据科学、生物信息学等需复杂依赖链的领域，尤其是需要非python依赖的时候，是最好的选择。</p><hr><h3 id="三、poetry：一体化依赖与项目管理"><a href="#三、poetry：一体化依赖与项目管理" class="headerlink" title="三、poetry：一体化依赖与项目管理"></a>三、poetry：一体化依赖与项目管理</h3><p><strong>定位</strong>：现代Python项目的依赖解析和打包工具。</p><p><strong>核心功能</strong>：</p><ul><li>通过pyproject.toml统一管理依赖、脚本、元数据。</li><li>自动解析依赖树，生成精确的poetry.lock文件。</li><li>内置打包发布功能（poetry publish）。</li></ul><p><strong>优点</strong>：</p><ol><li><strong>依赖确定性</strong>：基于SAT算法解决版本冲突，避免“依赖地狱”。</li><li><strong>项目全周期管理</strong>：从初始化到发布覆盖开发全流程。</li><li><strong>开发者友好</strong>：命令简洁（如poetry add requests==2.28.0）。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>学习曲线</strong>：需适应pyproject.toml配置语法。</li><li><strong>旧项目迁移成本</strong>：对传统setup.py项目支持有限。</li></ol><p><strong>适用场景</strong>：长期维护的应用程序或库开发，尤其是需要严格依赖控制的团队项目。</p><hr><h3 id="四、uv：Rust驱动的超高速工具"><a href="#四、uv：Rust驱动的超高速工具" class="headerlink" title="四、uv：Rust驱动的超高速工具"></a>四、uv：Rust驱动的超高速工具</h3><p><strong>定位</strong>：由Astral团队（Ruff作者）开发的下一代Python工具链，poetry的上位替代。</p><p><strong>核心功能</strong>：</p><ul><li>兼容pip和poetry工作流，替换后端以提升性能。</li><li>基于Rust实现，安装速度比传统工具快10-100倍。</li><li>支持多平台缓存复用，减少重复下载。</li></ul><p><strong>优点</strong>：</p><ol><li><strong>极致性能</strong>：Rust底层优化，尤其适合大型项目。</li><li><strong>渐进式采用</strong>：可替代pip install或poetry install命令。</li><li><strong>统一工具链</strong>：与ruff、astral-sh等工具深度集成。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>生态初期</strong>：插件和第三方支持尚不完善（截至2025年）。</li><li><strong>高级功能限制</strong>：复杂依赖场景仍需配合其他工具。</li></ol><p><strong>适用场景</strong>：追求极速CI/CD流水线，或已采用Ruff等Astral生态的项目。</p><hr><h3 id="五、横向对比与选型建议"><a href="#五、横向对比与选型建议" class="headerlink" title="五、横向对比与选型建议"></a>五、横向对比与选型建议</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>维度</strong></th><th style="text-align:left">venv</th><th style="text-align:left">conda</th><th style="text-align:left">poetry</th><th style="text-align:left">uv</th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心优势</strong></td><td style="text-align:left">轻量、内置</td><td style="text-align:left">跨语言、预编译包，<br />可以管理非python依赖</td><td style="text-align:left">依赖确定性</td><td style="text-align:left">依赖确定性+极速执行</td></tr><tr><td style="text-align:left"><strong>依赖解析</strong></td><td style="text-align:left">无</td><td style="text-align:left">中等</td><td style="text-align:left">强（SAT算法）</td><td style="text-align:left">兼容pip/poetry</td></tr><tr><td style="text-align:left"><strong>虚拟环境</strong></td><td style="text-align:left">独立目录</td><td style="text-align:left">独立目录+版本管理</td><td style="text-align:left">可选集成</td><td style="text-align:left">兼容现有工具</td></tr><tr><td style="text-align:left"><strong>适用规模</strong></td><td style="text-align:left">小型项目</td><td style="text-align:left">科学计算/大型项目</td><td style="text-align:left">中大型应用</td><td style="text-align:left">大型/企业级项目</td></tr><tr><td style="text-align:left"><strong>学习成本</strong></td><td style="text-align:left">低</td><td style="text-align:left">中</td><td style="text-align:left">中高</td><td style="text-align:left">低（兼容现有习惯）</td></tr><tr><td style="text-align:left"><strong>社区成熟度</strong></td><td style="text-align:left">极高</td><td style="text-align:left">高</td><td style="text-align:left">高</td><td style="text-align:left">快速上升期</td></tr></tbody></table></div><p><strong>选型指南</strong>：</p><ul><li><strong>新手入门</strong>：从venv + pip开始，逐步过渡到poetry和uv。</li><li><strong>数据科学</strong>：首选conda，避免编译和依赖冲突。</li><li><strong>企业级应用</strong>：poetry提供严格依赖控制，uv加速CI流程。</li><li><strong>极致性能</strong>：uv，no doubt。</li></ul><hr><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>对于开发者而言，关键在于根据项目需求选择工具，并保持对新技术的开放态度。</p><p>无论选择哪种方案，清晰的依赖管理和可复现的环境构建，始终是高质量Python项目的基石。另外，更高效的依赖安装速度也是锦上添花的一环。</p><p>现在我所有的新项目都迁移到uv，一些老项目也在逐步改造中，可以说是唯一的真神。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uv </tag>
            
            <tag> poetry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BERT与GPT：语言模型的双子星</title>
      <link href="/2022/04/09/bert-yu-gpt-yu-yan-mo-xing-de-shuang-zi-xing-jia-gou-jie-xi/"/>
      <url>/2022/04/09/bert-yu-gpt-yu-yan-mo-xing-de-shuang-zi-xing-jia-gou-jie-xi/</url>
      
        <content type="html"><![CDATA[<p>随着论文《Attention is All You Need》的发表，常用的RNN结构逐渐被抛弃。出现了基于attention的Transformer模型架构。</p><p>在seq2seq模型架构中，存在一个encoder与一个decoder，这二者都是基于RNN结构。而当把原本的RNN结构换成多头attention（还包括位置向量、归一化和残差等模块）就形成了Transformer模型架构。</p><p>而GPT和BERT是Transformer模型架构中最流行的两种语言模型。</p><h2 id="1-BERT模型结构：双向编码"><a href="#1-BERT模型结构：双向编码" class="headerlink" title="1 BERT模型结构：双向编码"></a>1 BERT模型结构：双向编码</h2><h4 id="1-1-核心架构"><a href="#1-1-核心架构" class="headerlink" title="1.1 核心架构"></a>1.1 核心架构</h4><p>bert严格说来属于是Transformer的编码器部分，虽然在预训练过程中需要使用解码器，但是训练完成之后这部分就被丢弃，只保留了编码器部分。所以，我们下载到的开源bert模型的输出为编码器生成的embedding向量。</p><p>模型结构方面比较简单，主要是使用了attention代替RNN，具体可以看之前写的<a href="https://skyfaker.cc/2021/03/10/attention-is-all-you-need/">关于attention的博客</a>。</p><h4 id="1-2-预训练"><a href="#1-2-预训练" class="headerlink" title="1.2 预训练"></a>1.2 预训练</h4><p>Bert模型的思路和ELMO一脉相承，ELMO采用了很典型的两阶段过程，第一阶段，对语言模型进行预训练；第二阶段，是进行下游任务时，将Embedding作为新特征补充到下游模型中。</p><p>Bert模型采用双向自注意力机制。其输入由三部分嵌入向量相加构成：</p><ul><li><strong>Token Embeddings</strong>：对输入token进行向量化（含特殊符号[CLS]和[SEP]）</li><li><strong>Segment Embeddings</strong>：区分句子对（如问答中的问题与答案）</li><li><strong>Position Embeddings</strong>：编码序列中每个token的位置信息</li></ul><p>Bert模型在预训练阶段有2个任务：</p><ol><li><strong>掩码语言模型（MLM）</strong>：随机遮蔽15%的输入词，模型需预测被遮蔽词（其中80%替换为[MASK]，10%随机替换，10%保持不变）。MLM借鉴了CBOW的思路，类似于做完形填空。</li><li><strong>下一句预测（NSP）</strong>：判断两个句子是否为连续文本，增强篇章理解能力。这个任务作用不是很大。</li></ol><h4 id="1-3-BERT-vs-RoBERTa：优化方向的演进"><a href="#1-3-BERT-vs-RoBERTa：优化方向的演进" class="headerlink" title="1.3 BERT vs RoBERTa：优化方向的演进"></a>1.3 BERT vs RoBERTa：优化方向的演进</h4><p>RoBERTa（Robustly Optimized BERT）通过四项关键改进提升BERT性能：</p><ol><li><strong>动态掩码</strong>：训练时对同一数据多次随机遮蔽，替代静态掩码，增强模型鲁棒性。</li><li><strong>移除NSP任务</strong>：实验证明NSP对下游任务无显著增益，改为连续文本输入。</li><li><strong>更大批次与数据量</strong>：批次从256增至8,000，训练数据从16GB扩至160GB。</li><li><strong>更长的训练周期</strong>：从BERT的1M步增至300K-500K步，充分挖掘模型潜力。</li></ol><p><strong>性能提升</strong>：RoBERTa在GLUE基准测试中平均提升2-3个百分点，尤其在长文本理解任务中表现突出。</p><h4 id="1-4-BERT的评价"><a href="#1-4-BERT的评价" class="headerlink" title="1.4 BERT的评价"></a>1.4 BERT的评价</h4><p>Bert的效果很强，一出现就霸榜，但是它的优越性不在于多么新奇的网络结构，或者是新的训练方式（MLM），而是它证明了Transformer的上限要远超RNN和LSTM。</p><p>另外，通过Bert与RoBERTa的对比，我们可以发现，Bert也还没有充分发掘出Transformer的能力上限，只要有更多更优质的数据，更深的模型层数，就可以得到更强大的模型。</p><h2 id="2-GPT模型结构：自回归生成"><a href="#2-GPT模型结构：自回归生成" class="headerlink" title="2 GPT模型结构：自回归生成"></a>2 GPT模型结构：自回归生成</h2><h4 id="2-1-核心架构"><a href="#2-1-核心架构" class="headerlink" title="2.1 核心架构"></a>2.1 核心架构</h4><p>GPT系列（如GPT-3）基于Transformer的<strong>解码器堆叠</strong>，采用<strong>掩码自注意力机制</strong>（仅允许关注左侧上下文）。其训练特点包括：</p><ul><li><p><strong>自回归语言建模</strong>：逐词生成，通过上文预测下一个词（如“我爱__”预测“你”）。类似于写作文任务。</p></li><li><p><strong>无监督预训练 + 零样本学习</strong>：无需微调即可完成对话、翻译等生成任务。</p></li></ul><h2 id="3-BERT-vs-GPT：架构与能力的本质差异"><a href="#3-BERT-vs-GPT：架构与能力的本质差异" class="headerlink" title="3 BERT vs GPT：架构与能力的本质差异"></a>3 BERT vs GPT：架构与能力的本质差异</h2><h4 id="3-1-GPT和Bert强弱对比"><a href="#3-1-GPT和Bert强弱对比" class="headerlink" title="3.1 GPT和Bert强弱对比"></a>3.1 GPT和Bert强弱对比</h4><p>GPT只采用Context-before，即这个单词的上文来进行预测，所以普遍认为其在上下文的理解上较弱于Bert。</p><p>个人认为根本上是二者在训练阶段的不同训练方式导致的。</p><p>Bert的编码器结构将token编码成embedding向量，然后由下游模型去微调完成下游任务，并且一般的下游任务为分类任务。由于额外的网络结构，加上特地为分类任务去微调，天然导致Bert模型在这方面更强。</p><p>而GPT训练过程更偏向于文本生成，因此在文本生成方面也要强于Bert模型。</p><h4 id="3-2-GPT和Bert的缺陷和发展方向"><a href="#3-2-GPT和Bert的缺陷和发展方向" class="headerlink" title="3.2 GPT和Bert的缺陷和发展方向"></a>3.2 GPT和Bert的缺陷和发展方向</h4><p>Bert模型的一大特点就是两阶段训练，一阶段训练出encoder，二阶段结合下游模型微调（也可以freeze一阶段的encoder）。</p><p>这个特点带来了更强的适配性，另一方面也存在一些问题：</p><ol><li>训练和推理存在gap，训练时token中存在了推理阶段没有的token：[MASK]。因此在训练阶段[MASK]比例不能太高，就像是完形填空不能一篇文章全是空，那就没法填了。</li><li>论文采用的遮蔽方式太不优雅，随机遮蔽15%的比例，也造成了训练效率低下，即每次只有15%的token被训练，而计算量是100%。</li><li>另外，为了实现自监督学习，Bert需要有解码器，并且解码器不能太简单。而在训练完成之后的大部分场景，解码器是无用的，也是白白浪费算力。</li></ol><p>GPT模型的一大特点是自回归生成，训练与推理一致，完全属于是端到端的模型架构。那他的缺点就是不方便外接下游任务，不像Bert生成的向量可以给各种各样的下游模型使用。</p><p>不过理论上，生成的方式可以解决目前所有的NLP任务，而且GPT使用prompt来适配不同任务的方式更加自然，更加符合人类的使用习惯。现在的问题是生成式任务自由度太高了，GPT基础模型还不够强，实现不了仅通过prompt的方式适配所有任务。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pretraining model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多进程中的坑</title>
      <link href="/2022/02/15/python-duo-jin-cheng-zhong-de-keng/"/>
      <url>/2022/02/15/python-duo-jin-cheng-zhong-de-keng/</url>
      
        <content type="html"><![CDATA[<p>最近在线上的测试环境遇到一个偶发的问题，问题表现为docker容器卡死，不执行程序并且也不再消费消息队列中的任务。</p><p>线上环境使用docker集群，消息的传递使用消息队列实现。出问题的是一个下游服务，这个服务基本流程是，载入数据，处理之后进行模型训练和预测。奇怪的是，卡死的位置不固定，有时候出现在模型训练过程中，有时候出现在data_loader中，并且不是稳定触发，但是一旦触发，整个容器卡死，只有进行容器重启才能恢复。</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>首先把代码拉到开发集群，测试之后没有问题，所有测试用例都通过，没有卡死。没办法，只能在线上测试集群debug。</p><p>查看代码，发现使用了多进程。原来该服务为了防止出现内存泄漏，每当消费一个消息，就会生成一个子进程完成数据处理和模型训练的功能。而当复现bug之后，查看进程，发现只存在一个python进程。估计是多进程中的子进程挂掉了，没有被父进程正常回收，导致的容器卡死。</p><p>其中多进程使用<code>multiprocessing.Pool</code>实现，代码逻辑类似于：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> multiprocessing</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> os</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">subprocesses</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">argv</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;sub-process id: &#39;</span><span style="color: #ABB2BF">os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 子进程处理中</span></span><span class="line"><span style="color: #ABB2BF">    re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">&quot;result&quot;</span><span style="color: #ABB2BF">: argv}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    pool </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> multiprocessing.</span><span style="color: #61AFEF">Pool</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">processes</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    results </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">    msg </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;test&quot;</span></span><span class="line"><span style="color: #ABB2BF">    sub_res </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> pool.</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(subprocesses, (msg,))</span></span><span class="line"><span style="color: #ABB2BF">    results.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(sub_res)</span></span><span class="line"><span style="color: #ABB2BF">    pool.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 关闭进程池，表示不能再往进程池中添加进程，需要在join之前调用</span></span></code></pre></div></div></figure><p>读者可以使用上述代码进行测试，<strong>当子进程执行时，使用kill命令（windows使用taskkill命令）杀死子进程</strong>，会发现主程序卡死，永远不会执行完成。</p><p>所以问题出现在子进程执行过程中，子进程意外挂掉。</p><p>进一步查看日志发现，集群测试时，使用了很大的数据规模，并且给batch_size设置了很大的值，导致在处理数据或者模型训练时，内存远远超过集群对单个服务的限制，从而导致子进程被系统kill。</p><h3 id="进一步测试"><a href="#进一步测试" class="headerlink" title="进一步测试"></a>进一步测试</h3><p>按照逻辑，子进程意外终止，那么父进程应该接收到信号。然而实际上，即使将子进程写入try/except中，也捕获不了，因为</p><blockquote><p>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</p></blockquote><p>所以即使子进程中增加异常捕获也是不起作用的，例如下面的写法：<br><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">subprocesses</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">argv</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">try</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">except</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Error&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">&quot;result&quot;</span><span style="color: #ABB2BF">: argv}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span></code></pre></div></div></figure></p><p>或者将map方法换成<code>apply 、 apply_async、 map_async</code>方法都是一样的结果，因为<code>apply_async、map_async</code>中的<em>error_callback</em>函数同样无法捕获kill信号。</p><p>例如：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> multiprocessing</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> os</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">subprocesses</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">argv</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">&quot;result&quot;</span><span style="color: #ABB2BF">: argv}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">collect_result</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">result</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;Error&quot;</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    pool </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> multiprocessing.</span><span style="color: #61AFEF">Pool</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">processes</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    results </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">    msg </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;hello&quot;</span></span><span class="line"><span style="color: #ABB2BF">    sub_res </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> pool.</span><span style="color: #61AFEF">map_async</span><span style="color: #ABB2BF">(subprocesses, (msg,), </span><span style="color: #E06C75; font-style: italic">error_callback</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">collect_result)</span></span><span class="line"><span style="color: #ABB2BF">    results.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(sub_res)</span></span><span class="line"><span style="color: #ABB2BF">    pool.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    pool.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 异步多线程需要加这一行，否则主进程会直接结束</span></span></code></pre></div></div></figure><p>上述代码使用<code>map_async</code>，但是子进程被kill的时候仍然触发不了<em>error_callback回调函数</em>。</p><h3 id="Pool源码"><a href="#Pool源码" class="headerlink" title="Pool源码"></a>Pool源码</h3><p>既然<code>Pool</code>类的几种多进程方法都没有办法解决这个问题，这说明是<code>Pool</code>这个类的实现不支持子进程意外挂掉之后通知主进程，说以先来看看这个<code>Pool</code>的源码是怎么实现的。</p><p>以下述代码为例，实例化进程池，并指定子进程数量为1：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">pool = multiprocessing.Pool(processes=1)</span></span><span class="line"><span style="color: #abb2bf">sub_res = pool.apply_async(subprocesses, error_callback=collect_result)  #以apply_async为例，apply,map,map_async结构类似</span></span></code></pre></div></div></figure><p>第一行为<code>Pool的实例化</code>，在第一行代码执行之后，会生成三个队列<code>_taskqueue, _inqueue, _outqueue</code>，并生成一个<code>_cache</code>字典，之后生成指定数量的子进程加入到进程池中，最后生成三个线程<code>_worker_handler, _task_handler, _result_handler</code>。</p><p>以下为<strong>精简后</strong>的<code>Pool</code>类的<code>init</code>函数</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._pool </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">_setup_queues</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 在这里构造_inqueue, _outqueue队列</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._taskqueue </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> queue.</span><span style="color: #61AFEF">SimpleQueue</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># _taskqueue队列</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._cache </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">_PoolCache</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">notifier</span><span style="color: #56B6C2">=</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._change_notifier)  </span><span style="color: #7F848E; font-style: italic"># 构造_cache</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">try</span><span style="color: #ABB2BF">:  </span><span style="color: #7F848E; font-style: italic"># 为进程池构造子进程</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">_repopulate_pool</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #C678DD">except</span><span style="color: #ABB2BF"> Exception:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> p </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._pool:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> p.exitcode </span><span style="color: #C678DD">is</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            p.</span><span style="color: #61AFEF">terminate</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> p </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._pool:</span></span><span class="line"><span style="color: #ABB2BF">        p.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">raise</span></span><span class="line"></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._worker_handler </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">Thread</span><span style="color: #ABB2BF">(  </span><span style="color: #7F848E; font-style: italic"># _worker_handler线程</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">target</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">Pool._handle_workers,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">args</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._cache, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._taskqueue, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._ctx, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.Process,</span></span><span class="line"><span style="color: #ABB2BF">          </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._processes, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._pool, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._inqueue, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._outqueue,</span></span><span class="line"><span style="color: #ABB2BF">          </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._initializer, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._initargs, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._maxtasksperchild,</span></span><span class="line"><span style="color: #ABB2BF">          </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._wrap_exception, sentinels, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._change_notifier)</span></span><span class="line"><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._worker_handler.daemon </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._worker_handler._state </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">RUN</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._worker_handler.</span><span style="color: #61AFEF">start</span><span style="color: #ABB2BF">()</span></span><span class="line"></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._task_handler </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">Thread</span><span style="color: #ABB2BF">(  </span><span style="color: #7F848E; font-style: italic"># _task_handler线程</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">target</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">Pool._handle_tasks,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">args</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._taskqueue, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._quick_put, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._outqueue,</span></span><span class="line"><span style="color: #ABB2BF">          </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._pool, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._cache)</span></span><span class="line"><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._task_handler.daemon </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._task_handler._state </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">RUN</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._task_handler.</span><span style="color: #61AFEF">start</span><span style="color: #ABB2BF">()</span></span><span class="line"></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._result_handler </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">Thread</span><span style="color: #ABB2BF">(  </span><span style="color: #7F848E; font-style: italic"># _result_handler线程</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">target</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">Pool._handle_results,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">args</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._outqueue, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._quick_get, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._cache)</span></span><span class="line"><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._result_handler.daemon </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._result_handler._state </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">RUN</span></span><span class="line"><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._result_handler.</span><span style="color: #61AFEF">start</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure><p>在第二行代码中，<code>apply_async</code>会将要执行的函数和函数参数打包放入<code>_taskqueue</code>，子进程获取任务执行。</p><p><code>apply_async</code>函数代码：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">apply_async</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">func</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">args</span><span style="color: #ABB2BF">=(), </span><span style="color: #D19A66; font-style: italic">kwds</span><span style="color: #ABB2BF">={}, </span><span style="color: #D19A66; font-style: italic">callback</span><span style="color: #ABB2BF">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #D19A66; font-style: italic">error_callback</span><span style="color: #ABB2BF">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">_check_running</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ApplyResult</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">, callback, error_callback)  </span><span style="color: #7F848E; font-style: italic"># 打包用户传入的任务函数，同时在_cache中添加对应记录</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">._taskqueue.</span><span style="color: #61AFEF">put</span><span style="color: #ABB2BF">(([(result._job, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, func, args, kwds)], </span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">))  </span><span style="color: #7F848E; font-style: italic"># 任务函数等信息送入_taskqueue队列</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> result</span></span></code></pre></div></div></figure><p>其中</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">_taskqueue: 存放用户指定子进程去执行的函数以及函数参数信息；</span></span><span class="line"><span style="color: #abb2bf">_inqueue: 该队列与子进程交互，从_taskqueue取出的task，放到_inqueue，由子进程从队列中取出任务执行；</span></span><span class="line"><span style="color: #abb2bf">_outqueue: 该队列与子进程交互，保存子进程的结果；</span></span><span class="line"><span style="color: #abb2bf">_cache: 缓存字典，以job_id为key。</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">_worker_handler: 维护进程数量的子线程，例如指定进程池大小为4，任务数为10，一个子进程完成任务之后销毁，进程池中进程为3，此时由这个线程生成新的进程加入到进程池；</span></span><span class="line"><span style="color: #abb2bf">_task_handler: 从_taskqueue队列取任务到_inqueue队列的子线程；</span></span><span class="line"><span style="color: #abb2bf">_result_handler: 从_outqueue取出结果的子线程，并将_cache中对应的记录删除。</span></span></code></pre></div></div></figure><p>分析完类里面的主要变量，下面分析一下过程：</p><blockquote><ol><li>实例化Pool类时，生成上述主要变量，生成进程池；</li><li>在apply_async函数中，将用户传入的函数和函数变量打包为ApplyResult类，放入_taskqueue，并在_cache字典中添加这条任务的记录；</li><li>_task_handler线程遍历_taskqueue队列，将任务放入_inqueue队列；</li><li>子进程执行任务，将结果放入_outqueue队列；</li><li>_result_handler从_outqueue队列中取出子进程的运算结果，并删除_cache中对应的记录。</li><li>_result_handler检查_cache，当_cache才会停止_result_handler线程</li></ol><p>另外，Pool类的一些重要方法如下：</p><p>pool.join()是用来等待进程池中的worker进程执行完毕，防止主进程在worker进程结束前结束。但pool.join()必须使用在pool.close()或者pool.terminate()之后。</p><p>close()跟terminate()的区别在于close()会等待池中的worker进程执行结束再关闭pool,而terminate()则是直接关闭。</p></blockquote><p>因此，很显然，之前的问题是卡在了第5步：一旦某个子进程卡死，那么这个子进程将不会产生结果，则_result_handler就不会删除这个任务对应的_cache记录，_cache不空则_result_handler不会结束，这样整个进程池都不会结束。</p><p>看到这里，可以明白，<strong>使用进程池必须要能够获取到子进程的结果，而子进程被kill的时候不会产生结果，也不会通知进程池，因此这个问题对于使用进程池来实现多进程是无解的。</strong></p><p>因此，当子进程任务比较复杂，存在被操作系统自动kill的可能，那么最好不要使用<code>Pool</code>。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>上面的问题归根到底是通过Pool的方式实现多进程时，主进程不知道子进程是否已经挂掉，因此如果非要使用进程池来解决这个问题，可以从这里下手，例如下面这个不大优雅的实现：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> multiprocessing</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> os</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">subprocesses</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">argv</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;sub-process id: &#39;</span><span style="color: #ABB2BF">os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 子进程处理中</span></span><span class="line"><span style="color: #ABB2BF">    re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">&quot;result&quot;</span><span style="color: #ABB2BF">: argv}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    pool </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> multiprocessing.</span><span style="color: #61AFEF">Pool</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">processes</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    results </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">    msg </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;test&quot;</span></span><span class="line"><span style="color: #ABB2BF">    sub_res </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> pool.</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(subprocesses, (msg,))</span></span><span class="line"><span style="color: #ABB2BF">    results.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(sub_res)</span></span><span class="line"><span style="color: #ABB2BF">    pool.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 关闭进程池，表示不能再往进程池中添加进程，需要在join之前调用</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">:  </span><span style="color: #7F848E; font-style: italic"># 主进程轮询子进程状态，代替pool.join()</span></span><span class="line"><span style="color: #ABB2BF">        finish_flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># Pool is finish(True) or not</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> sub_p </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> pool._pool:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> sub_p.</span><span style="color: #61AFEF">is_alive</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">                finish_flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> finish_flag:</span></span><span class="line"><span style="color: #ABB2BF">            error_flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># error(True) or not</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> sub_p </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> pool._pool:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> sub_p.exitcode </span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Sub-processes exit error&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                    pool.</span><span style="color: #61AFEF">terminate</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">                    flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">break</span></span></code></pre></div></div></figure><blockquote><p>The exit code or exit status is a number returned by a process created by a command line indicating if there was an error or not.</p><ul><li>0 means that there is no error</li><li>an other value means that there was an error.</li></ul></blockquote><p>上面的代码用主进程轮询子进程状态，代替<code>pool.join()</code>，先通过进程的<code>is_alive()</code>方法判断进程是否存活，当进程池中所有进程都已经退出，则通过进程的<code>exitcode</code>变量判断是否是正常退出，若存在异常退出的子进程，则手动terminate进程池，确保不会卡死。</p><h4 id="Process解决"><a href="#Process解决" class="headerlink" title="Process解决"></a>Process解决</h4><p>直接不用Pool实现多进程，使用<code>multiprocessing.Process</code>实现，子进程被kill的时候会自动结束：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> multiprocessing</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> os</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">subprocesses</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">argv</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;sub-process id: &#39;</span><span style="color: #ABB2BF">os.</span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 子进程处理中</span></span><span class="line"><span style="color: #ABB2BF">    re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">&quot;result&quot;</span><span style="color: #ABB2BF">: argv}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:    process_list </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> multiprocessing.</span><span style="color: #61AFEF">Process</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">target</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">subprocesses, </span><span style="color: #E06C75; font-style: italic">args</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;test_process&#39;</span><span style="color: #ABB2BF">,))</span></span><span class="line"><span style="color: #ABB2BF">        p.</span><span style="color: #61AFEF">start</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        process_list.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(p)</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> p </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> process_list:</span></span><span class="line"><span style="color: #ABB2BF">        p.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Don&#39;t stop pretraining</title>
      <link href="/2021/12/11/don-t-stop-pretraining/"/>
      <url>/2021/12/11/don-t-stop-pretraining/</url>
      
        <content type="html"><![CDATA[<p>如今很多NLP任务都会在Bert等预训练模型的基础上进行fine-tuning，可能很多人没有意识到在任务领域上进行新的预训练会进一步提高模型效果，下面这篇论文<a href="https://arxiv.org/abs/2004.10964">《<strong>Don’t Stop Pretraining: Adapt Language Models to Domains and Tasks</strong>》</a>就从多个实践角度证明了这种方法的可行性。</p><p>太长不看之结论总结版：</p><blockquote><ol><li><p>在任务相关的领域数据集上继续预训练（DAPT）可以提高模型效果。</p></li><li><p>在具体下游任务数据集上继续预训练（TAPT）也是有效果的。</p></li><li>在更多的、任务相关的无标注数据继续预训练（Curated-TAPT），效果也会提升。</li><li>没有任务相关的无标注数据，可以采取一种一些简单的数据选择策略生成数据集继续预训练，模型效果也会提升。</li></ol></blockquote><p><strong>并且当任务目标领域与预训练模型的原始训练语料越不相关，DAPT和TAPT对模型效果提升越明显。但是使用与任务目标领域无关的数据进一步预训练模型时，会损坏模型效果。</strong></p><h2 id="Never-stop-pretraining"><a href="#Never-stop-pretraining" class="headerlink" title="Never stop pretraining"></a>Never stop pretraining</h2><p>一些工作已经证明了预训练模型在下游任务相关的数据集上进一步预训练可以提高模型效果，但是不够全面也不够系统，而今天的这篇文章从多个领域和多个下游任务上用实践证明了继续预训练的可行性。</p><p>并且论文给出了一些标准，揭示了在什么样的数据上预训练会有更明显的提升。</p><h3 id="领域自适应预训练（DAPT）"><a href="#领域自适应预训练（DAPT）" class="headerlink" title="领域自适应预训练（DAPT）"></a>领域自适应预训练（DAPT）</h3><p>论文选取了4个领域语料库，分别为生物医学（BioMed）领域、计算机科学（CS）领域、新闻（NEWs）领域、评论（Reviews）领域。使用的预训练模型为RoBERTa。</p><p><img src="./data.png" style="zoom:60%;" /></p><p>上图为领域语料库（PT代表RoBERTa的预训练语料）的相关性，相关性计算方式为各领域出现最频繁的10K个单词的重合程度。</p><p>可以看出RoBERTa模型训练预料库比较接近News领域，与CS领域相关性最低。</p><p><img src="./DAPT.png" style="zoom:60%;" /></p><p>上图第5,6列表示经过DAPT前后，模型在不同数据集上的mask LM损失，损失越小表示模型对于数据集的拟合能力越强。其中最后一行表示从RoBERTa模型预训练语料相似的预料中采样出来。</p><p>第5列表示DAPT前的mask LM损失，可以看出NEWS领域的mask LM损失比较接近RoBERTa模型训练预料库，这表明2者数据集看比较相似，这和第一张图表现一致。奇怪的是从第一张图看出Reviews数据集和PT是第二相似，但是RoBERTa模型在这一数据集上的mask LM损失却是最大的，比较反直觉。</p><p>在经过DAPT之后，除了NEWS领域，其他三个领域的mask LM损失都有比较明显的下降，即说明<strong>与RoBERTa的训练数据集越不相似，领域自适应预训练的受益程度越高</strong>。</p><p><img src="./DAPT2.png" style="zoom:60%;" /></p><p>上图表示4个领域的8个任务，经过DAPT之后模型效果，第2列表示任务类型，其中前面带标志的表示该任务数据集较大。第4列表示使用领域数据进行DAPT，第五列表示使用不相关领域数据进行DAPT，用以证明DAPT之后模型效果提升是因为使用任务相关领域数据预训练，而不仅仅是因为使用额外数据预训练。</p><p>从上图可以看出，几乎所有的任务经过DAPT之后模型效果都会有提升，尤其是数据量较小的情况下，提升更为明显。而是用<strong>非相关领域数据进行DAPT基本不会有提升，甚至于反而会削弱模型效果</strong>。</p><h3 id="任务自适应预训练（TAPT）"><a href="#任务自适应预训练（TAPT）" class="headerlink" title="任务自适应预训练（TAPT）"></a>任务自适应预训练（TAPT）</h3><p>领域自适应预训练意思是直接使用任务相关的无标注语料继续进行预训练，然后再对特定任务进行finetune。任务数据集可以看作相关领域中的一个子集，相比于领域数据，它的数量更小，但是与任务更加相关，因此在这样的数据上进一步预训练的成本更小。</p><p><img src="./TAPT.png" style="zoom:50%;" /></p><p>上图为不同领域不同任务在DAPT和TAPT之后的模型效果，注意这里的DAPT+TAPT指的是在DAPT之后再进行TAPT，而不是数据集拼在一起一次性预训练。</p><p>基本上，DAPT+TAPT的预训练效果最佳。</p><p>上述对比表明，任务自适应预训练（TAPT）是一种低成本但有效的提升方法。但TAPT直接将标注数据当作无标注数据进行预训练，毕竟数据量还是较小的。如果可以进一步利用任务相关的非标注数据集，则可以进一步提升TAPT的效果，论文中称之为<strong>Curated-TAPT</strong>，即对人工构造的、可用的、任务相关的未标注数据进行任务自适应预训练。</p><p>举个例子，有一批200份的合同，想要训练模型抽取合同中关键信息，对这200份合同进行标注，获得了10K的标注好的序列作为训练和测试集。如果我们只使用这标注好的10K条数据进行预训练，那么就是TAPT。此时如果我们继续搜集合同到1000份，不进行标注，而是把所有合同都进行预训练，则称为Curated-TAPT。</p><p><img src="./TAPT2.png" style="zoom:60%;" /></p><p>上图比较了TAPT和Curated-TAPT的效果差异，可以看出DAPT+Curated-TAPT的效果最佳。并且这样的生成预训练数据集的成本非常低，通常是不需要额外标注。因此在实际的任务中，我们最好是尽可能搜集数据，即使没有资源标注，也可以作为进一步预训练的数据。</p><p>论文还给出了一个自动数据选择方法，不过看起来效果不不太好，这里就不介绍了，感兴趣可以看论文原文。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>在实际任务中，尤其是中文任务，有一些实践上的小trick：</p><p><strong>怎么样进一步预训练模型？</strong></p><p>以Bert模型为例，Bert模型分为2个过程<strong>Masked LM任务</strong>即预测被mask掉的字符和<strong>NSP任务</strong>，即预测下一个句子。</p><p>在进一步预训练时，只需要训练Masked LM任务即可。对于中文数据，在进行mask的时候可以直接mask一个完整词语而不是单个字。</p><p>具体预训练方法在Transformer中已经有现成的，可以直接使用，<a href="https://github.com/huggingface/transformers/tree/main/examples/pytorch/language-modeling">详情参考这个Github仓库</a>。</p><p>Transformer如果没法满足个性化预训练需求的，可以参考<a href="https://zhuanlan.zhihu.com/p/337212893">这一篇知乎文章</a>。</p><p><strong>需要多少数据进行进一步预训练才会有提升？</strong></p><p>鉴于论文中提的Curated-TAPT方法，我们应该尽可能搜集任务相关无标注数据作为预训练预料。</p><p>考虑到Bert的Masked LM任务中只有15%的字符或者词汇被mask，所以用于预训练的语料要尽可能大一些，个人实践至少要有1W条以上的序列用于预训练，换算成Token的话在15W左右。</p><p>相比于Bert模型10亿级Token作为训练集，10万的Token做进一步预训练就可以继续提升模型效果，成本确实是非常低了。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pretraining model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NER技术的探索与实践</title>
      <link href="/2021/11/01/ner-ji-zhu-de-tan-suo-yu-shi-jian/"/>
      <url>/2021/11/01/ner-ji-zhu-de-tan-suo-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="NER概述"><a href="#NER概述" class="headerlink" title="NER概述"></a>NER概述</h2><p>命名实体识别（Named Entity Recognition，简称NER），是指识别文本中具有特定意义的<strong>实体</strong>，主要包括人名、地名、机构名、专有名词等，一般的也可以识别特定类型的、人为规定的实体。NER是信息提取、问答系统、句法分析、机器翻译等领域的重要基础工具，在自然语言处理走向落地应用过程中占有重要的地位。</p><p><img src="bingli.jpg" style="zoom:33%;" /></p><p>例如，我们可以使用命名实体识别技术抽取出病历单上的病人姓名、年龄、性别、患病部位、问诊时间、科室、诊断结果、检查结果等等。提取这些信息之后，我们可以将这些关键信息存储至结构化数据库，或者利用这些信息构建病人的病历肖像，也可以用这些信息生成只是图谱等。</p><p>又例如，有很多合同比如基金合同，我们需要提取合同中的关键信息显示在公告网站上，如基金管理人，基金名称，基金申购赎回时间，基金申购和赎回费率等。这时可以利用命名实体识别直接提取出这些信息。</p><p>从上面的例子来看，命名实体识别技术可以提取出关键信息，这是数据电子化之后的重要一步，也可以作为后续自然语言处理技术的基础。</p><h3 id="NER数据与评估"><a href="#NER数据与评估" class="headerlink" title="NER数据与评估"></a>NER数据与评估</h3><h4 id="数据与标注"><a href="#数据与标注" class="headerlink" title="数据与标注"></a>数据与标注</h4><p>NER任务的基本方法当成一个序列标注（序列分类）任务，简单来说就是把一个句子序列中的每一个字都预测出一个标签，然后从这些标签中提取出实体。</p><p>举个例子：</p><blockquote><p>上海是一座美丽的城市</p><p>B_LOC I_LOC O O O O O O O O</p></blockquote><p>每个字都预测出一个类别，然后把字的类别组合成实体。比如“上”的标签为“B_LOC”，“海”的标签为“I_LOC”，“上海”两个字的标签组合为“LOC”，即location位置。</p><p>一般来说，不同的NER任务会有不同的类别，但都基本基于以下两种：</p><ul><li>BIO：B-begin，I-inside，O-outside</li><li>BIESO：B-begin，I-inside，O-outside，E-end，S-single 或者BMESO，M类似于I</li></ul><p>这里主要介绍BIO标注方法。BIO标注方法，就是给句子中的每一个字都标注一个标签，这个标签由两部分组成：一部分是该单词所属实体的位置，其中B表示该单词是实体的第一个单词，I表示该单词是实体的中间单词，O表示不是实体；另一部分是该单词对应的实体类型。因此，最终每个单词都被标注为BIO+实体类型的形式，这就变成了一个文本序列分类任务。</p><p>绝大部分的公开数据集也是按照这个方法标注的，<a href="https://github.com/SimmerChan/corpus">常见的数据集参考这个</a>。</p><p>还存在一种标注方式：</p><blockquote><p>{</p><p>“Text”: “上海是一个美丽的城市。”,</p><p>“entity”: [(1,2, “LOC”)]</p><p>}</p></blockquote><p>即用一个字典表示实体的位置和类别，很多阅读理解和关系抽取使用这种方式标注。</p><h4 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h4><p>命名实体识别模型的评估方式分为两种，一是通用的基于token标签进行直接评估，即评估每一个字的标签。二是将字的结果生成实体的标签之后再评估。后者的评测方法比较严格，也会考虑到字标签生成实体标签的方法的效果。</p><p>举个例子：</p><blockquote><p>原始序列：上海是一座美丽的城市</p><p>原始标签：B_LOC I_LOC O O O O O O O O</p><p>预测结果：B_LOC I_LOC I_LOC O O O O O O O</p></blockquote><p>按照第一个评估方法，实体（非“O”）标签的召回率=1，精确率=2/3。</p><p>而按照第二个方法，需要先将字预测标签生成实体标签，这里以“B_LOC”作为实体开始，最后一个遇到“O”的“I_LOC”作为实体结束，则原始标签实体为“上海”，预测实体为“上海是”，那么实体的召回率为0，精确率也为0。</p><p>很显然的，第二种方法很严格，只有最终生成的实体结果完全正确才能算作抽取出正样本，而不是仅仅字级别标签分类正确就可以了。</p><p>这时，细心的读者会考虑到，将字预测标签变成实体标签这一步属于人为生成的算法，而不是模型的一部分，并且这一部分也会较大的影响最终结果。</p><p>例如：</p><blockquote><p>原始序列：上海是一座美丽的城市</p><p>原始标签：B_LOC I_LOC O O O O O O O O</p><p>预测结果：I_LOC I_LOC O O O O O O O O</p></blockquote><p>在从单个字符的预测结果转换成实体结果的时候，如果我们认为孤立的，没有B作为开头的”I_LOC”都是错误的预测，那么预测出的“I_LOC I_LOC”不会生成实体。如果我们认为句子开头的“I_LOC”可以人为修改成“B_LOC”，那么就可以生成出实体，从而正确预测。</p><p>一般来说，我们会把从单个字符预测结果转换成为实体的过程叫做后处理，正确的后处理有时可以很大程度上提高整体的预测效果。</p><h3 id="NER算法"><a href="#NER算法" class="headerlink" title="NER算法"></a>NER算法</h3><p>大部分的NER算法是将NER任务当作一个序列标注任务来处理，预测出每一个字符的标签。</p><h4 id="lstm-CRF"><a href="#lstm-CRF" class="headerlink" title="lstm+CRF"></a>lstm+CRF</h4><p><a href="https://arxiv.org/abs/1508.01991">《Bidirectional LSTM-CRF Models for Sequence Tagging》</a>是百度2015年发表的论文，论文将LSTM和CRF这两种方法结合，实现序列标注任务。</p><p><img src="./lstm-crf.png" style="zoom:100%;" alt='LSTM-CRF模型结构图'/></p><ol><li>输入为字符的销量表示，先经过LSTM层，这里可以将字符的向量表示进行融合，LSTM层输出的结果为类别的预测结果，也称为发射概率P（黄色框部分）。</li></ol><p>LSTM layer的输出维度是类别大小，设Bi-LSTM的输出矩阵为P，其中$P(i, j)$代表字符$w_i$映射到$tag_j$的非归一化概率。</p><p>例如上图的 $w_0, w_1, w_2, w_3, w_4$ 经过LSTM的预测结果分别为 $B-Person, I-Person, O, B-Organization, O$。</p><script type="math/tex; mode=display">P(0, 0)表示字符w_0属于类别0(B-Person)的概率</script><ol><li>将发射概率送入CRF，CRF中存在一个转移矩阵A，表示每一类标签转移到下一类标签的概率, 即$A(i,j)$表示$tag_i$到$tag_i$的转移概率。例如上图中，存在 $B-Person, I-Person, B-Organization,I-Organization, O$ 共5个类别，则加上开头和结尾，转移矩阵大小为$7*7$。</li></ol><script type="math/tex; mode=display">A(0,1)表示从0类别（通常为start）转移到1类别的概率</script><p>对于整个序列$X$的输出$y$, 整个序列的分数</p><script type="math/tex; mode=display">s(X, y) = \sum_{i=0}^n A(y_i,y_{i+1}) + \sum_{i=1}^n P(i,y_{i})</script><p>实际上，在第一步的时候已经获取到每一个字符的预测结果了，但是CRF保证了序列中字符预测结果的可靠性。</p><p>例如，</p><blockquote><p>真实标签：B I O B I</p><p>LSTM的预测结果：B I O I I</p></blockquote><p>这种预测结果是不符合实际情况的，因为标签 <strong>I</strong> 的前面一个标签不可能是 <strong>I</strong> 。这表明序列的标签顺序存在一种约束关系，这是LSTM没办法学到的。</p><p>CRF将序列长度为N，类别数为K的序列的预测方式从N个K分类任务转换成一个$K^N$分类任务，从而可以剔除掉一些不符合实际情况的序列预测结果。随之而来的代价就是复杂度提高，解码速度慢。</p><h4 id="预训练模型"><a href="#预训练模型" class="headerlink" title="预训练模型"></a>预训练模型</h4><p>随着这些年预训练模型越来越强大，基本上绝大部分任务的编码阶段都使用预训练模型完成了，序列标注任务也不例外。</p><p>使用Bert之类的预训练模型+LSTM+CRF可以大幅度提高模型效果，甚至于实践证明，如果抛弃LSTM和CRF，仅仅使用softmax作为解码器，仍然可以取得不错的效果，并且大幅度提升速度。</p><h4 id="词汇增强"><a href="#词汇增强" class="headerlink" title="词汇增强"></a>词汇增强</h4><p>根据论文《Is Word Segmentation Necessary for Deep Learning of Chinese Representations?》中的结论，一般来说，中文字向量的效果要强于词向量，并且一般中文预训练模型会生成字向量而不是词向量。而根据常识，在中文中，语义大部分以词汇的形式表示，同一个字在不同词语中的含义可能不同，所以引入词汇信息或许可以对字向量做一些补充，这一方法在一些特定领域会比较有效。</p><h5 id="Lattice-LSTM"><a href="#Lattice-LSTM" class="headerlink" title="Lattice LSTM"></a>Lattice LSTM</h5><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1805.02023">Lattice LSTM：Chinese NER Using Lattice LSTM（ACL2018）</a>算是词汇增强方法的中文NER的开篇之作。</p><p><img src="./lattice.jpg" style="zoom:40%;" /></p><p>这篇论文提出了一种lattice结构，它是一个有向无环图，由词汇的开始和结束决定这个无环图的位置。对于当前的字符，融合以该字符结束的所有word信息，如对于「店」融合了「人和药店」和「药店」的信息。</p><p>但是这种结构也存在一些缺点：</p><ol><li><strong>计算性能低下，不能batch并行化</strong>。因为在不同序列中字符之间的增加word cell数目不一致，每一个序列都要生成单独的lattice结构；</li><li><strong>信息损失</strong>：每个字符只能获取以它为结尾的词汇信息，对于其之前的词汇信息也没有持续记忆。如对于「药」，并无法获得‘inside’的「人和药店」信息；</li><li><strong>可迁移性差</strong>：只适配于LSTM，不具备向其他网络迁移的特性。</li></ol><h5 id="FLAT"><a href="#FLAT" class="headerlink" title="FLAT"></a>FLAT</h5><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2004.11795.pdf">FLAT: Chinese NER Using Flat-Lattice Transformer（ACL2020）</a>适用于Transformer网络结构，设计了一种巧妙position encoding来融合Lattice 结构：</p><p><img src="./flat.png" style="zoom:33%;" /></p><ol><li>将原始序列（设序列字向量个数为N）分词，并将分词之后的词向量（设词向量个数为n）拼接到字向量之后，则新序列向量总长度为N+n；</li><li><p>根据字和词汇的位置生成k种（论文中为4种）相对位置矩阵，大小为 $(N+n)*(N+n)*k$；</p></li><li><p>将相对位置矩阵重新编码之后融合到新序列向量的attention中，生成一个新的attention score。</p></li></ol><p>这样就可以将词汇的向量信息和相对位置信息融合到Transformer网络结构，并且这种方式可以安排在预训练模型之后，这样就可以同时有效利用预训练模型。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络语言模型</title>
      <link href="/2021/08/06/shen-jing-wang-luo-yu-yan-mo-xing/"/>
      <url>/2021/08/06/shen-jing-wang-luo-yu-yan-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h2><p>N-gram语言模型接收离散向量作为输入，一般来说，这些输入都是由词典中的词使用one-hot编码之后获得，因此也引入了one-hot编码的一些弊端。</p><p>从语义相似性的角度，<code>&#123;“猎豹”，“花豹”&#125;</code>要比<code>&#123;“猎豹”，“汽车”&#125;</code>的语义相似度更高，在很多句子中，<code>“猎豹”</code>与<code>“花豹”</code>是可以相互替换的，这表明从语法规则上来说，这两个词的语义也更相似。但是经过one-hot编码之后的词与词之间失去了语义关联，因为编码后的任意两个向量都是单位向量且彼此正交，因此任意两个向量之间的距离都相等，即词与词之间丢失了距离信息。这一点严重限制了N-gram模型的性能。</p><p>N-gram模型无法解决长距离依赖（long dependency）问题。一般在使用N-gram模型时，N的取值为3~5，因为超过5之后模型性能的提升不大，但是计算复杂度却大幅增加。</p><p>前馈神经网络语言模型通过结合词向量（word embedding）和前馈神经网络来解决上面两个问题。</p><p>前馈神经网络语言模型接收低维稠密向量作为输入，这些低位稠密向量由one-hot编码之后的高维稀疏向量训练产生，在训练过程中，高维稀疏向量经过学习与压缩，维度降低且学习到了词汇之间的语义关系。</p><p>语言模型本质是计算  $P（w_1,w_2,w_3,…,w_n）$，即给定句子的概率分布，而神经网络强大的非线性拟合能力很适合拟合概率分布。并且神经网络模型可以获取到当前词汇下文的信息，这一点是N-gram语言模型所不具备的，另外神经网络模型能够利用到的的上下文词汇长度要比N-gram模型长的多，即看到的信息也要更多更广。</p><h4 id="前馈神经网络模型"><a href="#前馈神经网络模型" class="headerlink" title="前馈神经网络模型"></a>前馈神经网络模型</h4><p>神经网络语言模型中最简单的就是前馈神经网络模型。前馈神经网络将 $x_t$ 的前n-1个词的向量进行拼接作为网络输入，经过一次非线性变换，最后输出字典中每个词的概率作为预测结果，其中 $x_t$ 为序列中的第t个词。</p><p><img src="前馈神经网络结构图.png" alt='前馈神经网络结构图' style="zoom:40%;" /></p><p>上述过程主要分为2大步骤：</p><ol><li><p>先将 $x_t$ 前的n-1个单词从词典信息转化为特征向量，这一步通常被称为特征映射或者词嵌入。每个词在词典V（V为词典大小，即词典中词个数）中的index（位置顺序）通过映射矩阵C转换成一个维度为m的特征向量，然后将n-1个单词的特征向量进行拼接，合并成一个（n−1）*m维的向量。</p></li><li><p>合并成的（n−1）*m维向量作为输入送入神经网络，经过一个隐藏层，将输入转换为V维的概率分布，每一维度表示词典中每个词出现在位置t的概率。</p></li></ol><p>可选的部分是将（n−1）*m维的输入向量和隐藏层结果合并预测概率分布，如图中的虚线曲线部分所示。</p><p>从上面的架构图可以看出，前馈神经网络的输入是当前词前后范围很广的词汇，通过当前位置前n-1个词来预测当前位置的概率分布，这个n可以很大，一般取值在数十到数百。相比于N-gram模型只能接受前面3-5个词作为输入，从获取上下文信息的角度上，神经网络语言模型的上限就要高得多。</p><h4 id="循环神经网络语言模型"><a href="#循环神经网络语言模型" class="headerlink" title="循环神经网络语言模型"></a>循环神经网络语言模型</h4><p>前面介绍到的前馈神经网络将一个个的输入单独地送入隐藏层，对于模型来说，在隐藏层之前的输入是隔离开的，前一个输入和后一个输入所携带的信息无法互通。但是，语言模型的一大特点是，即前面的输入和后面的输入是有关联的，这一点在多义词上表现尤为明显。</p><p>比如，<code>“一头牛”</code>和<code>“你真牛”</code>中的同一个<code>“牛”</code>字在不同上下文中的含义不同，甚至词性都不一样，而由于同一个字在词典中出现一次，只有一个index，所以在前馈神经网络中经过特征映射之后只会有一个特征向量，即同一个字在不同的上下文中虽然有不同的含义，却只会有一个固定的特征向量表示，这明显是不合理的。所以很自然的，我们引入了循环神经网络语言模型。</p><p>循环神经网络模型的特殊之处在于每一个RNN神经元不仅接收原始的输入，还会保留上一时刻的隐藏状态，在二者共同作用下生成一个新的输出。</p><p><img src="循环神经网络按时间线展开.png" alt="循环神经网络按时间线展开" style="zoom:30%;" /></p><p>x为输入向量，s表示隐藏层的值（这一层可以是多个节点），o表示输出层的值。</p><p>对于上图左侧的RNN神经元，如果把右侧W去掉，它就变成了全连接神经网络中的一个神经元。循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。隐藏层上一次的值经过权重矩阵 W之后作为这一次输入的一部分。</p><p>从上图右侧可以看出，t时刻网络接收到输入 $x_t$ 之后，生成输出层结果 $o_t$，而 $o_t$ 不仅仅与输入  $x_t$  有关，也与前一时刻的隐藏层结果 $s_{t-1}$ 有关。在 $s_{t-1}$ 和 $x_t$ 的共同作用下，计算出输出结果 $o_{t}$ ，同时生成 $s_{t}$ 用于下一次计算。通过这种类似接力的方式，每一时刻可以保留部分之前时刻的信息。</p><p>通过下图可以明显看出在模型训练过程中，模型可以感受到的文档信息：</p><p><img src="N-gram模型与神经网络模型上下文信息示意图.png" alt="N-gram模型与神经网络模型上下文信息示意图" style="zoom:40%;" /></p><p>上图为unigram、bigram、前馈神经网络和单向循环神经网络四个模型预测“本”字在当前位置出现的概率，其中蓝框部分为网络可以感受到的字的范围。</p><p>当我们预测“智能文本实战”这个序列中的“本”字的概率时，N-gram模型只能接收到有限范围的信息，例如unigram只包含当前时刻，即“本”一个字的信息，而bigram除了当前字之外，还可以获取到前一个字，即“文本”二字的信息。</p><p>而神经网络模型的感受范围就要广得多，前馈神经网络可以获取到前面数十个字的信息，而循环神经网络则更进一步，每个字都融合了之前字的信息。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言模型 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言模型——N-gram模型</title>
      <link href="/2021/05/26/n-gram-yu-yan-mo-xing/"/>
      <url>/2021/05/26/n-gram-yu-yan-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="N-Gram语言模型"><a href="#N-Gram语言模型" class="headerlink" title="N-Gram语言模型"></a>N-Gram语言模型</h2><h3 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h3><p>N-gram模型是一种基于马尔科夫假设的语言模型，简单来说，就是当前一个单词（中文中一般以字为最小单位）出现的可能性大小只与这个单词前面一个或者几个单词有关，而与这几个单词之外的其他单词无关。其中的N即表示有关联的单词的个数（包括当前词本身）。</p><p><img src="N-gram.png" alt="N-gram" style="zoom:50%;" /></p><p>特别的，当N=1，即当前单词出现的可能性不依赖其他任何单词，称为unigram模型；</p><p>N=2，即当前单词出现的可能性与本身和前一个单词有关，称为bigram模型；</p><p>N=3，即当前单词出现的可能性与本身和前两个单词有关，称为trigram。</p><p>。。。</p><p>前面提到，对于一个语言序列 $w_1,w_2,…,w_n$，语言模型负责计算该序列的概率  $P（w_1,w_2,…,w_n）$。</p><p>对于unigram，由于当前词出现的可能性不依赖其他任何词，因此：</p><script type="math/tex; mode=display">P(w_1,w_2,...,w_n) = \prod_{i=1}^nP(w_i) \tag{1}</script><p>对于bigram，当前词出现的可能性只依赖于当前词汇的前一个词，因此：</p><script type="math/tex; mode=display">P(w_1,w_2,...,w_n) = \prod_{i=1}^{n}P(w_i|w_{i-1}) \tag{2}</script><p>其中  $P（w_i|w_i-1）$  表示在的 $w_{i-1}$的 条件下  $w_i$ 出现的概率。</p><p>特别的，$P（w_1|w_0） 即 P（w_1|BOS）\ （BOS表示句子开头）$ 表示 $ w_1 $ 出现在句子开头的概率。</p><p>以此类推，K-gram模型概率为：</p><script type="math/tex; mode=display">P(w_1,w_2,...,w_n) = \prod_{i=1}^{n}P(w_i|w_{i-1}) \tag{3}</script><h3 id="句子开头与结尾"><a href="#句子开头与结尾" class="headerlink" title="句子开头与结尾"></a>句子开头与结尾</h3><p>可以看出，（1）式和（2）式不太一样，变成了条件概率，并且多了 <code>BOS</code> 对于bigram来说，因为要考虑到前一个字对于当前字的影响，那么某个字出现在句子中或者句子开头的概率是不一样的。那么为了表示某个字出现在句子开头，我们添加一个特殊符号 <code>&lt;BOS&gt;（或者s）</code>。</p><p>另外，为了保持所有句子出现的总的概率为1，需要人为在句尾添加一个特殊符号<code>EOS（或者\s）</code> 表示句子结束，否则所有长度为1的句子出现概率之和已经为1：$\sum_{i=1}^n P(w_i|BOS) = 1$，而添加句尾符号之后，所有的句子的概率和为1（满足一个真正的分布）。</p><p>如果没有结束标签，那么N-gram系统根本没法区分一个长度为m的句子和一个长度大于m的句子中的前m个词。</p><p>在实践中，一般是在词表中添加一个特殊符号表示结尾符号，一个有N个字的词表，在计算单词概率时，加入结尾符号，按照N+句子个数来计算。</p><h3 id="模型计算"><a href="#模型计算" class="headerlink" title="模型计算"></a>模型计算</h3><p>之所以N-gram模型属于统计语言模型，是因为N-gram模型中，我们根据极大似然估计，由单词出现的频率来计算单词的概率。</p><p>以unigram为例，因为当前单词（或者字）的出现概率与其他词无关，只与本身出现的次数有关，那么某个单词（或者字）出现的概率为</p><script type="math/tex; mode=display">P(w_i) = \frac{count(w_i)}{T} \tag{4}</script><p>其中 $count（w_i）$ 为 $w_i$ 出现的次数， $T$ 为语料库或者说单词表中所有字的个数（加上结尾符号，结尾符号个数等于句子个数。）。</p><p>以中文为例，直观解释就是，以一篇文章作为语料库，某个字出现在这篇文章的次数 $\div$ 这篇文章的总字数，就是这个字的概率。</p><p>下面举个小例子：</p><p>有一句话 $T$ 作为语料库：“张三喜欢写代码，张三和李四喜欢听音乐。”</p><p>要求得“张三喜欢音乐”出现的概率。</p><p>除去标点符号，共18个字（其中包括一个结束符号）。“张”、“三”，“喜”、“欢”出现2次，“听”、“音”、“乐”各出现一次。则：</p><blockquote><p>P（张）= P（三）= P（喜）= P（欢）= 1/9，P（听）= P（音）= P（乐）= 1/18。</p><p>P（张三喜欢听音乐）= P（张）* P（三）* P（喜）* P（欢）* P（听）* P（音）* P（乐）= 1.31*10-8。</p><p>P（张三喜欢音乐）= P（张）* P（三）* P（喜）* P（欢）* P（音）* P（乐）= 2.35*10-7。</p></blockquote><p>很显然，句子的长度在很大程度上会影响句子的概率，这就是之前提到的，为何计算句子困惑度需要用N次根号去解决句子长度对于句子概率的影响。</p><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><p>对于unigram，P（欢）= count（欢）/ count（T）= 1 / 9, 只需要遍历一次词表就可以计算出“欢”出现的概率。</p><p>对于bigram，则需要使用条件概率才能计算出连续两个单词出现的概率，所以N为2时，相比N为1 的N-gram模型，计算复杂度高了一个量级。</p><p>仍然以 <code>N-gram模型计算</code> 一节中的  $T$  作为语料库，此时我们使用<strong>bigram</strong>模型，此时模型计算公式为：</p><script type="math/tex; mode=display">P(张三喜欢听音乐) = P(张|BOS) * P(三|张) * P(喜|三) * P(欢|喜) * P(听|欢) * P(音|听)  * P(乐|音) * P(EOS|乐)</script><p>计算条件概率的方法仍然是数次数，只不过此时数数过程稍有不同，以二维转移矩阵显示比较直观：</p><p><img src="matrix.jpg" style="zoom:33%;" /></p><p>从表中可得：</p><script type="math/tex; mode=display">P(张三喜欢听音乐) = 1 * 1 * 0.5 * 1 * 0.5 * 1 * 1 * 1 = 0.25</script><p>很显然，bigram模型概率的计算过程与unigram模型比较相似，但是条件概率计算难度比单个字符出现概率计算难度复杂的多。举个例子：</p><p>对于unigram，</p><script type="math/tex; mode=display">P(欢)=\frac{count(欢)}{count(T)} = \frac{2}{18} = \frac{1}{9}</script><p>即只需要遍历词表一次即可输出 <strong>“欢”</strong> 出现的次数。</p><p>对于bigram，</p><script type="math/tex; mode=display">P(听|欢)=\frac{count(欢听)}{\sum_{x}count(欢x)}=\frac{1}{count(欢听)+count(欢写)} = \frac{1}{2}</script><p>计算 $P（听|欢)$ 需要先遍历除所有以 <strong>“欢”</strong> 开头的词语，再计算 <strong>“欢听”</strong> 的条件概率。</p><p>更一般的：</p><script type="math/tex; mode=display">P(w_{i+1} | w_{i}) = \frac{count(w_iw_{i+1})}{count(w_i)}</script><p>也就是说，N为2时相比N为1的N-gram模型，计算复杂度高了一个量级。</p><p>N-gram模型的参数数量与N的关系成指数级，因此计算量受到N的影响很大。</p><p>毫无疑问，增大N的值可以提高模型的性能，但是也会使得模型难以计算，所以实践中一般用bigram或者trigram。</p><p><img src="困惑度.jpg" alt="N-gram模型困惑度" style="zoom:30%;" /></p><p>N-gram模型的模型效果和计算量就像天平的两端，往往二者不可得兼，为了减少参数量，只能减小N的取值，但这样不可避免地会导致模型效果下降。一般来说，N-gram模型中的n的取值也就是3~5，而即使是N选取比较大的的值，也难以充分覆盖前文信息，因此仍然无法解决长距离依赖关系问题。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言模型 </tag>
            
            <tag> N-gram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语言模型概述</title>
      <link href="/2021/05/03/yu-yan-mo-xing-gai-shu/"/>
      <url>/2021/05/03/yu-yan-mo-xing-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="语言模型基本概念"><a href="#语言模型基本概念" class="headerlink" title="语言模型基本概念"></a>语言模型基本概念</h2><h3 id="语言模型基础"><a href="#语言模型基础" class="headerlink" title="语言模型基础"></a>语言模型基础</h3><p>语言模型（Language Model），顾名思义，是与语言相关的模型，是对语句的概率分布的建模。那么既然是模型，应当有模型的输入与对应的输出，对于语言模型，输入为字或者单词组成的序列，输出为这个序列的概率。</p><p>所以语言模型的定义是，对于一个给定的语言序列 $w_1,w_2,…,w_n$，语言模型用于计算序列的概率分布$P(w_1,w_2,…,w_n)$。</p><p>通俗点说，就是给定一个语句，语言模型用于判断该语句是否符合人类语言。</p><p>解释完什么是语言模型，接下来简单介绍一下为什么语言模型是有效的。上学学习语文的时候，语文老师教导我们每一句话都是有组成成分的，如<code>‘主谓宾’</code>，<code>‘定状补’</code>的句子结构等，那么基于这些结构，<code>‘我是人’</code>通常比<code>‘我是六点半’</code>更像是一句人类语言。另外，单词或者短语自身也存在依存关系和顺序关系，比如‘我们’比‘们我’更像是正常人会说的词。</p><p>看起来语言模型似乎很专业，然而实际上它早已经广泛应用于我们的生活中，最常见的如搜索引擎或者输入法在我们输入一些单词后给出联想词：</p><p><img src="语言模型.png" alt="搜索引擎词汇联想" style="zoom:50%;" /></p><p>另外，人的大脑中的语言系统，就是一个非常强大的语言模型。例如在理解人类语音时，从听力转到语言的过程中，人脑扮演了语言模型的角色。在听到<code>‘wo xi huan ni’</code>这句话的时候，绝大多数人应该会理解为<code>‘我喜欢你’</code>而不是<code>‘我洗换你’</code>。</p><p>事实上，语言模型起源于语音识别领域，实现的功能正类似于人类语言系统识别语音。而随着语言模型与深度学习的发展，语言模型的功能越来越强大，应用范围早已经扩展到翻译、搜索、问答等众多领域。</p><h3 id="困惑度定义"><a href="#困惑度定义" class="headerlink" title="困惑度定义"></a>困惑度定义</h3><p>语言模型首先是一个模型，那么我们需要一个方法或者指标来评估这个模型预测一个语言样本的能力。前面提到，语言模型可以计算出给定序列的出现概率。概率即不确定性，统计学中常常使用交叉熵来衡量不确定性，而困惑度实际上是交叉熵的指数形式。因此，困惑度是评估一个概率模型预测样本能力的指标。</p><p>这里给出困惑度（Perplexity）的数学定义：</p><script type="math/tex; mode=display">perplexity = P(w_1,w_2,...,w_n)^{-\frac{1}{n}}</script><p>从公式可以看出，困惑度是与句子的出现概率是负相关的。</p><p>模型对于真实数据集中的句子预测其出现的概率越大，那么模型的困惑度越小，也就是该模型性能越好。而公式中的N次根号是为了解决句子长度对于句子概率的影响，因为越长的句子的概率在连乘的情况下必然越小。</p><p>困惑度与语料库紧密相关，因而两个或多个语言模型只有构建在相同的语料库上才能使用困惑度进行对比。</p><h3 id="语言模型类型划分"><a href="#语言模型类型划分" class="headerlink" title="语言模型类型划分"></a>语言模型类型划分</h3><p>下面会介绍两个较为典型的语言模型：基于统计语言模型的N-gram模型和基于深度学习的神经网络语言模型。</p><p>统计语言模型（Statistical Language Model，SLM）尝试获取自然语言中的语法规则，以建立一个可以尽可能准确估计自然语言概率分布的统计学模型。</p><p>N-gram模型是如今使用最广泛的统计语言模型。N-gram模型把一个完整句子分割为固定长度为N的小片段，通过计算这些片段的概率来近似计算整个句子的概率。很显然，简单切分为固定长度的方式并不总是可以正确切分句子，固定长度N过小会导致信息丢失，而如果N设置过大也会导致计算量过大。</p><p>为了解决使用统计语言模型遇到的问题，人们把目光转向了神经网络（Neural Network，NN）。包括前馈神经网络（Forward Feedback Neural Network，FFNN）和循环神经网络（Recurrent Neural Network，RNN）在内的神经网络都能接收到更广泛的上下文作为输入，自动学习到每个字符的表征和上下文关系，性能较传统的语言模型有了大幅度的提升。</p><h4 id="本站语言模型文章链接"><a href="#本站语言模型文章链接" class="headerlink" title="本站语言模型文章链接"></a>本站语言模型文章链接</h4><a href="/2021/05/26/n-gram-yu-yan-mo-xing/" title="语言模型——N-gram模型">语言模型——N-gram语言模型</a><a href="/2021/08/06/shen-jing-wang-luo-yu-yan-mo-xing/" title="神经网络语言模型">语言模型——神经网络语言模型</a>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言模型 </tag>
            
            <tag> NLP </tag>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python协程入门</title>
      <link href="/2021/04/02/python-xie-cheng/"/>
      <url>/2021/04/02/python-xie-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发编程是指在一台处理器上“同时”（同一个时间段）处理多个任务。</strong> 并发是在同一实体上的多个事件。 多个事件在同一时间间隔发生。</p><p>比如，多个线程任务在同一个CPU上快速地轮换执行，由于切换的速度非常快，给人的感觉就是这些线程任务是在同时进行的，但其实并发只是一种逻辑上的同时进行。</p><p>举个例子，你有一台单CPU的电脑，在上面打开了一个视频播放软件，这样就启动了一个进程，但是这个进程内部有2个线程，一个用于显示视频，另一个用于播放声音。在任意一个时刻，只有一个线程占用CPU，所以视频于音频并不是同时播放的，只是因为线程切换速度快到无法察觉，从宏观上看起来是“同时”的。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>协程，又称微线程，英文名<code>Coroutine</code></strong>。实际上，协程是运行在单线程中的“并发”，程序员通过高超的代码能力，在代码执行流程中人为的实现多任务并发，是单个线程内的任务调度技巧。协程相比多线程的一大优势就是省去了多线程之间的切换开销，获得了更高的运行效率。</p><blockquote><p>特点：</p><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</li><li>协程切换需要的Stack远小于线程，因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免出现竞争和死锁。</li><li>适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。</li></ol></blockquote><h3 id="python协程"><a href="#python协程" class="headerlink" title="python协程"></a>python协程</h3><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>python中协程的原始实现方式是通过yield关键字实现，而yield关键字在python中用于实现生成器。</p><p>yield的语法规则是这样的：<strong>代码执行时遇到yield则停止执行，返回yield右侧的值（没有则返回None），遇到next（或者send）命令则从yield处继续执行，并将send命令的参数传给yield的左值变量。</strong></p><p>看个例子：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">example_coroutine</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;-&gt; 启动协程&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    y </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span></span><span class="line"><span style="color: #ABB2BF">    x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">yield</span><span style="color: #ABB2BF"> y</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;-&gt; 协程接收到了x的值:&#39;</span><span style="color: #ABB2BF">, x)</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">ex_coro </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">example_coroutine</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">res </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">next</span><span style="color: #ABB2BF">(ex_coro)  </span><span style="color: #7F848E; font-style: italic"># 或者ex_coro.send(None)</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(res)</span></span><span class="line"><span style="color: #ABB2BF">ex_coro.</span><span style="color: #61AFEF">send</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">## 控制台输出：</span></span><span class="line"><span style="color: #FFFFFF">-&gt;</span><span style="color: #ABB2BF"> 启动协程</span></span><span class="line"><span style="color: #D19A66">10</span></span><span class="line"><span style="color: #FFFFFF">-&gt;</span><span style="color: #ABB2BF"> 协程接收到了x的值: </span><span style="color: #D19A66">10</span></span><span class="line"><span style="color: #61AFEF">Traceback</span><span style="color: #ABB2BF"> (most recent call last):</span></span><span class="line"><span style="color: #ABB2BF">  File </span><span style="color: #98C379">&quot;d:/exercise/algorithm_exercise/py_coroutine.py&quot;</span><span style="color: #ABB2BF">, line </span><span style="color: #D19A66">15</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">module</span><span style="color: #56B6C2">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    ex_coro.</span><span style="color: #61AFEF">send</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">StopIteration</span></span></code></pre></div></div></figure><p>过程是这样的：next唤醒生成器，生成器返回变量y的值10，res接收到生成器的返回值,send(10)将10传入生成器并赋值给变量x，最后生成器结束，抛出<code>StopIteration</code>异常。</p><p>实际上到这里，已经实现了一个简易的协程，通过yield和send实现任务切换。</p><p>下面的例子表示如何通过协程实现主任务与副任务切换：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">task1</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        count </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">yield</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;&lt;甲&gt;累了，让&lt;乙&gt;工作一会儿&quot;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> count:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;&lt;甲&gt;开始工作.....&quot;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">break</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">task2</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">t</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># next(t)</span></span><span class="line"><span style="color: #ABB2BF">    a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> t.</span><span style="color: #61AFEF">send</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># a = &quot;&lt;甲&gt;累了，让&lt;乙&gt;工作一会儿&quot;</span></span><span class="line"><span style="color: #ABB2BF">    count </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> count:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;-----------------------------------&quot;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;&lt;乙&gt;开始工作.....&quot;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        time.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;&lt;乙&gt;累了，让&lt;甲&gt;工作一会儿....&quot;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        ret </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> t.</span><span style="color: #61AFEF">send</span><span style="color: #ABB2BF">(count)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(ret)</span></span><span class="line"><span style="color: #ABB2BF">        count</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">    t.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">task1</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">task2</span><span style="color: #ABB2BF">(t)</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 控制台输出</span></span><span class="line"><span style="color: #FFFFFF">----------------------------------</span><span style="color: #56B6C2">-</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">开始工作</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">..</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">累了，让</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">工作一会儿</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">.</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">开始工作</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">..</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">累了，让</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">工作一会儿</span></span><span class="line"><span style="color: #FFFFFF">----------------------------------</span><span style="color: #56B6C2">-</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">开始工作</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">..</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">累了，让</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">工作一会儿</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">.</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">开始工作</span><span style="color: #D19A66">...</span><span style="color: #ABB2BF">..</span></span><span class="line"><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">甲</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">累了，让</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">乙</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">工作一会儿</span></span></code></pre></div></div></figure><h4 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h4><p><code>asyncio</code>是<strong>Python 3.4</strong>版本引入的标准库，直接内置了对异步IO的支持。asyncio是一个基于事件循环的异步IO模块。</p><p><code>yield from</code>可以返回另一个生成器生成的值。<a href="https://wenkefendou.gitbooks.io/python3-learning/content/yield_from.html">yield详细介绍点这里</a>。</p><p>asyncio可以分成三个过程：</p><ol><li>创建事件循环</li><li>指定循环模式并运行</li><li>关闭循环</li></ol><p>要注意的是，简单地调用一个协程并不会使其被调度执行。</p><p>通常我们使用<code>asyncio.get_event_loop()</code>方法创建一个循环。</p><p>循环创建后可以通过<code>run_until_complete()</code>方法或者<code>run_forever()</code>方法来运行循环</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> asyncio</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> threading</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">@asyncio</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">coroutine  </span><span style="color: #7F848E; font-style: italic"># 声明为协程函数</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hello1</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 1 start! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">yield from</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 遇到IO，出让线程</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 1 end! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">@asyncio</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">coroutine</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hello2</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 2 start! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">yield from</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 2 end! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    loop </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">get_event_loop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    tasks </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #61AFEF">hello1</span><span style="color: #ABB2BF">(), </span><span style="color: #61AFEF">hello2</span><span style="color: #ABB2BF">()]</span></span><span class="line"><span style="color: #ABB2BF">    loop.</span><span style="color: #61AFEF">run_until_complete</span><span style="color: #ABB2BF">(asyncio.</span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(tasks))</span></span><span class="line"><span style="color: #ABB2BF">    loop.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 控制台输出</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> start! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">21500</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> start! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">21500</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 在这里阻塞1s</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> end! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">21500</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> end! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">21500</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p>上面一段代码，使用asyncio模拟了同一个线程中的两个协程。不像上面的例子，分为主副协程，这个例子中的hello1和hello2属于平等，并不是由某个协程直接唤醒另外一个协程。虽然hello1再task列表中排在第一位，先执行的确是hello2 协程。</p><p>具体过程为<code>@asyncio.coroutine</code>装饰器声明协程，调用协程并不会使其被执行。<code>asyncio.sleep(1)</code>模拟1s的IO操作。<code>hello2</code>协程先执行，遇到IO操作时出让CPU，然后<code>hello1</code>协程被调度，同样遇到IO出让CPU，hello2的<code>asyncio.sleep(1)</code>结束后，由<code>yield from</code>返回hello2协程，获取CPU资源。因此虽然模拟了2s的IO操作，但是2次IO同时进行，程序总耗时大约1s。</p><h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><p><strong>Python3.5</strong>中对协程提供了更直接的支持，引入了<code>async/await</code>关键字。使用<code>async</code>代替<code>@asyncio.coroutine</code>，使用<code>await</code>代替<code>yield from</code>，代码变得更加简洁可读。从Python设计的角度来说，<code>async/await</code>让协程独立于生成器而存在，不需要再借助yield语法。<code>async</code>与<code>await</code>必须成双成对使用。</p><p>下面使用async和await重写上面的代码：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> asyncio</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> threading</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">async</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hello3</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 3 start! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">await</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 3 end! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">async</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hello4</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 4 start! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">await</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;Hello 4 end! (</span><span style="color: #D19A66">%s</span><span style="color: #98C379">)&#39;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> threading.</span><span style="color: #61AFEF">currentThread</span><span style="color: #ABB2BF">())</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">__name__</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;__main__&#39;</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    loop </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> asyncio.</span><span style="color: #61AFEF">get_event_loop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    tasks </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #61AFEF">hello3</span><span style="color: #ABB2BF">(), </span><span style="color: #61AFEF">hello4</span><span style="color: #ABB2BF">()]</span></span><span class="line"><span style="color: #ABB2BF">    loop.</span><span style="color: #61AFEF">run_until_complete</span><span style="color: #ABB2BF">(asyncio.</span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(tasks))</span></span><span class="line"><span style="color: #ABB2BF">    loop.</span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 控制台输出</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF"> start! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">15288</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> start! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">15288</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF"> end! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">15288</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">Hello </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF"> end! (</span><span style="color: #56B6C2">&lt;</span><span style="color: #61AFEF">_MainThread</span><span style="color: #ABB2BF">(MainThread, started </span><span style="color: #D19A66">15288</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><h2 id="怎么用协程"><a href="#怎么用协程" class="headerlink" title="怎么用协程"></a>怎么用协程</h2><p>开头介绍了一些协程与线程的区别以及协程的优点，但是事实上大部分情况下，多线程都能很好的完成任务，而并不是花心思写协程。</p><p>目前，主流的代码结构设计理念需要先对要解决的问题进行抽象、分解、建模，强调的是高内聚低耦合的模块化思想。模块之间不应该相互影响，这对于互相基本不影响的多线程来说是很自然的，对于底层资源的竞争都交给操作系统来解决，上层的代码层面就可以做到模块化。而对于协程，却并不是这样，协程把资源的分配提到用户态，由程序员在代码中实现逻辑流，不可避免地会使得一些代码相互耦合。</p><p>但是多线程也不是万能的，抢断式线程调度下，操作系统对于不同线程的时间片分配使公平的，公平有时候就会导致效率低下。另外，涉及到线程非独立的时候会遇到更多的问题，比如A线程需要B线程产生的资源，那么操作系统即使切换到A线程，也会因为资源不足而必须再切回去；又比如多线程操作同一个资源，需要进行线程安全处理。这些情况下，主动出让式的协程效率则高得多。</p><p>在如今的python程序中，协程绝大多数情况下用来处理网络IO或者文件IO，但是很多情况下也是可以从协程的角度去设计代码的，很多问题从协程角度去思考可能会别有一番天地。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention is all you need</title>
      <link href="/2021/03/10/attention-is-all-you-need/"/>
      <url>/2021/03/10/attention-is-all-you-need/</url>
      
        <content type="html"><![CDATA[<h2 id="对Attention的一些解读"><a href="#对Attention的一些解读" class="headerlink" title="对Attention的一些解读"></a>对Attention的一些解读</h2><p>2017年，Google发表了论文《Attention is All You Need》，在论文中，抛弃了常用的RNN结构，提出了一种比较新颖的Attention结构。</p><h3 id="Attention的作用"><a href="#Attention的作用" class="headerlink" title="Attention的作用"></a>Attention的作用</h3><p>在做NLP任务时，原始数据一般是句子级别，所以需要先将句子拆分，中文通常按照词或者字级别进行拆分。以中文字拆分为例，拆分后的每个字通过字典获取这个字的唯一编号，然后将这个编号转换成对应的字向量。这样，一个句子<code>X</code>可以表示成 $X=( x_0,x_1, …,x_n)$，其中 $x_i$ 为该句子中第 $i$ 个字的字向量，维度为v, 即$X\in R_{n×d_v}$。</p><p>将编号转换成向量的最简单方法为one-hot编码，但是这种编码方式不具备实用性，我们需要的是一种维度更低的，表达语义效果更好的向量。</p><h4 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h4><p>在NLP领域中，最常用的编码结构为RNN结构，RNN方法的过程可以简单表示为一种递归的方式</p><script type="math/tex; mode=display">y_{t+1}=f(y_t, x_t)</script><p>这样，在改变原始字的向量维度的同时，还可以结合到这个字之前的字的信息，从而可以实现对于同一个字在不同语境中生成不同的字向量。</p><p>在所有语言中，都会出现字或者单词存在一字多义的情况，使用one-hot编码的方式，无法处理这样的情况。比如说，“一头牛”和“你真牛”中的“牛”明显不是同一个含义，甚至于词性都不一样，但在one-hot这样的编码方式中，这两个“牛”的字向量是完全相同的，而在RNN结构中就可以实现同一个字根据上下文语义生成不同的字向量，例如双向的RNN结构可以同时获取当前字之前和之后的语义信息。</p><p>基于这样的特性，RNN天然的适合序列建模，但RNN的明显缺点之一就是无法并行，因此速度较慢，另外RNN无法很好地学习到全局的结构信息。因为它本质是一个马尔科夫决策过程，其他字对于当前字的影响会随着距离的拉远而削弱和稀释，这和语言学上的表现是不一致的，语言中字之间的关系并不严格和位置正相关，因此很多时候，距离较远的字对当前字在语义信息上的影响要大于当前字旁边的字，而这一点很难在RNN结构上体现出来。</p><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>CNN结构也是一种可以用于生成序列字向量的结构，和RNN的递归方法不同，CNN结构通过当前字符的前后字符来重新编码当前字符，从而可以获取一定范围上下文信息，这有点儿类似于前后方向上的N-gram方法。</p><p>例如，CNN结构中卷积核尺寸为3，则经过该结构之后的字向量可以表示为：</p><script type="math/tex; mode=display">y_t = f(x_{t-1}, x_{t}, x_{t+1})</script><p>而对于超过了卷积核范围的其他字向量信息，可以通过层级结构，扩大感受野，获取更远距离的字符信息。</p><h4 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h4><p>Attention Mechanism和CNN与RNN最大的不同是，在attention结构中，每一个字可以获取到所有信息。</p><script type="math/tex; mode=display">Y = f(Q, K, X)</script><p>其中Q，K为列维度相同的矩阵，X为输入的句子的子向量，且K和X的向量个数相同，即 $ Q\in R_{m×d_k},K\in R_{n×d_k},V\in R_{n×d_v} $。</p><p>当Q=K=X时，称为self-attention。</p><p>以self-attention为例，在self-attention中，每个字都可以直接与句子中任意一个字直接连接，即这个字可以获取到句子中任意一个字的信息。</p><p>下面我们详细看看，attention是怎么实现这一效果的。</p><h3 id="Attention定义"><a href="#Attention定义" class="headerlink" title="Attention定义"></a>Attention定义</h3><p><img src="./attention.png" style="zoom:67%;" alt="attention 示意图"/></p><script type="math/tex; mode=display">Attention(Q,K,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V \\其中 Q\in R_{m×d_k},K\in R_{n×d_k},V\in R_{n×d_v}</script><p>结构很简单，除去中间的Scale,Mask,SoftMax之后，就是两次简单的矩阵运算，Attention之后的矩阵维度为$R_{m×d_v}$。当Q=K=V时，就是self-attention。</p><p>对于这个结构的作用，可以这么理解：K，V是一对匹配对，Q是一个query，通过Q和K的矩阵运算，计算Q与K的相关性，再用这个相关性与V做矩阵运算，后得到一个由V构成的与Q相关的矩阵。  </p><p>举个例子：有这样一句话“Attention is all you need”，使用self-attention，即Q=K=V均为该句子的向量。设每个字的向量长度为d，则Q，K，V矩阵维度为5*d。</p><p>先计算$QK^T$, 为一个5*5的矩阵，这个矩阵的第i行第j列表示第i个单词向量与第j个单词的向量的点乘。我们知道向量的点乘可以表示两个向量的“相似度”，两个向量越“相似”，它们的点乘结果越大。因此该矩阵就表示这个句子中5个单词向量之间的相似性。将这个矩阵经过scale和softmax之后，与V做矩阵运算生成一个新的5*d矩阵，这个新的矩阵就是这个句子中5个单词的新的表征向量，并且每个单词的新的表征是由这句话中的5个单词的原始向量组成的，从而每个单词的新的表征向量获取到了这个上下文的信息。</p><p>想象一下这个场景：一个队伍按次序排列，每个人只能接收到相邻人的消息，也只能向相邻的人发出消息，这种传递消息的方式就相当于RNN及其变种。我们把相邻的人称为邻居，除了自己和邻居之外的人称为非邻居，实际上每个人都接收不到非邻居的消息，这些非邻居的消息是经过自己的邻居处理过的，而不是原始的消息。</p><p>而Attention可以想象成是这种场景，所有人散布在操场上，每个人之间没有顺序关系，但是每个人都随身携带一个对讲机，可以和任意一个直接通信，每个人都根据和其他所有人直接通信之后收到的信息生成一个新的向量。</p><h4 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h4><p><img src="Multi-Head-Attention.png" style="zoom:67%;" alt="multi-head attention 示意图"/></p><p>论文中使用的方法主要是Multi-Head Attention，这个Multi-Head Attention实际上也非常简单，首先将V,K,Q三个举证经过一层简单的全连接网络，然后新的V,K,Q矩阵进行Attention，上述的过程重复h次之后结果拼接起来，就是h次的Multi-Head Attention。</p><script type="math/tex; mode=display">MultiHead(Q, K, V ) = Concat(head_1, ..., head_h)W^O \\{\bf where} \ head_i = Attention(QW^Q_i, KW^K_i, VW^V_i) \\其中 Q\in R_{m×d_k},K\in R_{n×d_k},V\in R_{n×d_v}, W^Q_i\in R_{d_k× \widetilde d_k}, W^K_i\in R_{d_k× \widetilde d_k}, W^V_i\in R_{d_v× \widetilde d_v}</script><p>可以看出，经过Multi-Head Attention之后，新的结果矩阵维度为$R_{m×(h \widetilde d_v)}$，如果全连接矩阵不改变输入的Q，K，V三个矩阵的维度，则，经过h次的Multi-Head Attention之后，结果矩阵的列维度会变成输入的h倍，所以为了保持输入矩阵经过h次的Multi-Head Attention之后字向量维度不变，在论文中，Google设置$\widetilde d_k, \widetilde d_v$为$d_k, d_v$的 $\frac{1}{h}$。</p><h4 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h4><p>论文的一大贡献就是，证明了Self-Attention在机器翻译的编码过程中的是非常有效的。正如在Attention小节中提到的，在self-attention中，每个字都可以直接与句子中任意一个字直接连接，即这个字可以获取到序列中任意一个字的信息。因此在编码过程中，可以更好的找到每个字之间的联系。</p><p>当然，论文中使用的是Self Multi-Head Attention。</p><p>我们可以这样理解Self-Attention：对于一个序列$X=( x_0,x_1, …,x_n)$， $x_i$为序列中第i个字的字向量，序列 $X$ 经过Self-Attention之后的新向量为 $Y =( y_0,y_1, …,y_n)$， $y_i$为序列中第i个字的新生成的字向量，即：</p><script type="math/tex; mode=display">Y = f(X, K, X)</script><p>如果不考虑最后的Softmax，可以理解为 $y_i$是由 $x_0,x_1, …,x_n$ 按照一定比例相加产生的。</p><p>这样的过程可以用来表示序列中每个字对于其他字不同的影响。</p><h4 id="Position-Embedding"><a href="#Position-Embedding" class="headerlink" title="Position Embedding"></a>Position Embedding</h4><p>上文提到Attention可以看成是所有人散布在操场上，每个人之间没有顺序关系，但是每个人都随身携带一个对讲机，可以和任意一个直接通信。这样却有一个明显的缺点，那就是序列中所有的字失去的原有的顺序关系，因为它们可以直接通信，所以并不知道它们之间的相互字符距离，而这个字符距离或者说字符的顺序在很多场景是必不可少的。比如在翻译任务中，“人吃肉”和“肉吃人”肯定不是一个相同的意思，失去顺序信息可能导致每个字的意思都翻译出来了，但是句子意思截然不同。</p><p>为了解决个问题，Google引入了”位置向量”——“Position Embedding”，通过给每一个位置编一个号，让每一个编号对应一个字向量，从而和字向量一起加入到模型中，在纯Attention模型中，Position Embedding是位置信息的唯一来源，因此它是模型的核心成分之一。</p><p>在Google的论文中，直接给出了这个“Position Embedding”的计算方法，和以往的由模型学习产生不同，论文中的“Position Embedding”是由公式直接计算出来的。</p><script type="math/tex; mode=display">\begin{cases}PE(pos,2i)=sin(p/10000^{2i/d_{pos}}) \\PE(pos,2i+1)=cos(p/10000^{2i/d_{pos}})\end{cases}</script><p>Google在论文中也提到，他们尝试过直接训练出来的位置向量，和公式计算出来的位置向量，模型效果基本一致。并且公式计算的方式可以满足模型推理时序列长度长于模型训练的情况。</p><h4 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h4><p><img src="./complexity.png" style="zoom:67%;" /></p><p>上图是论文中的每一层Attention与RNN以及CNN相比较的复杂度，n表示序列中字的个数，d表示字向量的长度，k表示CNN层卷积核的大小，r表示restrict Attention中相邻字的长度。</p><p>由于一般来说，一个序列中的相关联的字距离不会很大，即使是一句较长的序列，一般相关字距离也就几十。而目前预训练模型一般设置字向量的长度为512、768甚至1024等，要大于序列长度，所以从这个角度来看，Attention的计算复杂度要低于RNN。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>上面介绍了一些Attention的好处，但是它也有不足之处。首先Attention失去了位置信息，使用Position Embedding来弥补这一缺点，但是Position Emdedding对位置的表达能力有限，对于翻译任务表现还好，但是对于序列标注任务就有所力不从心了。我曾经尝试过使用self-Attention于序列标注的任务，加入Position Emdedding之后效果几乎没有提升。由此看出Attention想要完全代替RNN还需要进一步解决位置信息的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attention </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式与python正则</title>
      <link href="/2021/01/01/zheng-ze-biao-da-shi-yu-python-zheng-ze/"/>
      <url>/2021/01/01/zheng-ze-biao-da-shi-yu-python-zheng-ze/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一个特殊的字符序列，它使用单个字符串来描述、匹配一系列匹配某个句法规则的字符序列，通常被用来检索、替换那些匹配某个模式的文本。</p><p>正则表达式是一种用来匹配字符串的强有力的武器。所以多用于字符校验，比如密码是否符合强度要求；校验电话号码或者邮箱是否合法等等。</p><p>正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同。</p><h3 id="常用的正则元素："><a href="#常用的正则元素：" class="headerlink" title="常用的正则元素："></a>常用的正则元素：</h3><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>一般字符</td><td>匹配自身</td></tr><tr><td><code>.</code></td><td>匹配除了换行符之外的字符</td></tr><tr><td><code>\d</code></td><td>数字</td></tr><tr><td><code>\D</code></td><td>非数字，即\d的逆 <code>[^\d]</code></td></tr><tr><td><code>\s</code></td><td>空白字符（空格、换行、制表等）</td></tr><tr><td><code>\S</code></td><td>非空白字符</td></tr><tr><td><code>\w</code></td><td>单词字符</td></tr><tr><td><code>\W</code></td><td>非单词字符</td></tr><tr><td>　<code>｜</code></td><td>左右任意匹配一个，先左后右</td></tr><tr><td><code>[]</code></td><td>字符集，中括号内部既可以是单个字符如<code>[abc]</code>，也可以是字符范围如<code>[0-3]</code></td></tr><tr><td><code>()</code></td><td>小括号内部表示一个整体作为一个分组，并且会依次赋予一个编号</td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>大括号表示前一个字符或者字符集和重复次数，包括m和n次</td></tr><tr><td><code>*</code></td><td>匹配前一个字符0到无限次</td></tr><tr><td><code>+</code></td><td>匹配前一个字符1到无限次</td></tr><tr><td><code>?</code></td><td>匹配前一个字符0次或者1次，问号加在<code>&#123;m,n&#125;,*,+,?</code>这些数量词后面，可以变成非贪婪匹配</td></tr><tr><td><code>^</code></td><td>匹配开头</td></tr><tr><td><code>$</code></td><td>匹配结尾</td></tr></tbody></table></div><p>除了上面一些常用的元素外，还有一些比较强大的分组用法，比如：</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td><code>\number</code></td><td>引用编号为<code>&lt;number&gt;</code>的分组所匹配到的字符串</td></tr><tr><td><code>(?=X)</code></td><td>匹配的字符串的后面限制为X，如<code>a(?=\d)</code>匹配后面是数字的a</td></tr><tr><td><code>(?!X)</code></td><td>匹配的字符串的后面限制不为X，如<code>a(?!\d)</code>匹配后面不是数字的a</td></tr><tr><td><code>(?&lt;=X)</code></td><td>匹配的字符串的前面有限制条件，如<code>a(?&lt;=\d)</code>匹配前面是数字的a</td></tr><tr><td><code>(?&lt;!X)</code></td><td>匹配的字符串的前面有限制条件，如<code>a(?&lt;=\d)</code>匹配前面不是数字的a</td></tr></tbody></table></div><h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><p><strong>贪婪匹配：</strong>贪婪匹配在匹配字符串时总是尝试匹配<strong>尽可能多</strong>的字符。</p><p><strong>懒惰匹配：</strong>与贪婪匹配相反，懒惰匹配在匹配字符串时总是尝试匹配<strong>尽可能少</strong>的字符。</p><p>在python中默认使用的是贪婪匹配。</p><p>举个例子，一个字符串<code>abcabc</code>，正则表达式为<code>a.*c</code>，那么默认的贪婪匹配匹配到的结果为<code>abcabc</code>，非贪婪匹配的结果为<code>abc</code></p><p>从贪婪匹配模式改成懒惰匹配也很简单，只要在表示次数的元素<code>*、？、+、&#123;m,n&#125;</code>后面加上<code>？</code>即可。</p><p><img src="re.jpg" style="zoom:50%;" /></p><h2 id="python正则"><a href="#python正则" class="headerlink" title="python正则"></a>python正则</h2><p>python中的re模块是python自带的处理正则表达式的库。</p><p>主要方法有</p><blockquote><p>re.match()，re.search()，re.compile()，re.split()，re.findall()，re.finditer()等等</p></blockquote><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile()"></a>re.compile()</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供其他函数使用。</p><p>实际上compile函数返回一个正则表达式对象，和一般的类对象实例化过程不同的是，正则表达式对象只能通过compile函数生成。</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h3><p>这个函数就可以通过类方法调用也可以通过正则表达式对象的实例方法调用。者方法会从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p><p>匹配成功后，<code>re.match</code>方法返回一个匹配的对象，可以使用匹配对象的<code>group()</code>方法 来获取匹配到的字符串，也可以使用<code>span()</code>方法获取到匹配对象的位置。</p><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h3><p>这个函数扫描整个字符串并返回第一个成功的匹配对象。</p><p>search和match的区别是：<code>re.match</code> 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 <code>re.search</code> 匹配整个字符串，直到找到一个匹配。</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall()"></a>re.findall()</h3><p>search和match只会找出一个匹配结果，而很多情况下，我们需要找到所有匹配的结果，这时候就需要用findall方法。</p><p>该方法找到正则表达式所匹配的所有子串，并返回一个字符串列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer()"></a>re.finditer()</h3><p>在字符串中找到正则表达式所匹配的所有子串，不过返回的是一个迭代器。</p><h3 id="re-split"><a href="#re-split" class="headerlink" title="re.split()"></a>re.split()</h3><p>split 方法按照能够匹配的子串将字符串分割后返回列表，可以代替字符串的<code>split</code>方法。</p><blockquote><p>Notice:</p><p>match(), search(), finditer()返回的都是匹配对象，匹配对象可以通过group方法和span方法获取到匹配的表达式和位置</p><p>findall()方法返回的是一个列表，里面只有匹配到的字符串。</p></blockquote><h2 id="正则原理与问题点"><a href="#正则原理与问题点" class="headerlink" title="正则原理与问题点"></a>正则原理与问题点</h2><p>实现正则表达式引擎的有两种方式：<strong>DFA 自动机</strong>（Deterministic Final Automata 确定型有穷自动机）和 <strong>NFA 自动机</strong>（Non deterministic Finite Automaton 不确定型有穷自动机）。</p><p>DFA 自动机的时间复杂度是线性的，更加稳定，但是功能有限。</p><p>而 NFA 的时间复杂度比较不稳定，有时候很好，有时候不怎么好，好不好取决于你写的正则表达式，但是 NFA 的功能更加强大。</p><p>Python中使用的是NFA。</p><p>NFA自动机消耗输入符号的字符串。对每个输入符号它变换到一个新状态直到所有输入符号到被耗尽。整个过程比较复杂，这里不赘述，需要注意的是自动机的<strong>回溯</strong>过程。</p><p><strong>匹配过程导致 CPU 使用率高</strong>的主要原因就是自动机的回溯过程。上文已经提到了正则匹配的贪婪模式，一般来说，贪婪匹配更容易发生回溯的问题。还有一种模式被称为<strong>独占模式</strong>，在表示次数的元素<code>*、？、+、&#123;m,n&#125;</code>后面加上<code>+</code>，匹配时会尽可能多的匹配，但是不回溯。如果写正则表达式的时候发现匹配时间久，CPU使用率长时间居高不下，可以试着分析是否是正则表达式写的有问题，导致的回溯过多。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习——SVM简述</title>
      <link href="/2020/11/11/svm-xiang-jie/"/>
      <url>/2020/11/11/svm-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>支持向量机（Support Vector Machine, SVM）是一种应用非常广泛的分类方法。其基本模型定义是特征空间上的间隔最大的线性分类器，即支持向量机的学习策略是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><p>简而言之，就是寻找到一个最佳的超平面（hiperplane），可以最完美地划分二类。SVM正是围绕着这一问题，构建的一个方法。</p><p>为了解决更加复杂的问题，支持向量机学习方法有一些由简至繁的模型:</p><ul><li>线性可分SVM</li></ul><blockquote><p>当训练数据线性可分时，通过硬间隔（hard margin，什么是硬、软间隔下面会讲）最大化可以学习得到一个线性分类器，即硬间隔SVM。</p></blockquote><ul><li>软间隔SVM</li></ul><blockquote><p>当训练数据不能线性可分但是可以近似线性可分时，通过软间隔（soft margin）最大化也可以学习到一个线性分类器，即软间隔SVM。</p></blockquote><ul><li>非线性SVM</li></ul><blockquote><p>当训练数据线性不可分时，通过使用核技巧（kernel trick）和软间隔最大化，可以学习到一个非线性SVM。</p></blockquote><h2 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h2><p>先看一个简单的例子：</p><p><img src="two.jpg" style="zoom:70%;" /></p><p>什么的图片中有2类点，一类用 “+” 表示，一类用 “-” 表示，每个点有2个特征$x_1, x_2$，现在我们想找到一个合适的直线（超平面的二维形式），正确的分开两类。可以看到，上述图片中的线段都能达到这一目的，那么哪一个直线是最优的呢？</p><p>直觉上红色的线是最优的。而其他的线，比如1号线旁边有一个黑色十字，如果黑十字旁边有一个新的稍微偏移一些的点，即蓝色十字的位置，那么1号线就会判断错误。所以看起来红色的线鲁棒性更强，不会因为一些数据的扰动而产生错误判断，这也是深度学习里面说的“泛化性”。</p><p>因为由于能将样本分开的超平面可能有很多, SVM 进一步希望找到离各样本都比较远的划分超平面，也就是上述红色的直线。</p><p>那么在SVM中，这个红色的线到底应该如何精确定义和求解呢？</p><h3 id="超平面与间隔"><a href="#超平面与间隔" class="headerlink" title="超平面与间隔"></a>超平面与间隔</h3><h4 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h4><p>给定一个有n个样本的数据集$D_n = (\boldsymbol x_1,y_1),(\boldsymbol x_2,y_2) \dots (\boldsymbol x_n,y_n)$，其中$\boldsymbol x_i=(x_1,x_2\dots x_d)$是一个含有d个元素的列向量, 即$\boldsymbol x_i \in R^d$；$y_i$即标签，是标量，$y_i \in {+1, -1}$，$y_i = +1$时表示属于正类别，$y_i = -1$时表示负样本。</p><p>SVM考虑基于训练集$D_n$在样本空间中找到一个划分超平面，将不同类别的样本分开。<strong>在支持向量机中, 我们用间隔 （margin） 刻画划分超平面与样本之间的距离。</strong></p><p>最优的超平面应该满足三点：</p><ol><li>该超平面可以分开2类；</li><li>该超平面具有最大化间隔；</li><li>该超平面位于间隔的中间，到所有支持向量距离相等。</li></ol><p>我们设最优的超平面$H$的公式为</p><script type="math/tex; mode=display">\boldsymbol w^T\boldsymbol x+b=0 \tag{1}</script><p>$\boldsymbol w = (w_1,w_2,\dots w_d)$为超平面的法向量，b为偏置。</p><p>样本空间中任意一点 $\boldsymbol x_i$<strong>到超平面H的距离</strong>为</p><script type="math/tex; mode=display">\frac{\boldsymbol w^T\boldsymbol x_i + b}{||\boldsymbol w||} \tag{2}</script><p>其中，$||\boldsymbol w|| = \sqrt{w_1^2+w_2^2+\dots w_d^2}$ ，是向量的欧几里德范数，也称为向量模、欧几里德长度或 2范数。</p><p>注：上面的向量模定义来自matlab向量范数和矩阵范数一节：</p><blockquote><p>欧几里德范数</p><p>具有 <code>N</code> 个元素的向量 <code>v</code> 的欧几里德范数（也称为向量模、欧几里德长度或 2-范数）的定义如下：</p><p>$||\boldsymbol v|| = \sqrt{\sum_{k=1}^N{|v_k|^2}}$</p></blockquote><h4 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h4><p><strong>间隔表示距离划分超平面最近的样本到划分超平面距离的两倍。</strong></p><p>那么，间隔为最近样本到超平面距离的两倍是怎么得来的呢？</p><p>因为最优超平面是位于支持向量中间，现在我们将这个超平面向上移动，直到接触到第一个正样本，此时超平面方程$C_1$为$\boldsymbol w^T \boldsymbol x+b=c,c&gt;0$。同样的，将超平面向下移动直到碰到第一个负样本，此时超平面方程$C_2$为$\boldsymbol w^T \boldsymbol x +b=-c$。</p><p>那么$C_1C_2$两个超平面的距离为$\frac{2c}{||\boldsymbol w||}$。</p><p>通过缩放$\boldsymbol w$和$b$，我们总是可以使得$c=1$并且不影响解，这样$C_1C_2$两个超平面的方程分别为$\boldsymbol w^T \boldsymbol x +b=1$和$\boldsymbol w^T \boldsymbol x+b=-1$，注意此时的$\boldsymbol w、b$为经过放缩之后的新向量。</p><p>此时上下两个超平面之间距离为$\frac{2}{||\boldsymbol w||}$，如下图所示。</p><p><img src="hp.jpg" style="zoom:67%;" /></p><p>也就是说，此时，<strong>我们用来划分不同类别的超平面$H$正好处于两类之间，且保证了到两类的最边缘的向量（支持向量）距离相等</strong>。</p><p>则对于任意样本点$\boldsymbol x_i$：</p><script type="math/tex; mode=display">\begin{cases}\boldsymbol w^T \boldsymbol x_i +b>=1,y_i=+1\\\boldsymbol w^T \boldsymbol x_i+b<=-1,y_i=-1\\\end{cases} \tag{3}</script><p>此时方程组（3）可以写成这样：</p><script type="math/tex; mode=display">对于\forall (\boldsymbol x_i,y_i),\quad y_i (\boldsymbol w^T \boldsymbol x_i+b) \geq1 \tag{4}</script><h4 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h4><p><strong>不等式（4）满足了最优超平面的条件1和条件3</strong>，只剩下条件2：最大化间隔。</p><p>所以最终我们得到了，线性支持向量机的优化问题等价于找到一组合适的参数$(\boldsymbol w,b)$, 使得</p><script type="math/tex; mode=display">\max\frac{2}{||\boldsymbol w||}\\s.t.\quad y_i (\boldsymbol w^T \boldsymbol x_i+b) \geq1  \tag{5}</script><p>这是一组带有约束的最优化问题，可以使用拉格朗日函数解决。因为拉格朗日函数需要用到导数并且$\max \frac{2}{||\boldsymbol w||} \Rightarrow \min ||\boldsymbol w|| \Rightarrow \min \frac{1}{2} \boldsymbol w^T\boldsymbol w$，所以我们把公式（5）改写成下式以方便求导计算：</p><script type="math/tex; mode=display">\min \ \frac{1}{2} \boldsymbol w^T\boldsymbol w\\s.t.\quad 1-y_i (\boldsymbol w^T \boldsymbol x_i+b) \leq 0, i=1,2,\dots ,n \tag{6}</script><p>上述公式（6）就是线性SVM的基本型，求解方法属于凸优化（convex optimization）中的二次规划问题。</p><blockquote><p>二次规划的定义：</p><ol><li><p>目标函数为二次项；</p></li><li><p>限制条件为一次项。</p></li></ol></blockquote><p>凸优化问题有唯一全局极值，所以这个问题要么无解要么有唯一解。</p><p>我们将公式（6）转化为拉格朗日函数：</p><script type="math/tex; mode=display">L(\boldsymbol w,b,\boldsymbol \alpha) = \frac{1}{2}\boldsymbol w^T \boldsymbol w + \sum_{i=1}^{n}\alpha_i(1-y_i (\boldsymbol w^T \boldsymbol x_i+b)) \tag{7}</script><p>其中，$\alpha_i = (a_1;a_2;\dots ;a_n;)$，拉格朗日乘子$\alpha_i \geq 0$。</p><h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>接下来要求解公式（7）的对偶问题，转换为对偶问题来求解的原因是:</p><ul><li>对偶问题更易求解，由下文知对偶问题只需优化一个变量$\alpha$且约束条件更简单；</li><li>能更加自然地引入核函数，进而推广到非线性问题。</li></ul><p>对公式（7）的拉格朗日函数，给定一个$\boldsymbol w$和b，对于满足约束条件（6）的样本$(\boldsymbol x_i,y_i)$：，由于</p><script type="math/tex; mode=display">\alpha_i\geq 0， 1-y_i (\boldsymbol w^T \boldsymbol x_i+b)\leq 0</script><p>即公式（7）的后一项为负数或者0，那么：</p><script type="math/tex; mode=display">\max \limits_{\alpha} L(\boldsymbol w,b,\boldsymbol \alpha) = \frac{1}{2}\boldsymbol w^T \boldsymbol w \tag{8}</script><p>而对于不满足约束条件的样本，由于公式（7）的后一项为正，且可以无限大，所以$\max \limits_{\alpha} L(\boldsymbol w,b,\boldsymbol \alpha) = +\infty $</p><p>可以看出，公式（8）实际上就是我们要最小化的值，即公式（6）等价于找出一组$(\boldsymbol w, b)$使得公式（8）最小。即：</p><script type="math/tex; mode=display">\min \limits_{\boldsymbol w,b} \ \max \limits_{\alpha}L(\boldsymbol w,b,\boldsymbol \alpha)</script><p>根据拉格朗日对偶性，可得到其<strong>对偶问题</strong>为：</p><script type="math/tex; mode=display">\max \limits_{\alpha} \ \min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha)</script><p>对偶问题的解即为先求$L(\boldsymbol w,b,\boldsymbol \alpha)$对$(\boldsymbol w,b)$的极小值，再求其对$\boldsymbol \alpha$的极大值。</p><p>（1）先求$L(\boldsymbol w,b,\boldsymbol \alpha)$对$(\boldsymbol w,b)$的极小值，即$\min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha)$：</p><p>我们对公式（7）进行求导，可得：</p><script type="math/tex; mode=display">\begin{cases} \frac{\partial L}{\partial \boldsymbol w}=0 \Rightarrow \boldsymbol w = \sum_{i=1}^{n} \alpha_i y_i \boldsymbol x_i \\\\\frac{\partial L}{\partial b}=0 \Rightarrow \sum_{i=1}^{n}\alpha_i y_i=0\end{cases} \tag{9}</script><p>将求导后的公式（9）带入公式（7），将$L(\boldsymbol w,b,\boldsymbol \alpha)$中的$(\boldsymbol w,b)$消掉，则：</p><script type="math/tex; mode=display">\min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha) = \sum_{i=1}^{n}\alpha_i - \frac{1}{2} \sum_{i=1}^{n}\sum_{j=1}^{n}\alpha_i\alpha_jy_iy_j \boldsymbol x_i^T \boldsymbol x_j</script><p>（2）对$\min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha)$求α的极大，即$\max \limits_{\alpha} \ \min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha)$：</p><script type="math/tex; mode=display">\max \limits_{\alpha} \ \min \limits_{\boldsymbol w,b} L(\boldsymbol w,b,\boldsymbol \alpha) = \max \limits_{\alpha} \quad \sum_{i=1}^{n}\alpha_i - \frac{1}{2} \sum_{i=1}^{n}\sum_{j=1}^{n}\alpha_i\alpha_jy_iy_j \boldsymbol x_i^T \boldsymbol x_j \\s.t. \quad \sum_{1}^{n}a_iy_i=0;\\ \alpha_i \geq0,i=1,2,\dots ,n. \tag{10}</script><p>以上，我们就得到了线性SVM的优化问题（6）和其对偶问题（10）。</p><p>$L(\boldsymbol w,b,\boldsymbol \alpha)$的对偶问题实际上是这样的：对于$L$，遍历定义域内的所有$\boldsymbol w$，找到使得$L$最小的一组$(\boldsymbol w,b)$，这样$L$就变成了一个关于$\boldsymbol \alpha$的函数，再求取这个函数关于$\boldsymbol \alpha$的极大值。</p><p>解出$\boldsymbol \alpha$后，求出 $\boldsymbol w$ 与b即可得到模型：</p><script type="math/tex; mode=display">f(x)=\boldsymbol w^Tx+b=∑_{i=1}^{m}α_iy_i\boldsymbol x_i^T\boldsymbol x+b \tag{11}</script><p>关于求解$\boldsymbol \alpha$的方法，可以采用二次规划的解法，也有一些其他算法比如SMO（Sequential Minimal Optimization）算法。</p><h3 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h3><p> KKT （Karush-Kuhn-Tucker）条件是指优化问题在最优值处必须满足如下条件：</p><ul><li>$主问题可行: g_i(u) ≤ 0, h_i(u) = 0; $</li><li>$对偶问题可行: \alpha_i ≥ 0; $</li><li><p>$互补松弛 (complementary slackness): \alpha_i g_i(u) = 0.$</p><p>公式（7）中的写法保证了满足线性支持向量机的 KKT 条件，如下：</p></li><li><p>$主问题可行: 1 − y_i(\boldsymbol w^Tx_i + b) ≤ 0;$</p></li><li>$对偶问题可行:\alpha_i ≥ 0;$</li><li>$互补松弛:\alpha_i(1 − y_i(\boldsymbol w^Tx_i + b)) = 0.$</li></ul><p>线性支持向量机中, 支持向量是距离划分超平面最近的样本, 落在最大间隔边界上。支持向量机的参数$(\boldsymbol w,b)$仅由支持向量决定, 与其他样本无关。</p><p>对于任意样本$(\boldsymbol x_i,y_i)$，总会有$\boldsymbol \alpha_i=0 $或者$y_i(\boldsymbol w^Tx_i + b)=1$或者。则若$\boldsymbol \alpha_i=0 $则该样本不是支持向量，对模型没有任何影响；若$\boldsymbol \alpha_i&gt;0 $，此样本点位于最大间隔边界上，是一个支持向量。</p><h2 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h2><p>再上面一节，我们假设训练样本是严格线性可分的即存在一个超平面能完全将两类数据分开。但是现实任务这个假设往往不成立。</p><p>这种问题的一个解决方法是适当地放松限制条件，允许少量的数据可以不满足$y_i (\boldsymbol w^T \boldsymbol x_i+b) &gt;=1$的约束条件，即允许少量样本被分错。放松约束条件的基本思路是对于每一个样本，设置一个松弛变量$\delta$。</p><p><img src="Non.jpg" style="zoom:50%;" /></p><p>那么约束条件变成：</p><script type="math/tex; mode=display">对于\forall (\boldsymbol x_i,y_i),\quad y_i (\boldsymbol w^T \boldsymbol x_i+b) \geq 1- \delta_i,(i=1\sim N) \tag{12}</script><p>只要$\delta_i$足够大，每一个样本都可以满足这个条件，所以我们还要加入新的限制条件，使得$\delta_i$不会变的太大。</p><p>则优化函数如下：</p><script type="math/tex; mode=display">\min \ \frac{1}{2} \boldsymbol w^T\boldsymbol w + C\sum_{i=1}^{n}\delta_i\\s.t.\quad y_i (\boldsymbol w^T \boldsymbol x_i+b) \geq 1- \delta_i, (i=1\sim n) \\\delta_i \geq 0, (i=1\sim n)\tag{13}</script><p>上述问题即为加入松弛因子之后的软间隔支持向量机，其中比例因子C为人为设定的值，被称为超参数。</p><p>由于需要满足KKT条件，我们把上式改写成如下：</p><script type="math/tex; mode=display">\min \ \frac{1}{2} \boldsymbol w^T\boldsymbol w - C\sum_{i=1}^{n}\delta_i\\s.t.\quad  1+ \delta_i - y_i (\boldsymbol w^T \boldsymbol x_i+b)\leq 0 , (i=1\sim n) \\\delta_i \leq 0, (i=1\sim n)\tag{14}</script><h3 id="对偶问题-1"><a href="#对偶问题-1" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>软间隔支持向量机依然是一个凸二次规划问题，和硬间隔支持向量机类似，通过拉格朗日乘子法将其转换为对偶问题进行求解。</p><p>公式（14）所对应的拉格朗日函数为：</p><script type="math/tex; mode=display">L(\boldsymbol w,b,\delta,\boldsymbol \alpha,\boldsymbol \beta) = \frac{1}{2}\boldsymbol w^T \boldsymbol w - C\sum_{i=1}^{n}\beta_i \delta_i + \sum_{i=1}^{n}\alpha_i(1+ \delta_i - y_i (\boldsymbol w^T \boldsymbol x_i+b)) \tag{7}</script><p>为了求得对偶问题的解，我们同样需要先求得$L(\boldsymbol w,b,\delta,\boldsymbol \alpha,\boldsymbol \beta)$对$\boldsymbol w,b,\delta,$的极小，再求对$\boldsymbol \alpha,\boldsymbol \beta$的极大。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历与启发式搜索</title>
      <link href="/2020/10/06/bian-li-yu-qi-fa-shi-sou-suo/"/>
      <url>/2020/10/06/bian-li-yu-qi-fa-shi-sou-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><p>常规的遍历算法主要包括DFS和BFS。这两个算法不需要知道终结点在哪里，它会按照一定的模式挨个搜索，直到找到终结点。</p><p>举个不恰当的例子，遍历算法相当于你蒙着眼睛站在球场上，球场有一个球，需要你找到球，因为不知道球在哪，只能挨个找完所有位置。而启发式搜索需要一个启发函数，相当于睁开了眼睛，就可以直奔着球去了。</p><p>关于搜索算法的python实现已经放在了GitHub上：<a href="https://github.com/skyfaker/search_algorithm">搜索求解算法</a></p><p>具体实现是用不同的搜索算法在网格地图上寻找终点。如A*算法的实现效果如下：</p><p><img src="https://z3.ax1x.com/2021/04/10/cU5Uoj.png" alt='A*算法示例' style="zoom:50%;" /></p><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先，顾名思义即深度越大的节点会被优先扩展。在DFS中，使用栈（Stack）来实现上述特性。栈的特性是先进后出、后进先出。DFS过程中，会遍历当前节点的所有邻接节点，将它们依次压入栈中，遍历结束后，取出栈中最后一个元素，也就是最后一个被访问的邻接节点，继续递归。</p><p>DFS为数据结构中的基础内容，这里不再细说，遍历过程可以看下图（标号为第几轮遍历，橘黄色为寻找的路径）：</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSZ7j.jpg" style="zoom:40%;" /></p><p>上图为DFS的遍历过程（按照左上右下遍历）与寻找到的路径。首先遍历起点的邻接节点，并标注为1（第一轮遍历），将下节点1（即栈尾）出栈，递归遍历，直到找到终点。</p><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>广度优先会遍历完同级的所有节点，再增加深度。BFS中，使用队列（Queue）实现。队列的特性是先进先出、后进后出。BFS过程中，会遍历当前节点的所有邻接节点，将它们依次放入队列中，一轮遍历结束后，取出队列中第一个一个元素，也就是第一个被访问的邻接节点。</p><p>所以每一次的遍历，会遍历同一层所有节点的邻接节点。直到同一层的所有节点都已经遍历，才会遍历下一层的节点。看起来就像是一圈一圈地向外扩展。</p><p>BFS遍历过程如下图（标号为第几轮遍历，橘黄色为寻找到的路径）：</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSmAs.jpg" style="zoom:40%;" /></p><p>上图为BFS的遍历过程与寻找到的路径。首先遍历起点的邻接节点，并标注为1（第一轮遍历），将左节点1（即队首）出队列，遍历左节点1，其相邻的节点标注为2，排入队列中，直到找到终点。而在从终点向起点的回溯过程中（按照左上右下回溯），可以找到最短路径。</p><p>可以看出，一般而言，DFS遍历的节点较少，在某些节点没有遍历的情况下已经达到了终点。不过，找到的路径并非是最优路径。而BFS的遍历次数较多，但是回溯的时候可以找到最短路径。</p><p>DFS就像是一个孤军深入的莽夫，速度很快，一直向前冲，撞到南墙就回到上一步换个方向。BFS则稳扎稳打，步步为营，走得虽然很慢，但是可以找到最短路径。</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>Dijkstra算法用来寻找图形中从一个顶点到其余各顶点的最短路径算法，一般用来解决两点之间（带权）最短路径问题。考虑这样一种场景，在一些情况下，图形中相邻节点之间的移动代价并不相等。</p><p>它既与BFS有相同之处，又与后面要介绍的贪婪最佳优先算法有一定相关性。</p><p>Dijkstra算法是这样运行的：把所有的点分成2类，一类称为S，指已经确定与起点之间最短路径的点集合，一类为U，指还没有确定与起点之间最短路径的点的集合。U中的点使用<strong>优先级队列</strong>表示，优先值为点到S的距离，如x到S的距离记作 $D_{S-x}$ 。之后每次从U中取一个距离最小的点，比如n点，加入到S中&lt;并更新n在U中的邻点x的值为$D_{S-x} = \min(D_{S-x}, D_{x-n}+D_{S-n})$。依次迭代，直到U为空。</p><p>下面举个例子，如下为带权路径图（a为起点，i为终点）：</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSEng.png" style="zoom:70%;" /></p><p>以上图为例，计算起点a到终点i的最短路径，箭头上的数值表示两个节点间的距离。</p><script type="math/tex; mode=display">起始状态： S = \{a:0\}, U = \{b:2, c: \infty,d: 9,e: 5,f: \infty,g: \infty,h:\infty ,i:\infty \} \quad (冒号后为该点与S的距离)</script><p>未与S中元素直接相连的点距离设置为正无穷。</p><p>第一轮选点，从优先队列U中选择值最小的b点放入S，并且更新b的邻点x的值为$\min(D_{S-x}, D_{x-b}+D_{S-b})$：</p><p>如邻点c，之前的$D_{S-c} = \infty$，在b加入S之后的$D_{S-c} = \min(\infty, 2+1) = 3$，故b点加入S集合之后的状态如下：</p><script type="math/tex; mode=display">第一轮： S = \{a:0, b:2\}, U = \{c: 3,d: 9,e: 5,f: \infty,g: \infty,h:\infty,i:\infty \}</script><p>第二轮选点，从优先队列U中选择c点放入S，并且更新c的邻点x的值：</p><script type="math/tex; mode=display">第二轮： S = \{a:0, b:2, c:3\}, U = \{d: 9,e: 4,f: \infty,g: 9,h:\infty,i:\infty \}</script><p>第三轮选点，从优先队列U中选择e点放入S，并且更新e的邻点x的值：</p><script type="math/tex; mode=display">第三轮： S = \{a:0, b:2, c:3, e:4  \}, U = \{d: 6,f: 13,g: 9,h:11,i:\infty \}</script><p>第四轮选点，从优先队列U中选择d点放入S，并且更新d的邻点的值：</p><script type="math/tex; mode=display">第四轮： S = \{a:0, b:2, c:3, e:4, d:6  \}, U = \{f: 13,g: 9,h:10,i:\infty \}</script><p>第五轮选点，从优先队列U中选择g点放入S，并且更新g的邻点的值:</p><script type="math/tex; mode=display">第五轮： S = \{a:0, b:2, c:3, e:4, d:6 ,g:9  \}, U = \{f: 13,h:10,i:14 \}</script><p>第六轮选点，从优先队列U中选择h点放入S，并且更新h的邻点的值:</p><script type="math/tex; mode=display">第六轮： S = \{a:0, b:2, c:3, e:4, d:6,g:9,h:10  \}, U = \{f: 11, i:14 \}</script><p>第七轮选点，从优先队列U中选择f点放入S，并且更新f的邻点的值:</p><script type="math/tex; mode=display">第七轮： S = \{a:0, b:2, c:3, e:4, d:6,g:9,h:10, f:11  \}, U = \{i:12 \}</script><script type="math/tex; mode=display">最终结果： S = \{a:0, b:2, c:3, e:4, d:6,g:9,h:10, f:11, i:12  \}, U = \{ \}</script><p>看上去，BFS与Dijkstra算法最显著的区别在于BFS使用了队列，而Dijkstra算法使用了优先级队列。实际上，使用不同的数据结构是为了各自取下一个点的方法而服务。</p><p>本质上，<strong>搜索算法和路径规划算法的目的都是如何正确地选取下一个节点</strong>。我们可以称评估如何选取下一个点的指标为<strong>代价函数$f(n)$</strong>，选取下一个点是要付出代价的，代价最小的点就是我们应该选取的点。</p><p>BFS算法之所以选择队列作为数据结构，是因为它每次选取的点为当前已经遍历的点的邻点，它的代价函数是当前点与起点的遍历轮数最小值。</p><p>Dijkstra算法之所以使用优先级队列，是因为它每次选取的点为从起点移动到当前点的最小值，也可以说是与已经遍历的点集合的距离最小的点。即它的代价函数是起点到当前点的移动代价。而当路径为无权时，移动代价就等于遍历轮数，即退化成了BFS。</p><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><p>BFS和DFS的区别主要在于节点的弹出策略，根据弹出策略的区别，分别使用了队列和栈两种数据结构，而栈和队列作为两种相当基本的容器，只将节点进入容器的顺序作为弹出节点的依据，并未考虑终点位置等因素，这就使搜索过程与终点位置无关，变得漫无目的，导致效率低下。Dijkstra算法虽然可以解决带权的路径问题，却同样没有利用到终点位置信息，它的代价函数只与起点有关。而启发式搜索借助了一个启发函数，需要提前知道终点的位置，优化代价函数与起点和终点都有关，这样可以更快达到终点。</p><h3 id="贪婪最佳优先算法"><a href="#贪婪最佳优先算法" class="headerlink" title="贪婪最佳优先算法"></a>贪婪最佳优先算法</h3><p>贪婪最佳优先算法（Greedy Best First Search, GBFS）的特点是评价函数=启发函数。</p><p>设评价函数为$f(n)$，启发函数为$h(n)$，那么令$f(n)=h(n)$。即从当前节点出发，寻找下一个邻接节点，邻接节点选择的依据（评价函数）为使得启发函数值最最小的节点。</p><p>之所以贪婪最佳优先算法的速度一般会比较快，是因为启发函数使用了当前点与终点的信息。</p><p>同样以寻找路径为例：</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSVBQ.jpg" alt='GBFS算法' style="zoom:40%;" /></p><p>上图为使用贪婪最佳优先算法寻找的路径（橙色标注），有数值的格子表示被遍历到的节点，数值表示该点与终点的欧氏距离，即启发函数$h(n)=$欧氏距离。</p><p>首先在起点处，计算邻点的$h(n)$，由于起点右侧的点距离小于其他邻点，即$h(n)$最小，又由于$f(n)=h(n)$，故该点的代价函数最小，因此选择该点作为下一个点。然后重复上述过程，直到达到终点。</p><p>可以看到，由于设置代价函数=启发函数，使得寻找过程中被遍历的点减少了，也就是说，这个算法可以直奔终点快速前进。</p><p>当然，这个算法也有不足之处：1.寻找的路径常常不是最优解，2.启发函数最小化这一目标对于错误的起点比较敏感，不同的起点对于路径寻找过程影响很大，甚至有可能进入死循环，3.最坏情况下复杂度很高为$O(b^m)$，b为节点分支因子数、m为搜索空间的最大深度。</p><p>实际的地图中，常常会有很多障碍物，因为代价函数只与启发函数有关，而启发函数只表示当前位置与终点的关系，所以GBFS就很容易陷入局部最优的陷阱。下图的地图中有一个专门设置的局部最优陷阱，很显然GBFS虽然搜索速度够快，但是找不到最优路径。</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSuhq.gif" alt="有障碍GBFS" style="zoom:33%;" /></p><p>针对这些不足之处，最重要的是需要设计一个良好的启发函数。</p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>英语不错的同学可以直接看一看这篇：<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to the A* Algorithm</a></p><p>GBFS用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高；而Dijkstra算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。</p><p>那么可不可以将两者的代价函数进行融合，从而<strong>在保证路径最优的同时提高搜索效率</strong>？答案是肯定的，融合后的算法就是<strong>A*算法</strong>。</p><p>A*算法的代价函数为$f(n) = g(n) + h(n)$，g(n)为起点到当前节点的移动代价，$h(n)$为启发函数，表示从当前点到终点的距离函数。</p><p>其中，若将$g(n)$置为0，则A*算法退化成贪婪最佳优先算法，若$h(n)=0$，则退化成Dijkstra算法。</p><p>能否找到最优路径的关键是启发函数$h(n)$的选取，如果$h(n)$始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当$h(n)$的值选取不合适，会导致算法将遍历越多的节点，也就导致算法越慢。<br>由于A* 算法的启发函数是位置上的距离，因此在不带位置信息的图数据中不适用。</p><p>A*算法描述如下：</p><figure class="shiki text"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">* 初始化open_set和close_set；</span></span><span class="line"><span style="color: #abb2bf">* 将起点加入open_set中，并设置优先级f(n)为0（优先级最高）；</span></span><span class="line"><span style="color: #abb2bf">* 如果open_set不为空，则从open_set中选取优先级最高的节点n：</span></span><span class="line"><span style="color: #abb2bf">    * 如果节点n为终点，则：</span></span><span class="line"><span style="color: #abb2bf">        * 从终点开始逐步追踪parent节点，一直达到起点；</span></span><span class="line"><span style="color: #abb2bf">        * 返回找到的结果路径，算法结束；</span></span><span class="line"><span style="color: #abb2bf">    * 如果节点n不是终点，则：</span></span><span class="line"><span style="color: #abb2bf">        * 将节点n从open_set中删除，并加入close_set中；</span></span><span class="line"><span style="color: #abb2bf">        * 遍历节点n所有的邻近节点：</span></span><span class="line"><span style="color: #abb2bf">        * 如果邻近节点m在open_set中，则：</span></span><span class="line"><span style="color: #abb2bf">                * 比较g(n)是否比原来更小，如果更小则更新其g(n)、优先级f(n)和其父节点</span></span><span class="line"><span style="color: #abb2bf">            * 如果邻近节点m在close_set中，则：</span></span><span class="line"><span style="color: #abb2bf">                * 跳过，选取下一个邻近节点</span></span><span class="line"><span style="color: #abb2bf">            * 如果邻近节点m不在open_set和close_set中，则：</span></span><span class="line"><span style="color: #abb2bf">                * 设置节点m的parent为节点n</span></span><span class="line"><span style="color: #abb2bf">                * 计算移动代价g(n)</span></span><span class="line"><span style="color: #abb2bf">                * 计算节点m的优先级f(n)</span></span><span class="line"><span style="color: #abb2bf">                * 将节点m加入open_set中</span></span></code></pre></div></div></figure><p>对于网格形式的图，有以下这些启发函数可以使用：</p><ul><li>如果图形中只允许朝上下左右四个方向移动，则可以使用曼哈顿距离（Manhattan distance）。</li></ul><script type="math/tex; mode=display">dx = abs(node.x - goal.x) \\dy = abs(node.y - goal.y) \\h(x) = dx + dy</script><ul><li><p>如果图形中允许朝八个方向移动，则可以使用对角距离。</p><script type="math/tex; mode=display">dx = abs(node.x - goal.x) \\dy = abs(node.y - goal.y) \\h(n) = dx + dy + (\sqrt{2} - 2) * min(dx, dy)</script></li><li><p>如果图形中允许朝任何方向移动，则可以使用欧几里得距离（Euclidean distance）。</p><script type="math/tex; mode=display">dx = abs(node.x - goal.x) \\dy = abs(node.y - goal.y) \\h(n) = \sqrt{dx^2 + dy^2}</script></li></ul><p><strong>最优遍历点：</strong></p><p>对于下图：</p><p><img src="https://z3.ax1x.com/2021/04/10/cU5NwQ.jpg" style="zoom:50%;" /></p><p>假设路径函数$g(n)$和启发函数$h(n)$都使用曼哈顿距离，且$f(n)=g(n)+h(n)$。</p><p>首先，对于B点和E点，当它们都在open_set时，应该选取哪一个点作为下一个路径点呢？E与B的代价函数f（n）相等，而直觉上应该选择B点，因为第一行第三列与E点是等价的，选择E点必然也可以选择它，而这样会大大增加遍历次数。B点的启发函数小于E，而路径函数大于E，为了使得B点可以优于E点，我们需要使得B点减少的启发函数代价要多于其增加的路径代价。</p><p>其次，对于A、B、C、D四点来说，$f(A)=f(B)=f(C)=f(D)$，并且四点的启发函数也相同，那么在这种情况下，当四个点都在open_set中时，又该如何选取呢？如果我们更倾向于选择B、C，那么需要使得它们的代价更小。</p><p>针对上述2点，我们可以改变路径函数，比如使用对角距离作为路径函数，则E、B/C、A/D的代价函数2+4、2.4+3、3+3（路径+启发函数），即可实现选取B/C作为更优点的目的。</p><p>或者，在不改变路径函数的情况下，在代价函数相同时，使用额外的约束条件。比如路径和启发函数都为曼哈顿距离，则E、B/C、A/D的代价函数相同，此时取其中到终点对角距离最小的点最为最优点即可选出B/C。</p><p><strong>最短路径：</strong></p><p>关于A*算法能否找到最短路径最重要的一点就是已经处于open_set的邻点的更新。也就是如果遍历到的邻点在open_set中，要比较现有路径和原路径哪一个更短，取更短的路径的上一个节点作为父节点。</p><p>以下举个例子：假设在A点处遍历到邻点B，且B没有加入open_set，则的B父节点设置为A。一段时间后，在C点处也遍历到了B，则比较$g(c)+D_{C-B}$和$g(A)+D_{A-B}$，若$g(c)+D_{C-B}$更小，则应该更新B的父节点为A。</p><p>关于GBFS和A*算法在路径寻找过程中的差别可以参看下图：</p><p><img src="https://z3.ax1x.com/2021/04/05/cQSnNn.jpg" style="zoom:50%;" /></p><p>上图为GFBS和A*算法正有障碍路径寻找过程中，每个节点的代价函数。可以看到，使用GBFS之后，路径上的节点的代价函数随着接近终点会逐渐减小，但是却无法找到最优路径。</p>]]></content>
      
      
      <categories>
          
          <category> 搜索算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启发式搜索 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法综述</title>
      <link href="/2020/10/02/sou-suo-suan-fa-zong-shu/"/>
      <url>/2020/10/02/sou-suo-suan-fa-zong-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><p>关于搜索算法的具体介绍见 <a href="https://skyfaker.cc/2020/10/06/bian-li-yu-qi-fa-shi-sou-suo/">遍历与启发式搜索</a>。</p><p>搜索算法的形式化描述：状态、动作、状态转移、路径、测试目标</p><p>启发式搜索（有信息搜索）</p><p>搜索过程中利用辅助信息，代表有贪婪最佳优先搜索和A*搜索。</p><p>以城市最短路径问题为例：可以利用的信息为城市之间的直线距离作为启发函数。</p><p>辅助信息、评价函数（如何寻找下一个节点）、启发函数（节点到目标节点的路径的最小代价值）</p><h4 id="贪婪最佳优先搜索"><a href="#贪婪最佳优先搜索" class="headerlink" title="贪婪最佳优先搜索"></a>贪婪最佳优先搜索</h4><p>(Greedy Best First Search, GBFS)：评价函数=启发函数</p><p>从当前节点出发，寻找下一个邻接节点，邻接节点选择的依据（评价函数）为使得启发函数值最最小的节点。</p><p>不足之处：1.不是最优解，2.启发函数最小化这一目标对于错误的起点比较敏感，有可能进入死循环（不完备）3.最坏情况下复杂度很高为$O(b^m)$，b为节点分支因子数、m为搜索空间的最大深度</p><p>需要设计一个良好的启发函数</p><h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><p>评价函数$f(n)=g(n)+h(n)$</p><p>g(n)为起始节点到当前节点n的开销代价，h(n)表示从节点n到目标节点路径所估算的开销代价值（启发函数）。</p><p>即评估函数=当前最小开销代价+后续最小开销代价</p><p><strong>要求：</strong></p><p>可容：需要启发函数&lt;=实际开销</p><p>一致性：$h(n)&lt;=c(n,n’) + h(n’)$，即n到目标的启发式距离不大于n到$n’$的距离加$n’$到目标的距离。</p><p>以直线距离作为启发函数h(n)，则一定是可容的和一致的。</p><p><strong>性质：</strong></p><p>A*算法中，如果$h(n)$是一致的，则如果$f(n)$是非递减的。</p><p>如果A*算法将节点n作为最小代价开销的路径中一个节点，则n一定是最优路径中的一个节点</p><h3 id="对抗搜索"><a href="#对抗搜索" class="headerlink" title="对抗搜索"></a>对抗搜索</h3><h4 id="最小最大搜索"><a href="#最小最大搜索" class="headerlink" title="最小最大搜索"></a>最小最大搜索</h4><p>时间复杂度为$O{(b^m)}$，m为游戏树的最大深度，b为每个节点存在的有效走法数</p><p>最小最大算法的最大弱点是它需要展开整个博弈树。对于有高分支因子的博弈（例如围棋或国际象棋），该算法将导致巨大的博弈树，使得计算无法进行。</p><h4 id="Alpha-Bata剪枝搜索"><a href="#Alpha-Bata剪枝搜索" class="headerlink" title="Alpha-Bata剪枝搜索"></a>Alpha-Bata剪枝搜索</h4><p>在极小极大算法中通过剪枝减少搜索的节点数。</p><p>α为max节点目前得到的最高收益，β为min节点可以给对手的最小收益 。</p><h3 id="蒙特卡洛搜索"><a href="#蒙特卡洛搜索" class="headerlink" title="蒙特卡洛搜索"></a>蒙特卡洛搜索</h3><p>蒙特卡洛树搜索</p><p>通过采样而不是穷举的方式实现</p><p>单一状态蒙特卡洛规划：多臂赌博机</p><p>上限置信区间策略</p><p>蒙特卡洛树搜索</p><h4 id="单一状态蒙特卡洛规划"><a href="#单一状态蒙特卡洛规划" class="headerlink" title="单一状态蒙特卡洛规划"></a>单一状态蒙特卡洛规划</h4><p>序列决策问题，再利用和探索之间保持平衡</p><p>利用：保证再过去决策中获取最佳回报</p><p>探索：未来能够获得更大的回报</p><h4 id="上限置信区间（UCB）"><a href="#上限置信区间（UCB）" class="headerlink" title="上限置信区间（UCB）"></a>上限置信区间（UCB）</h4><p>使$\overline{X_{i,T_i(t-1)}}$记录第i个赌博机（共k个）在过去t-1时刻内的平均奖励，选择具有最佳上限置信区间的赌博机：</p><script type="math/tex; mode=display">I_t = \max_{i\in \{1,\cdots,k\}}\{\overline{X_{i,T_i(t-1)}}+c_{t-1,T_i(t-1)} \}</script><p>其中$c_{t,s}$定义如下：</p><script type="math/tex; mode=display">c_{t,s} = \sqrt{\frac{2\ln t}{s}}</script><p>$T_i(t) = \sum_{s=1}^t if(I_s=i)$为从初始时刻到t时刻时，选择第i个赌博机的次数。</p><p>$I_t$中第一项表示不同赌博机过去的奖励均值，则为了最大化$I_t$，倾向于选取之前平均收益最大的赌博机，代表利用。第二项大小与该赌博机被选择的次数有关，次数越多，则$c_{t,s}$中的s越大，则$c_{t,s}$越小，更倾向于选择之前被选次数更少的赌博机，代表探索。</p><p>简化表示：</p><script type="math/tex; mode=display">UCB= \overline X_j + c\sqrt{\frac{2\ln n}{n_j}}</script><p>$\overline X_j$为第j个赌博机过去获得的奖励的均值，$n_j$为第j个赌博机被选择的次数，c为平衡因子。</p><p>首先把所有的赌博机选择一次，从第二次选择开始，每次从1一直遍历到k个赌博机，选取其中能够使UCB1（UCB最大）的一个j。</p><h4 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h4><p>将UCB应用于游戏树的搜索方式，包括选择、扩展、模拟、反向传播四个步骤。每个节点有2个值，代表选择这个节点的胜利次数和模拟的总次数。</p><p><strong>选择：</strong></p><p>从根节点向下递归选择，一直到一个叶子节点。选择方式为用UCB选择最优潜力的后续节点</p><p>节点分成三类：</p><p>未访问：节点没有被遍历过</p><p>为完全展开：节点访问过，而子节点没有被全部访问过</p><p>完全展开：所有子节点都被访问过</p><p><strong>扩展：</strong></p><p>将选择的叶子节点添加一个为（0，0）的叶子节点。然后开始模拟。</p><p><strong>模拟：</strong></p><p>随机走一个棋子，直到分出胜负。</p><p><strong>反向传播:</strong></p><p>从子节点，沿着刚才向下的路径返回去，沿途更新每个祖先节点的状态。</p><p>整个过程包括2种策略学习方法：</p><p>搜索树策略：从已有的搜索树选择或者创建一个叶子节点（选择和扩展步骤）</p><p>模拟策略：从扩展出的节点出发，模拟游戏，得到游戏最终胜负结果。</p><p>搜索过程为：首先至少模拟一次，得出部分节点状态，然后从根节点出发，基于上次的节点状态，选择子节点，当不存在子节点时，创建出一个状态为（0，0）的子节点，开始模拟，模拟的结果回溯更新祖先节点。</p><p><img src="MCTS.png" style="zoom:33%;" /></p><p>假设以<strong>黑棋</strong>的角度，以上述的搜索树为例，则第一行表示黑棋选择，第二行表示白棋选择，依次交替。每个节点有2个状态（A/B），A表示选择该节点黑棋胜利次数或者白棋失败次数，B表示选择该节点的总次数。已经模拟了21次，第22次时从根节点出发。比如根节点（12/21）表示总共模拟了21次，黑棋胜利12次。第一行第一个节点表示，该节点被走过10次，其中黑棋7次胜利。</p><p>当第22次时，根节点处，黑棋开始选择，黑棋有三个子节点，分别为7/10，5/8，0/3。使用UCB1公式(平衡因子c=$\frac{\sqrt{2}}{2}$)计算分别为：</p><script type="math/tex; mode=display">7/10：\frac{7}{10}+\sqrt{\frac{\ln 21}{10}} = 1.252 \\5/8：\frac{5}{8}+\sqrt{\frac{\ln 21}{8}} = 1.243 \\0/3：\frac{0}{3}+\sqrt{\frac{\ln 21}{3}} = 1.007</script><p>因此，从根节点，选择7/10这个子节点。接下来，白棋从7/10开始选择子节点。由于状态A/B中第一项A为白棋失败次数，计算时应该使用1-A。</p><script type="math/tex; mode=display">2/4:1-\frac{2}{4}+\sqrt{\frac{\ln 21}{4}} = 1.372 \\5/6:1-\frac{5}{6}+\sqrt{\frac{\ln 21}{6}} = 0.879</script><p>因此，白棋选择2/4节点。接下来黑棋选择1/1节点，此时到达了叶子节点，需要进行扩展。</p><p>扩展的新节点被置为0/0，然后以此节点开始模拟。假设经过一系列的仿真，最终白棋获胜，则将扩展节点置为0/1，并且沿着选择路径回溯到根节点，沿途所有祖先节点的A值不变，B值加一。</p>]]></content>
      
      
      <categories>
          
          <category> 搜索算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索求解 </tag>
            
            <tag> 启发式搜索 </tag>
            
            <tag> 蒙特卡洛树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mathjax渲染异常与hexo prism高亮无效bug</title>
      <link href="/2020/08/20/hexo-dai-ma-gao-liang-yu-mathjax-chong-tu/"/>
      <url>/2020/08/20/hexo-dai-ma-gao-liang-yu-mathjax-chong-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="Prism高亮"><a href="#Prism高亮" class="headerlink" title="Prism高亮"></a>Prism高亮</h2><p>在安装设置完hexo之后，写代码的时候发现hexo默认自带的代码高亮工具highlight.js不太好用。便安装了Prism代码高亮插件。</p><p><a href="https://github.com/ele828/hexo-prism-plugin">Prism高亮插件GitHub仓库地址</a></p><p>安装方式：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">npm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-S</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">hexo-prism-plugin</span></span></code></pre></div></div></figure><p>安装完成之后需要关掉hexo自带的高亮，并配置prism。</p><p><img src="https://z3.ax1x.com/2021/03/23/6HG5ZQ.jpg" style="zoom:38%;" /></p><h2 id="mathjax显示"><a href="#mathjax显示" class="headerlink" title="mathjax显示"></a>mathjax显示</h2><p>使用markdown编辑mathjax公式，markdown显示正常，部署到hexo中显示异常。</p><p>这个数学公式问题，主要是Hexo的Markdown解析器与MathJax有冲突引起的。</p><p>Markdwon本身的特殊符号与Latex中的符号出现冲突的时候，比如:</p><ul><li><code>_</code>的转义，在markdown中，<code>_</code>是斜体，但是在latex中，却有下标的意思，这样你在公式里面写下标会被解析为斜体。</li><li><code>\\</code>的换行，在markdown中，<code>\\</code>会被转义为<code>\</code>这样也会影响影响mathjax对公式中的<code>\\</code>进行渲染。</li></ul><p>hexo默认使用<code>marked.js</code>去解析我们写的markdown，比如一些符号，<code>_</code>代表斜体，会被处理为<code>&lt;em&gt;</code>标签，比如<code>x_i</code>在开始被渲染的时候，处理为<code>x&lt;em&gt;i&lt;/em&gt;</code>，这个时候mathjax就无法渲染成下标了。很多符号都有这个问题，比如粗体<code>*</code>,也是无法在mathjax渲染出来的，好在有替代的乘法等,包括<code>\\</code>同理。 所以说到底，是hexo使用的markdown引擎的锅，因为很多其它引擎在这方面处理的很好。</p><p>不仅仅是公式的问题，在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&lt;</code> 和 <code>&amp;</code>。</p><p>比如说<code>&lt;code&gt;</code>，&lt;代码&gt;在尖括号里面的字母code会被当做HTML。</p><p>如下图：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HG6PI.jpg" alt = '尖括号字母被隐藏' style="zoom:38%;" /></p><p>上图是我在markdown中打出来的内容，而页面显示的部分却少了一块。</p><p>原因在于尖括号之间的内容会被解析为HTML元素，并且后面的内容样式会改变。我遇到过c++代码中的部分内容消失了，就是因为这部分代码被包在了尖括号中，最简单的方法是输入尖括号之后加一个空格，如：&lt; code&gt;</p><p>那么如何避免mathjax公式的显示异常问题呢？</p><h3 id="1-手动转义（最简单）"><a href="#1-手动转义（最简单）" class="headerlink" title="1. 手动转义（最简单）"></a>1. 手动转义（最简单）</h3><p>这个方法最直接，多写一个转义。比如需要在公式中写下标符号，那就修改写法写为: <code>x\_i</code>，需要换行就使用<code>\\\\</code>,即可，需要写<code>&lt;</code>的地方多加一个空格。</p><p> 如果你不需要迁移到其他平台的话可以这样做，最简单。而且用<code>\\\\</code>换行到其他平台也影响不大，只是由一个换行变成了两个换行。</p><h3 id="2-代码块保护"><a href="#2-代码块保护" class="headerlink" title="2.代码块保护"></a>2.代码块保护</h3><p>markdown解析的时候是不会解析两个 <strong>`</strong> 之间内容的，某些情况下可以使用这种方法，但是需要注意的是mathjax仍然会解析里面的公式。</p><h3 id="3-手动修改渲染引擎源码（失败）"><a href="#3-手动修改渲染引擎源码（失败）" class="headerlink" title="3.手动修改渲染引擎源码（失败）"></a>3.手动修改渲染引擎源码（失败）</h3><p>hexo默认的渲染引擎为<a href="https://github.com/hexojs/hexo-renderer-marked"> hexo-renderer-marked</a>，源码文件地址: <code>nodes_modules/marked/lib/marked.js</code>:</p><p>修改渲染引擎源码主要有两个目的：</p><ul><li>去掉<code>\\</code>的额外转义，这样<code>\\</code>就可以实现换行，就不会影响mathjax公式的换行显示了；</li><li>将em标签对应的符号中，去掉<code>_</code>,因为markdown中有<code>*</code>可以表示斜体，<code>—</code>去掉了就不会影响mathjax的下标显示了。</li></ul><p>根据网上的教程，打开<code>nodes_modules/marked/lib/marked.js</code></p><p>找到<code>escape</code>那一行</p><figure class="shiki js"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">escape</span><span style="color: #ABB2BF">:</span><span style="color: #E06C75"> /</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\\</span><span style="color: #E06C75">(</span><span style="color: #D19A66">[!&quot;#$%&amp;&#39;()*+,\-./:;&lt;=&gt;?@</span><span style="color: #56B6C2">\[\]\\</span><span style="color: #D19A66">^_`{|}~]</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">替换成</span></span><span class="line"><span style="color: #E06C75">escape</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">/</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\\</span><span style="color: #E06C75">(</span><span style="color: #D19A66">[`*{}</span><span style="color: #56B6C2">\[\]</span><span style="color: #D19A66">()# +\-.!_&gt;]</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span></code></pre></div></div></figure><p>找到em的那一行:</p><figure class="shiki js"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">em</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">/</span><span style="color: #C678DD">^\b</span><span style="color: #E06C75">_((?:</span><span style="color: #D19A66">[</span><span style="color: #ABB2BF">^</span><span style="color: #D19A66">_]</span><span style="color: #ABB2BF">|</span><span style="color: #E06C75">__)</span><span style="color: #D19A66">+?</span><span style="color: #E06C75">)_</span><span style="color: #C678DD">\b</span><span style="color: #ABB2BF">|</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">((?:</span><span style="color: #56B6C2">\*\*</span><span style="color: #ABB2BF">|</span><span style="color: #D19A66">[</span><span style="color: #E06C75">\s\S</span><span style="color: #D19A66">]</span><span style="color: #E06C75">)</span><span style="color: #D19A66">+?</span><span style="color: #E06C75">)</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">(?!</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">替换成</span></span><span class="line"><span style="color: #E06C75">em</span><span style="color: #ABB2BF">:</span><span style="color: #E06C75">/</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">((?:</span><span style="color: #56B6C2">\*\*</span><span style="color: #ABB2BF">|</span><span style="color: #D19A66">[</span><span style="color: #E06C75">\s\S</span><span style="color: #D19A66">]</span><span style="color: #E06C75">)</span><span style="color: #D19A66">+?</span><span style="color: #E06C75">)</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">(?!</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span></code></pre></div></div></figure><p><strong>PS：</strong></p><p>可能由于marked插件的版本不同，我的<code>escape</code>那一行和网上的不太一样</p><p><img src="https://z3.ax1x.com/2021/03/23/6HGcGt.jpg" style="zoom:38%;" /></p><p>并且更改之后也没有效果，<code>\\</code>仍然不能实现换行。</p><h3 id="4-更换模板引擎（可用）"><a href="#4-更换模板引擎（可用）" class="headerlink" title="4.更换模板引擎（可用）"></a>4.更换模板引擎（可用）</h3><p>以下是替代原始解析器的两个模板引擎：</p><ul><li><a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>，很强大的解析器，Pandoc的语法完全没有上述问题, 但是安装比较麻烦。</li><li><a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>，安装方便，修改了marked中一部分bug，但还是有部分问题。</li></ul><p>以安装kramed为例：</p><h4 id="安装kramed"><a href="#安装kramed" class="headerlink" title="安装kramed"></a>安装kramed</h4><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">npm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">uninstall</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">hexo-renderer-marked</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--save</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">//</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">卸载marked</span></span><span class="line"><span style="color: #61AFEF">npm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">hexo-renderer-kramed</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--save</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">//</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">安装kramed</span></span></code></pre></div></div></figure><p>kramed对于<code>block</code>形式的公式可以正确渲染，但是对于内联公式<code>inline</code>仍然有问题。所以我们仍然需要修改其转义部分的源码。</p><h4 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h4><p>打开<code>/node_modules\kramed\lib\rules\inline.js</code><br>更改后为：</p><figure class="shiki js"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">escape</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">/</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\\</span><span style="color: #E06C75">(</span><span style="color: #D19A66">[`*</span><span style="color: #56B6C2">\[\]</span><span style="color: #D19A66">()#$+\-.!_&gt;]</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span></code></pre></div></div></figure><figure class="shiki js"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">em</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">/</span><span style="color: #C678DD">^</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">((?:</span><span style="color: #56B6C2">\*\*</span><span style="color: #ABB2BF">|</span><span style="color: #D19A66">[</span><span style="color: #E06C75">\s\S</span><span style="color: #D19A66">]</span><span style="color: #E06C75">)</span><span style="color: #D19A66">+?</span><span style="color: #E06C75">)</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">(?!</span><span style="color: #56B6C2">\*</span><span style="color: #E06C75">)/</span><span style="color: #ABB2BF">,</span></span></code></pre></div></div></figure><p><img src="https://z3.ax1x.com/2021/03/23/6HGhqg.jpg" style="zoom:30%;" /></p><p>我们输入以下图片中的公式，发现可以正常显示：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HGfsS.jpg" alt='公式代码' style="zoom:38%;" /></p><p>显示效果：</p><p>$ a_0\b_{12} $</p><script type="math/tex; mode=display">a_0\\b_{12}</script><p>总结：</p><p>1.如果想正确显示公式，又不想太折腾，那么在输入公式的时候，用<code>\_</code>代替<code>_</code>，用<code>\\\\</code>代替<code>\\</code>，缺点是markdown文件放到其他平台时，渲染方式不兼容。</p><p>2.愿意折腾以下又追求完美的，可以更换渲染引擎，如pandoc和kramed。pandoc安装比较麻烦，但是听说很好用。kramed安装简单，但是内联公式显示仍然有问题，需要修改源码中的转义方式。并且kramed可能和hexo的其他插件发生冲突，比如上面安装的代码高亮插件Prism。</p><h2 id="prism与kramed冲突"><a href="#prism与kramed冲突" class="headerlink" title="prism与kramed冲突"></a>prism与kramed冲突</h2><p>安装配置完kramed之后，mathjax公式显示正常了，但是这时候又发现了一个新的问题：</p><p>prism代码高亮失效了：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HG2xf.jpg" style="zoom:30%;" /></p><p>并且我们看到右上角的语言名前面多了一个<code>Lang-</code>。</p><p>直觉告诉我，无法高亮与右上角的变化有关。</p><p>首先，markdown中代码块是以</p><p><img src="https://z3.ax1x.com/2021/03/23/6HGsIA.jpg" style="zoom:38%;" /></p><p>格式写出来的。</p><p>通过查看网页元素，发现这些被固定格式包起来的代码，被渲染完成之后是以 <code>&lt; pre &gt;&lt; code &gt;your code&lt; /code &gt; &lt; /pre &gt;</code>的元素形式存在的</p><p><img src="https://z3.ax1x.com/2021/03/23/6HGWM8.jpg" alt='代码在页面中的元素' style="zoom:38%;" /></p><p>hexo中的主题中存在对应的CSS文件，用来渲染这些元素。</p><p>由于kramed渲染引擎会自动修改代码元素的<code>class name</code>，所以导致prism插件找不到对应元素，也就无法自动高亮代码块中的代码。</p><p>解决方法：</p><p>打开<code>\node_modules\kramed\lib\renderer.js</code></p><p><img src="https://z3.ax1x.com/2021/03/23/6HGIaj.jpg" style="zoom:40%;" /></p><figure class="shiki js"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">langPrefix</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">&#39;lang-&#39;</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #E06C75">改为</span></span><span class="line"><span style="color: #E06C75">langPrefix</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">&#39;&#39;</span><span style="color: #ABB2BF">,</span></span></code></pre></div></div></figure><p>即可防止kramed自动修改元素的<code>class name</code>。</p><p>最终prism又恢复了正常，效果如下：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HGgRP.jpg" style="zoom:38%;" /></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mathjax </tag>
            
            <tag> hexo渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNet--准确与速度的均衡</title>
      <link href="/2020/07/27/mobilenet/"/>
      <url>/2020/07/27/mobilenet/</url>
      
        <content type="html"><![CDATA[<p>卷积神经网络（CNN）在计算机视觉领域产生了许多新进展也衍生出了许多新型的网络，其中MobileNet就是CNN在轻量级网络的一个非常优秀的网络架构探索。近些年，为了追求分类准确度，模型深度越来越深，模型复杂度也越来越高，如深度残差网络（ResNet）其层数已经多达152层。</p><p>在某些应用场景如移动或者边缘嵌入式设备，大而复杂的模型是难以被应用的。模型过于庞大，面临着内存不足的问题，其次这些场景要求低延迟，或者说响应速度要快。所以，研究小而高效的CNN模型在这些场景至关重要，也是目前的一个主流方向。</p><p>目前的研究总结来看分为两个方向：一是对训练好的复杂模型进行压缩得到小模型；二是直接设计小模型并进行训练。不管如何，其目标在保持模型性能（accuracy）的前提下降低模型大小（parameters size），同时提升模型速度（speed, low latency）。本文的主角MobileNet属于后者，其是Google最近提出的一种小巧而高效的CNN模型，其在accuracy和latency之间做了一个balance。</p><p><a href="https://arxiv.org/abs/1704.04861">MobileNet论文地址</a>。</p><h2 id="Depthwise-separable-convolution"><a href="#Depthwise-separable-convolution" class="headerlink" title="Depthwise separable convolution"></a>Depthwise separable convolution</h2><p>MobileNet的基本单元是深度级可分离卷积（depthwise separable convolution），它是一种可分解卷积操作，把常规的卷积过程分解为两个更小的操作：<strong>深度卷积（depthwise \ convolution）</strong>和<strong>逐点卷积（pointwise \ convolution）</strong>，以减少计算量。</p><p>Depthwise convolution和标准卷积不同，对于标准卷积其卷积核是用在所有的输入通道上（input channels），而depthwise convolution针对每个输入通道采用不同的卷积核，就是说一个卷积核对应一个输入通道，所以说depthwise convolution是depth级别的操作。而pointwise convolution其实就是普通的卷积，只不过其采用的是1x1的卷积核。</p><h3 id="分离卷积过程"><a href="#分离卷积过程" class="headerlink" title="分离卷积过程"></a>分离卷积过程</h3><p>下图分别为depthwise和pointwise的卷积过程：</p><p><img src="https://z3.ax1x.com/2021/03/30/cizYxf.jpg" alt="分离卷积" style="zoom:100%;" /></p><p>左边为depthwise卷积过程，绿、红、黄分别为三个不同的 $3\times 3 \times 1$的卷积核，每个卷积核分别与输入特征图对应的某一个通道做卷积运算，以此得到了一个通道数不变的新特征图。</p><p>右边为pointwise卷积过程，它以depthwise卷积的输出作为输入，以N个 $1*1$的卷积核做运算，得到一个新的通道数为N的特征图。</p><p>更加全面的过程可以看下面的流程图，注意图中<strong>箭头的指向</strong>：</p><p><img src="https://z3.ax1x.com/2021/03/30/cizlad.png" alt="分离卷积全流程图" style="zoom:50%;" /></p><h3 id="计算量比较"><a href="#计算量比较" class="headerlink" title="计算量比较"></a>计算量比较</h3><p><img src="https://z3.ax1x.com/2021/03/30/ciz1IA.png" alt='卷积核的区别' style="zoom:50%;" /></p><h4 id="常规卷积"><a href="#常规卷积" class="headerlink" title="常规卷积"></a>常规卷积</h4><p>如上图（a），假设这一层的输入特征图维度为 $D_f \times D_f \times M (D_f为输入特征图宽高，M为通道数)$，假设卷积时使用边缘填充，则输出的宽高不变，该层输出为 $D_f \times D_f \times N(N为输出通道数)$，则对于卷积过程，需要N个维度为 $D_k \times D_k \times M (M为卷积核通道数)$的卷积核。</p><p>即卷积核的通道数必须等于输入特征图的通道数，而卷积核的个数是输出特征图的通道数。</p><p>因此，每一个卷积核包含的参数个数为 $D_k \times D_k \times M$个，此次运算所有卷积核参数为$D_k \times D_k \times M \times N $。</p><p>现在我们得到了卷积核和输入输出特征图的维度，那么可以计算出在卷积过程中进行的乘加运算次数（粗略计算）：</p><script type="math/tex; mode=display">D_k \times D_k \times D_f \times D_f \times M \times N \tag{1}</script><p>其中 $D_k \times D_k \times D_f \times D_f$为一个卷积核在输入特征图的某一个通道进行的运算次数。</p><h4 id="分离卷积"><a href="#分离卷积" class="headerlink" title="分离卷积"></a>分离卷积</h4><p>如上图（b），这一层的输入、输出特征图维度均与常规卷积相同。那么卷积过程分为2步：1.depthwise convolution，2.pointwise convolution。</p><h5 id="depthwise-convolution"><a href="#depthwise-convolution" class="headerlink" title="depthwise convolution"></a>depthwise convolution</h5><p>对于depthwise convolution的过程，首先需要M个维度为 $D_k \times D_k \times 1$的卷积核。这些卷积核的通道数为1，因此只负责某一层的卷积运算，这也是为什么需要M个卷积核，因为输入特征图的每一个通道需要一个不同的卷积核。</p><p>在这一部分中，所有的M个卷积核，参数总个数为$D_k \times D_k \times 1 \times M$。</p><p>乘加运算次数为：</p><script type="math/tex; mode=display">D_k \times D_k \times D_f \times D_f \times M \tag{2}</script><h5 id="pointwise-convolution"><a href="#pointwise-convolution" class="headerlink" title="pointwise convolution"></a>pointwise convolution</h5><p>如上图（c）,该卷积运算的过程与常规运算基本一致，差别在于pointwise convolution为N个 $1 \times 1 \times M$的卷积核。</p><p>这一部分中，参数个数为 $1 \times 1 \times M \times N$。</p><p>运算次数为：</p><script type="math/tex; mode=display">1 \times 1 \times D_f \times D_f \times M \times N \tag{3}</script><p>分离卷积的总参数量为 $D_k \times D_k \times M + M \times N$。</p><p>总计算量为 式（2）+ 式（3）：</p><script type="math/tex; mode=display">D_k \times D_k \times D_f \times D_f \times M + D_f \times D_f \times M \times N \tag{4}</script><h4 id="参数量与计算量比较"><a href="#参数量与计算量比较" class="headerlink" title="参数量与计算量比较"></a>参数量与计算量比较</h4><p>因此，我们可以得出，相同输入和输出的分离卷积过程和常规卷积过程，参数量的比值为：</p><script type="math/tex; mode=display">\frac{Depthwise \ separable \ convolution}{Standard \  convolution} = \frac{D_k \times D_k \times M + M \times N}{D_k \times D_k \times M \times N } \\= \frac{D_k \times D_k + N}{D_k \times D_k \times N} \\= \frac{1}{N} + \frac{1}{D_k^2} \tag{参数量之比}</script><p>由于一般卷积神经网络中，卷积核大小为$3*3$，而卷积核个数为256、512或1024等，因此分离卷积的参数量大约为正常卷积的$\frac{1}{9}$。</p><p> 由 式（1）和 式（4）可知，计算量的比值为：</p><script type="math/tex; mode=display">\frac{Depthwise \ separable \ convolution}{Standard \  convolution} = \frac{D_k \times D_k \times D_f \times D_f \times M + D_f \times D_f \times M \times N}{D_k \times D_k \times D_f \times D_f \times M \times N}  \\= \frac{1}{N} + \frac{1}{D_k^2} \tag{计算量之比}</script><p>与参数量的比值一致，因此分离卷积的计算量也大约为正常卷积的$\frac{1}{9}$。    </p><p><strong>PS：这里的乘加运算量为近似值，非准确计算。</strong></p><p><img src="https://z3.ax1x.com/2021/03/30/ciz8PI.jpg" alt='使用正常卷积和深度可分离卷积的MobileNet（单位：百万）' style="zoom:30%;" /></p><p>上图为同样的MobileNet网络结构，使用正常卷积和深度可分离卷积的模型，在参数量和运算量上的比较，因为最后使用了全连接神经层，所以之间的比值要大于$\frac{1}{9}$。但是仍然可以看出，使用了深度可分离卷积之后，计算量的差距达到了一个数量级，而在ImageNet数据集上性能差距仅大约为1%。</p><p>之所以分离卷积可以大幅度减少计算量，实际上是因为分离卷积相比于正常的卷积方式，大大减少了特征提取的次数。常规卷积每个卷积核会对所有通道做特征提取，而depthwise卷积只会对每个通道做一次特征提取，之后的pointwise只是对提取的特征进行复用。也因此，网络的特征提取能力会较差一些。</p><p>除了减少计算量，另一方面，分离卷积增加了网络的深度，也就增加了添加非线性激活函数的次数。 在depthwise卷积和pointwise卷积之后，可以分别应用一个非线性激活层，既增加了非线性层的数量而又不显著增加参数和计算量。无论是ReLU，Softmax还是其他，激活层都是非线性的，这与卷积层不同。 “线的线性组合仍然是线”，而非线性层扩展了模型的可能性，所以“深层”网络比“宽层”网络更好。 </p><p>因此，可以说，可分离卷积是通过减少单次卷积运算的特征提取能力，换取了更少的计算次数和更强的非线性拟合能力。</p><p>当然，仅仅以 FLOPs 计算量来表现网络的运行速度是不准确的，除非是同一种网络架构。确保这些运算能够有效实施也很重要。例如非结构化稀疏矩阵运算（unstructured sparse matrix operations）通常并不会比密集矩阵运算（dense matrix operations）快，除非是非常高的稀疏度。</p><p>这里需要注意的是，depthwise卷积的FLOPs更少，但是在相同的FLOPs条件下，depthwise卷积需要的IO读取次数比普通卷积要多得多。因此，由于depthwise卷积的小尺寸，相同的显存下，我们设置更大的batch来让GPU跑满，但是此时速度的瓶颈已经从计算瓶颈变成了GPU的IO瓶颈。</p><p>如果计算设备的IO带宽足够大，而浮点运算能力不高的情况下，典型的如CPU，使用depthwise卷积会有更大的收益。反之，即使浮点运算很快，但是受制于带宽速度，depthwise的运算速度不一定会比常规的卷积运算要快。</p><h4 id="网络各部分比较"><a href="#网络各部分比较" class="headerlink" title="网络各部分比较"></a>网络各部分比较</h4><p>从上面的公式可以看出，大部分计算量与参数量都集中在pointwise卷积过程中，如果没有pointwise过程，则计算量可以降低到大约$\frac{1}{N}$。</p><p><img src="https://z3.ax1x.com/2021/03/30/cizNM8.png" alt="MobileNet各部分比较" style="zoom:50%;" /></p><p>上表为Mobile net网络中所有不同部分的计算量和参数量比较。也可以看出，$1 \times 1$的卷积集中了整个网络接近95%的计算量和75%的参数量。</p><p>那么，为什么有了depthwise卷积之后还要加上耗费巨大计算量的pointwise卷积过程呢？</p><p>第一点，很明显，pointwise卷积可以用来改变输出的特征图的通道数。如果只有depthwise过程的话，输出只能和输入的通道数保持一致，无法改变。</p><p>第二点，个人看法。每一个卷积核代表了一种特征提取方式，但是有些提取出的特征需要进行组合才有意义。比如说一个卷积核用于x轴边缘检测，另一个卷积核用于y轴边缘检测，两个特征图组合在一起才是一个完整的边缘检测过程。所以需要pointwise过程，将各个通道的特征进行复用与融合，形成新的特征。有一种网络结构shuffleNet在group convolution之后使用channel shuffle打乱了通道顺序，也是一种对特征图通道进行操作的方式。</p><p>MobileNet 模型结构将几乎所有计算都放入密集的 1×1 卷积中（dense 1 × 1 convolutions），卷积计算可以通过高度优化的通用矩阵乘法（<code>GEMM</code>，最优化的数值线性代数算法之一）函数来实现。 卷积通常由 <code>GEMM</code> 实现，但需要在内存中进行名为 <code>im2col</code> 的初始重新排序，然后才映射到 <code>GEMM</code>。而 $1×1$ 卷积不需要在内存中进行重新排序，可以直接使用 <code>GEMM</code>来实现。</p><h2 id="Mobile-net"><a href="#Mobile-net" class="headerlink" title="Mobile net"></a>Mobile net</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>depthwise separable convolution，是MobileNet的基本组件，在真正应用中会加入batchnorm，并使用ReLU激活函数，所以depthwise separable convolution的基本结构如下图所示：</p><p><img src="https://z3.ax1x.com/2021/03/30/cizKqe.png" style="zoom:67%;" /></p><p>MobileNet网络结构如下图：</p><p><img src="https://z3.ax1x.com/2021/03/30/cFSMlV.jpg" alt = '整体网络结构' style="zoom:40%;" /></p><p>其中第三层红色标注’pw‘表明这一层为pointwise卷积，即为$1 \times 1$的卷积，下面的同理。另外倒数第五行的depthwise卷积的步长应该为s1，即$stride=1 \times 1$，应该是作者制作表格时弄错了。</p><p>剩下的网络结构就不再赘述了，图片中介绍得很详细。</p><h3 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h3><p>Mobile Net与比较流行的网络结构性能比较如下图：</p><p><img src="https://z3.ax1x.com/2021/03/30/cizQVH.png" style="zoom:50%;" /></p><p>上表的1.0 MobileNet-224指的是输入图片分辨率为224的标准MobileNet模型。可以明显看出Mobile Net在计算量与参数量都远小于其他网络的情况下，在ImageNet数据集上的准确率可以保持大致接近。</p><p>因此，在数据量不大，分类数目不多，难度不太大的情况下，采用Mobile Net可以达到不错的效果，同时大大加快训练与推理速度，并且对于内存要求也比较低。</p><h3 id="更小的MobileNet"><a href="#更小的MobileNet" class="headerlink" title="更小的MobileNet"></a>更小的MobileNet</h3><p>MobileNet主打的是轻量级模型，那么肯定不会局限于只改变卷积方式，它在输入图片尺寸和网络中卷积的通道深度都是可以配置的。分别为<strong>宽度因子α （Width multiplier ）</strong>和<strong>分辨率因子ρ（Resolution multiplier ）</strong>。</p><p><img src="https://z3.ax1x.com/2021/03/30/cFSKS0.jpg" style="zoom:40%;" /></p><p>宽度因子α可以同时减少运算量和参数量，分辨率因子ρ只可以减少运算量。ρ=0.714一行表示输入图片尺寸为160*160，并同时设置α=0.75。</p><h4 id="Width-Multiplier"><a href="#Width-Multiplier" class="headerlink" title="Width Multiplier"></a>Width Multiplier</h4><p>尽管不如全连接层的神经元个数代表该层的宽度那么直观，卷积层的通道数也可以代表改卷积层的宽度。而卷积层的深度则表示网络的深度。一般而言，一个”窄而深“的网络表现要好于“宽而浅”的网络。</p><p>控制模型宽度的超参数是：宽度因子α （Width multiplier ），用于控制输入和输出的通道数，即输入通道从M 变为αM，输出通道从N 变为αN。α 的范围为(0，1]，一般会取值为0.25，0.5，0.75，1。（如果宽度因子α * 标准网络的通道数不等于整数，直接用int取整）</p><p>宽度因子α 可以调节网络的宽度，从而进一步减少计算量。举个例子，标准的1.0 MobileNet-224网络的第一层为通道数为32的正常卷积，第二层为通道数为32的depthwise卷积。而α =0.5的0.5 MobileNet-224网络，第一层为通道数为16的正常卷积，第二层位通道数位16的depthwise卷积。</p><p>对于depthwise separable convolution，其计算量变为：</p><script type="math/tex; mode=display">D_k \times D_k \times D_f \times D_f \times \alpha M + D_f \times D_f \times \alpha M \times \alpha N</script><p>和常规卷积方式的计算量相比：</p><script type="math/tex; mode=display">计算量之比 = \frac{D_k \times D_k \times D_f \times D_f \times \alpha M + D_f \times D_f \times \alpha M \times \alpha N}{D_k \times D_k \times D_f \times D_f \times M \times N}  \\= \frac{\alpha}{N} + \frac{\alpha^2}{D_k^2}</script><p>宽度因子将计算量和参数降低为约$\alpha^2$倍，可很方便的控制模型大小.</p><p>理论上，宽度因子α是控制卷积神经网络宽度的因子，不仅仅局限于MobileNet，常规的卷积神经网络也可以通过设置宽度因子来使得模型变窄从而减小模型和加快运算速度。</p><h4 id="Resolution-multiplier"><a href="#Resolution-multiplier" class="headerlink" title="Resolution multiplier"></a>Resolution multiplier</h4><p>第二个控制模型大小的超参数是：分辨率因子ρ（resolution multiplier ），用分辨率因子控制图片的分辨率和输入特征图的宽高，以此减少乘加运算的次数。</p><p>可设置ρ ∈ ( 0 , 1 ] ，来控制输入分辨率为$224 \times \rho $，而在tensorflow中，只能设置输入分辨率为224 , 192 , 160 和 128。</p><p>标准的1.0 MobileNet-224模型中，图片输入到网络前会被放缩，限制在224×224的pixel，然后输入到模型中。而分辨率因子会进一步限制输入图片的尺寸为$（224\times \rho）* (224\times \rho)$。</p><p>在上述两种方法都使用的情况下：</p><script type="math/tex; mode=display">计算量之比 = \frac{D_k \times D_k \times \rho D_f \times \rho D_f \times \alpha M + \rho D_f \times \rho D_f \times \alpha M \times \alpha N}{D_k \times D_k \times D_f \times D_f \times M \times N}  \\= \frac{\alpha \rho^2}{N} + \frac{\alpha^2 \rho^2}{D_k^2}</script><p>同样的，缩减输入图片分辨率也是其他网络常用的方法之一。</p><p>使得网络变窄以及使得图片变小在加快网络速度的同时，也会降低网络的精度。下图为分别改变α和ρ的结果：</p><p><img src="https://z3.ax1x.com/2021/03/30/cizGGt.jpg" style="zoom:33%;" /></p><p>使用者可以根据自己的设备算力和问题复杂程度调整这两个参数，来灵活应对不同的问题。</p><h3 id="Tensorflow实现"><a href="#Tensorflow实现" class="headerlink" title="Tensorflow实现"></a>Tensorflow实现</h3><p>MobileNet已经收录在tensorflow的applications中，见此<a href="https://github.com/tensorflow/tensorflow/blob/98fe455579e1569050ee54567287c0a0b07b0a71/tensorflow/python/keras/applications/mobilenet.py#L82">GitHub地址</a>。</p><p>并且有在ImageNet上训练好的模型可以直接使用。</p><h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h3><p>我个人还是很喜欢MobileNet找一个网络结构的，虽然它的精度比不上ResNet，但是实际情况下我还是会经常用到它。在许多不是特别复杂的任务中，通过预先处理数据，剔除掉一些干扰特征，这个网络也可以表现得很不错。</p><p>而且分组卷积也是一个非常符合人类思维的结构。在上学那会，因为先接触到的是灰度图的数字图像处理，图像处理里的灰度图的空域变换都是用的厚度为1的算子卷积图像，所以刚刚接触到CNN的时候，我对卷积过程中卷积核的形状产生过疑惑，我总以为卷积核就是一个3*3*1的形状。即使后来理解了仍然会好奇为什么每一个通道需要使用不同的算子。而分组卷积正好就是不同的通道使用同一个算子从而减少参数量。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> MobileNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题——机器人跳跃</title>
      <link href="/2020/06/30/zi-jie-suan-fa-ti-ji-qi-ren-tiao-yue/"/>
      <url>/2020/06/30/zi-jie-suan-fa-ti-ji-qi-ren-tiao-yue/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。 </p><p>起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与$H_{k+1}$与E之差的能量。如果$H_{k+1}$&gt; E 那么机器人就失去$H_{k+1}$- E 的能量值，否则它将得到 E - $H_{k+1}$的能量值。</p><p>游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">第一行输入，表示一共有 N 组数据.</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">第二个是 N 个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度</span></span></code></pre></div></div></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>根据题目描述，我们可以得到一个关于机器人能量值的公式。设机器人跳到第k个建筑时的能量值为$E_k$，则：</p><script type="math/tex; mode=display">E_{k+1} = \begin{cases}E_k - (H_{k+1} - E_k), \quad H_{k+1} > E_k \\E_k + (E_k - H_{k+1}), \quad H_{k+1} \leq E_k \\\end{cases}</script><p>即：</p><script type="math/tex; mode=display">E_{k+1} = 2E_k - H_{k+1} \tag{1}</script><p>并且：</p><script type="math/tex; mode=display">E_{k} = 2E_{k-1} - H_{k}</script><p>根据这个递推公式，我们可以得到$E_n与E_0以及H_n$之间的关系：</p><script type="math/tex; mode=display">E_n = 2E_{n-1} - H_{n} = 2\times (2E_{n-2} - H_{n-1}) - H_n =……\\= 2^nE_0 -\sum_{i=1}^n 2^{n-i} H_i</script><p>题目要求$对于\ \forall n, E_n\geq 0 $，则：</p><script type="math/tex; mode=display">对于\forall n, E_0 \geq \sum_{i=1}^{n}\frac{H_i}{2^i}</script><p>所以符合题意的最小$E_0 = \lceil \ \sum_{i=1}^{n}\frac{H_i}{2^i} \ \rceil$</p><h3 id="逆推"><a href="#逆推" class="headerlink" title="逆推"></a>逆推</h3><p>想象一下，机器人从第n个建筑往前跳，则有$E_{n} = 2E_{n-1} - H_{n}$，即机器人在后一个建筑时的能量，加上建筑的高度，等于2倍的在前一个建筑时的能量，这样就可以依次获取到在前一个建筑的能量。</p><p>现在要求跳到第n个建筑的时候能量不小于0，则最小为0，那么设$E_{n} = 0$，则$E_{n-1} =\lceil \frac{H_n}{2} \rceil, E_{n-2} =\lceil \frac{H_{n-1}\ +\ E_{n-1}}{2} \rceil …… E_{0} =\lceil \frac{H_1 \ + \ E_{1}}{2} \rceil$。</p><h3 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h3><p>还可以直接模拟跳跃过程，搜索最小的$E_0$。搜索过程可以使用二分查找。</p><p>初始的能量只要超过全部建筑高度之和sum，则必定可以跳到最后一个建筑。则可以在 [1, sum] 使用二分查找。</p><p>也可以从1开始，跳跃失败则指数增加，直到跳跃成功，然后在失败的最大值和成功值之间二分查找。例如开始$E_0 = 1$，失败则设置$E_0 = 2$、$E_0 = 4$、$E_0 = 8$，假设$E_0 = 8$成功，则在 [4,8]之间二分查找。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><h4 id="公式法-1"><a href="#公式法-1" class="headerlink" title="公式法"></a>公式法</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">n </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">hight </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(i) </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">()]</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">E </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i,v </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">enumerate</span><span style="color: #ABB2BF">(hight):</span></span><span class="line"><span style="color: #ABB2BF">    E</span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF">(v</span><span style="color: #56B6C2">/</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">**</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> math</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(math.</span><span style="color: #61AFEF">ceil</span><span style="color: #ABB2BF">(E))</span></span></code></pre></div></div></figure><h4 id="逆推-1"><a href="#逆推-1" class="headerlink" title="逆推"></a>逆推</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">n </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">hight </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(i) </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">()]</span></span><span class="line"><span style="color: #ABB2BF">hight.</span><span style="color: #61AFEF">reverse</span><span style="color: #ABB2BF">()</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> math</span></span><span class="line"><span style="color: #ABB2BF">E </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> hight:</span></span><span class="line"><span style="color: #ABB2BF">    E</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> math.</span><span style="color: #61AFEF">ceil</span><span style="color: #ABB2BF">((E</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">v)</span><span style="color: #56B6C2">/</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(math.</span><span style="color: #61AFEF">ceil</span><span style="color: #ABB2BF">(E))</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题——连续出题问题</title>
      <link href="/2020/06/10/zi-jie-suan-fa-ti-lian-xu-chu-ti-wen-ti/"/>
      <url>/2020/06/10/zi-jie-suan-fa-ti-lian-xu-chu-ti-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每个出题人都出了一些有趣的题目，现在想把这些题目组合成若干场考试出来，在选题之前，我们定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：<br>a&lt;=b&lt;=c<br>b-a&lt;=10<br>c-b&lt;=10<br>一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，你能计算出我们最少还需要再出几道题吗？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目看起来复杂，实际上思路很简单，因为只有每场考试三个题目只有一个限制条件：a&lt;=b&lt;=c，b-a&lt;=10，c-b&lt;=10，即max((b-a), (c-b))&lt;=10。</p><p>所以可以先排序，后遍历数组,</p><p>1:相邻3个数满足相邻差均&lt;=10,则三个可以为一组,不需要加新的题目;</p><p>2:第二个数-第一个数&gt;=20;表示第一个数自成一组,需要添加2个题目;</p><p>3:第二个数-第一个数在10-20之间,这两个数为一组,需要添加1个题目;</p><p>4:第二个数-第一个数小于10,而第三个数-第二个数大于10,前两个题目为一组,需要添加1个题目。</p><p>第三点和第四点再写法上可以并为一点。</p><p>最后剩下的可能为1或者2个数,再判断一次即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">n </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">()[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #ABB2BF">ques </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">sorted</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">map</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">()))</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #56B6C2">&gt;=</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># max((b-a), (c-b))&lt;=10,即三个题目可以分为一组</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((ques[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">ques[pos])</span><span style="color: #56B6C2">&lt;=</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> (ques[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">ques[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">])</span><span style="color: #56B6C2">&lt;=</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        pos</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">3</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 前两个相差大于20,至少需要增加2题</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF">((ques[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">ques[pos])</span><span style="color: #56B6C2">&gt;</span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        re</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #ABB2BF">        pos</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 前两个可以为一组</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        re</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">        pos</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 剩余1个题目</span></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #56B6C2">==</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    re</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 剩余2个题目,有2种情况,一种增加一个题目,另一种增加4个题目</span></span><span class="line"><span style="color: #C678DD">elif</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #56B6C2">==</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    [a,b] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ques[</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">:]</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((b</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">a)</span><span style="color: #56B6C2">&lt;=</span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        re</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        re</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">4</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(re)</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #98C379">&lt;iostream&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #98C379">&lt;vector&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #98C379">&lt;algorithm&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">(){</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n;</span></span><span class="line"><span style="color: #ABB2BF">    cin</span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF">n;</span></span><span class="line"><span style="color: #ABB2BF">    vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ques</span><span style="color: #ABB2BF">(n,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;i</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">n;i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        cin</span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 排序</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> re </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 遍历</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #C678DD">&gt;=</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // max((b-a), (c-b))&lt;=10,即三个题目可以分为一组</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos])</span><span style="color: #C678DD">&lt;=</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">])</span><span style="color: #C678DD">&lt;=</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            pos</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 前两个相差大于20,至少需要增加2题</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]</span><span style="color: #56B6C2">-</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos])</span><span style="color: #C678DD">&gt;</span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            re</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            pos</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 前两个可以为一组</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            re</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            pos</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }   </span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 剩余2个题目,有2种情况,一种增加一个题目,另一种增加4个题目</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #C678DD">==</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((</span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ques</span><span style="color: #ABB2BF">[pos])</span><span style="color: #C678DD">&lt;=</span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            re</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            re</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 剩余1个题目,增加2题</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">pos</span><span style="color: #C678DD">==</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        re</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout</span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> re </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节算法题——字典序</title>
      <link href="/2020/05/24/zi-jie-suan-fa-ti-zi-dian-xu/"/>
      <url>/2020/05/24/zi-jie-suan-fa-ti-zi-dian-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定整数n和m, 将1到n的这n个整数按字典序排列之后, 求其中的第m个数。<br>对于n=11, m=4, 按字典序排列依次为1, 10, 11, 2, 3, 4, 5, 6, 7, 8, 9, 因此第4个数是2.<br>对于n=200, m=25, 按字典序排列依次为1 10 100 101 102 103 104 105 106 107 108 109 11 110 111 112 113 114 115 116 117 118 119 12 120 121 122 123 124 125 126 127 128 129 13 130 131 132 133 134 135 136 137 138 139 14 140 141 142 143 144 145 146 147 148 149 15 150 151 152 153 154 155 156 157 158 159 16 160 161 162 163 164 165 166 167 168 169 17 170 171 172 173 174 175 176 177 178 179 18 180 181 182 183 184 185 186 187 188 189 19 190 191 192 193 194 195 196 197 198 199 2 20 200 21 22 23 24 25 26 27 28 29 3 30 31 32 33 34 35 36 37 38 39 4 40 41 42 43 44 45 46 47 48 49 5 50 51 52 53 54 55 56 57 58 59 6 60 61 62 63 64 65 66 67 68 69 7 70 71 72 73 74 75 76 77 78 79 8 80 81 82 83 84 85 86 87 88 89 9 90 91 92 93 94 95 96 97 98 99 因此第25个数是120…</p><p><strong>分析：</strong>由于首位不能为0，所以可以构造出以0-9为根的9棵十叉树。</p><p><img src="tree.png" alt='以1为根的十叉树' style="zoom:50%;" /></p><p>以字典序排序就是求上述十叉树的深度遍历。深度遍历一般使用递归实现。</p><p>有意思的是，如果使用广度搜索，就可以实现自然数顺序的排序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><h4 id="1-暴力排序"><a href="#1-暴力排序" class="headerlink" title="1.暴力排序"></a>1.暴力排序</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">[n, m] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">map</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">strList </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">(i) </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, n</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)]</span></span><span class="line"><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">strList.</span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(strList[m</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]))</span></span></code></pre></div></div></figure><p>python对于字符串的排序方式就是按照字典顺序进行排序的，但是会直接内存溢出。</p><h4 id="2-字典树"><a href="#2-字典树" class="headerlink" title="2.字典树"></a>2.字典树</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">[n, m] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">map</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">())</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findNum</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">value</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">global</span><span style="color: #ABB2BF"> re, m</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(value)</span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF">n:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 以字典序从小到大查找，每找到一个就小于n的数就使全局变量m-1</span></span><span class="line"><span style="color: #ABB2BF">        m</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># m减到0，表示已经找到第m个数</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> m</span><span style="color: #56B6C2">==</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> value</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findNum</span><span style="color: #ABB2BF">(value</span><span style="color: #56B6C2">+str</span><span style="color: #ABB2BF">(i))</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 通过return True跳过接下来所有的递归</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> flag:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 通过return 0来停止同一深度的递归，比如100已经超过n，则不再递归101</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> flag </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> a </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findNum</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">(a))</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> flag:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(re)</span></span></code></pre></div></div></figure><p>深度遍历字典树应该是最符合题目要求的做法，不过python使用递归效率不高，百万级数据就已经显示超时。</p><h4 id="3-找规律"><a href="#3-找规律" class="headerlink" title="3.找规律"></a>3.找规律</h4><h5 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h5><p>实际上，上面的字典树的目的在于找出第m个数在哪一个字典树以及在某个字典树的哪个位置。</p><p>而上面的字典树递归解法，浪费了太多时间在递归上，而实际上很多递归是不必要的。我们可以通过计算以1开头的字典树的元素个数，和m比较，这样就可以知道m是否在以1开头的字典树中。</p><p>比如以 $n=25,m=20$ 为例。</p><p>小于等于25的数字按照字典序进行排序分别为：1 10 11 12 13 14 15 16 17 18 19 2 20 21 22 23 24 25 3  4 5 6 7 8 9</p><p>我们可以发现一些规律：</p><ol><li><p>由于25是2位数字，所以字典序中存在2位数字，又由于25的首位为2，所以只有1和2开头的可以取到2位数字，而剩下的3到9开头的数字则少一位。</p></li><li><p>1和2开头的可以取到2位数字，而由于n为25，所以以2开头的数字取不满所有2位数，只有以1开头的数字可以取满，分别为10 11 12 13 14 15 16 17 18 19共10个数字再加上一位的1，以1开头的数字一共是$10^0+10^1=11$ ，以2开头的数字有$10^0+(25 - 2*10^1+1) = 7$个，以3、4、5、6、7、8、9开头的各1个。</p></li></ol><p>由上述规律可知，以1开头的数字为11个，以1开头的数排列完成之后才会有以2开头的数。由于m为20大于11，那么必然第20个数不会是以1开头。</p><p>因此，递归的过程可以由计算以某个数字开头的所有数字个数替代，以减少计算次数。</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 以pre开头，并且小于等于n的数字个数</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">culculateNum_with_prefix</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">n</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">pre</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    n, pre </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">(n), </span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">(pre)</span></span><span class="line"><span style="color: #ABB2BF">    len_n, len_p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(n), </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(pre)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 以0开头的非法数字或者upper位数小于pre</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> len_n </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> len_p </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> pre.</span><span style="color: #61AFEF">startswith</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;0&quot;</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># n的相同位数前缀</span></span><span class="line"><span style="color: #ABB2BF">    pre_upper </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> n[:len_p]</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># pre小于n的前缀</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> pre </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> pre_upper:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;1&quot;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> len_n </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> len_p))</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># pre大于n的前缀</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> pre </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> pre_upper:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;1&quot;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> (len_n </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> len_p)) </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> len_n </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> len_p </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 开头相同，位数也相同，则只有pre本身一个数；开头相同，位数不同则需要分开计算</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;1&quot;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> (len_n </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> len_p)) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">(n[len_p:]) </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> len_n </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> len_p </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">n,m </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">list</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">map</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">,</span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">()))</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">digits </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">tuple</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">(x) </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> x </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">prefix, rank </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;&quot;</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> rank </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> m:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(digits)):</span></span><span class="line"><span style="color: #ABB2BF">        d </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> digits[i]</span></span><span class="line"><span style="color: #ABB2BF">        num </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">culculateNum_with_prefix</span><span style="color: #ABB2BF">(n, prefix </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> d)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> rank </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> num </span><span style="color: #56B6C2">&gt;=</span><span style="color: #ABB2BF"> m:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #ABB2BF">        rank </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> num</span></span><span class="line"><span style="color: #ABB2BF">    prefix </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> d</span></span><span class="line"><span style="color: #ABB2BF">    rank </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(prefix)</span></span></code></pre></div></div></figure><h5 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h5><p>上面的<code>culculateNum_with_prefix</code>函数用数字的位数快速计算以某数为前缀的数字个数，这实际上就是以这个前缀<code>pre</code>为根节点的字典树元素个数。</p><p>数字个数计算分为三种情况：</p><ol><li><strong><code>pre</code>小于<code>n</code>的前缀</strong></li></ol><p>举个例子，<code>n=250</code>， <code>pre=1</code>，则计算以1开头且小于250的数，分别为<code>1、10-19、100-199</code>共111个数，因为<code>pre</code>小于同位数的<code>n</code>的前缀2，所以相同位数的以<code>pre</code>开头的数字全都小于<code>n</code>。个数与<code>n</code>与<code>pre</code>的位数差有关，每相差一位，个数多十倍。所以满足条件的数字个数为<code>位数差+1</code>个1，以上面的250为例，位数差为2为，则数字个数为3个1，即111。</p><ol><li><strong><code>pre</code>大于<code>n</code>的前缀</strong></li></ol><p><code>n=250</code>， <code>pre=3</code>，满足条件的数只能为1位或者2位数字，即<code>3、30-39</code>共11个数字，所以是<code>位数差</code>个1，2个1即11。</p><ol><li><strong><code>pre</code>等于<code>n</code>的前缀</strong></li></ol><p><code>pre</code>等于<code>n</code>的前缀的情况分为两种。第一种，<code>pre</code>和<code>n</code>的位数相同。例如<code>n=250</code>， <code>pre=250</code>，则只有250这一个数字。</p><p>第二种<code>pre</code>小于<code>n</code>的位数，比如<code>n=250</code>， <code>pre=2</code>，满足条件的数为1、2、3位，即<code>2、20-29、200-250</code>共62个数字。62由两部分计算而成：位数小于n的数、位数等于n的数。分别为<code>位数差</code>个1、<code>除去前缀后的数的个数+1</code>。在这个例子中，第一部分，位数小于n（2、20-29）：250和2位数相差2，2个1即11；第二部分，位数相同（200-250）：250去除前缀2之后等于50，再加一，得51。共62个数。</p><h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><p>计算第m个数的时候，首先我们计算所有以1开头并且小于n的数字个数，这个数字小于m则继续计算以2开头并且小于n的数字个数。若这个数字大于m，则表明第m个数一定是以1为前缀，此时再继续以10为前缀……并且前缀每增加一位，表明字典深度增加1，所以根节点保证满足小于m，要把根节点也加上。</p><p>对于以<code>n=200, m=25</code>为例，</p><ol><li>首先计算以1开头的数字个数为111，显然大于m。 所以m必然以1开头，已经查找的数为根节点1，rank置为1；</li><li>计算以10开头的数字个数为11，小于m。加上根节点1已经查找了12个数，rank置为12；</li><li>计算以11开头的数字个数为11个，已经查找了前23个数小于m，rank置为23；</li><li>计算以12开头的数字个数为11个，加上之前的23已经超过m。 所以m必然以12开头，加上满足条件的根节点12，rank置为24；</li><li>计算以120开头的数字个数为1，加上rank=24，正好25。查找完毕。</li></ol><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;iostream&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;cstring&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;string&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;vector&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;algorithm&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">vector</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">string</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> ve;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">culculateNum_with_prefix</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">string</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">string</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">pre</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> len_n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">n</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> len_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">((len_n</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">len_p) </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">]</span><span style="color: #C678DD">==</span><span style="color: #98C379">&#39;0&#39;</span><span style="color: #ABB2BF">))</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    string n_pre;</span></span><span class="line"><span style="color: #ABB2BF">    n_pre </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">n</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">substr</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,len_p);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(pre</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">n_pre){</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 重复打印1+len_n-len_p个1</span></span><span class="line"><span style="color: #ABB2BF">        string </span><span style="color: #61AFEF">tmp</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> len_n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">len_p,</span><span style="color: #98C379">&#39;1&#39;</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">atoi</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">c_str</span><span style="color: #ABB2BF">());   </span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(pre</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">n_pre){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(len_n</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">len_p){</span></span><span class="line"><span style="color: #ABB2BF">            string </span><span style="color: #61AFEF">tmp</span><span style="color: #ABB2BF">(len_n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">len_p,</span><span style="color: #98C379">&#39;1&#39;</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">atoi</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">c_str</span><span style="color: #ABB2BF">());   </span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(len_n</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">len_p){</span></span><span class="line"><span style="color: #ABB2BF">            string str </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">n</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">substr</span><span style="color: #ABB2BF">(len_p);</span></span><span class="line"><span style="color: #ABB2BF">            string </span><span style="color: #61AFEF">tmp</span><span style="color: #ABB2BF">(len_n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">len_p,</span><span style="color: #98C379">&#39;1&#39;</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">atoi</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">c_str</span><span style="color: #ABB2BF">()) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">atoi</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">str</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">c_str</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">(){</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n,m;</span></span><span class="line"><span style="color: #ABB2BF">    cin</span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF">n</span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF">m;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // n = 1000000;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // m = 888888;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;i</span><span style="color: #C678DD">&lt;=</span><span style="color: #D19A66">9</span><span style="color: #ABB2BF">;i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">ve</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">to_string</span><span style="color: #ABB2BF">(i));</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    string prefix </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;&quot;</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> rank </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> num </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    string d </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&quot;&quot;</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (rank</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">m){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;j</span><span style="color: #C678DD">&lt;</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">;j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            d </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ve</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">            num </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">culculateNum_with_prefix</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">to_string</span><span style="color: #ABB2BF">(n), prefix</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">d);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(rank</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">num</span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF">m){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            rank</span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF">num;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        prefix</span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF">d;</span></span><span class="line"><span style="color: #ABB2BF">        rank</span><span style="color: #C678DD">+=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout</span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF">prefix</span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF">endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">cin</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">get</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
            <tag> 字节 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——二叉树路径和为指定值</title>
      <link href="/2020/05/08/yi-dao-bian-cheng-ti-er-cha-shu-lu-jing-he-wei-zhi-ding-zhi/"/>
      <url>/2020/05/08/yi-dao-bian-cheng-ti-er-cha-shu-lu-jing-he-wei-zhi-ding-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个值 <code>sum</code>，请找出所有的根节点到叶子节点的节点值之和等于 <code>sum</code> 的路径。返回一个二维数组，数组中保存路径上节点的值。</p><p><img src="1.png" style="zoom:60%;" /></p><p>返回结果：[[5,4,11,2], [5,8,9]]</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>本题涉及二叉树的遍历，需要注意的是题目中所需要的路径为根节点到叶子节点，所以即使路径和已经为 <code>sum</code> ，也是不符合题目要求的路径。</p><p>二叉树的遍历既可以使用 <code>DFS</code> 也可以用  <code>BFS</code> 。<code>DFS</code> 的话需要使用递归，终止递归的条件为节点不存在，在递归的过程中，如果遇到节点为叶子节点并且路径和为所给定的值，则将这个路径保存下来，所以我们需要两个数组，一个数组用来暂存每一个遍历的路径，另外一个用来保存满足条件的路径。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><h4 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS/递归"></a>DFS/递归</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># class TreeNode:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#     def __init__(self, x):</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.val = x</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.left = None</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.right = None</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> copy</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">__init__</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pathSum</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">root</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">sum</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(root, </span><span style="color: #56B6C2">sum</span><span style="color: #ABB2BF">, tmp)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.re</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># python函数传参形参为数组时传的是引用</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">root</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">sum</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">tmp</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归终止条件：节点为空</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root):</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 节点存在则加入到路径中</span></span><span class="line"><span style="color: #ABB2BF">        tmp.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(root.val)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.left </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.right </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">sum==</span><span style="color: #ABB2BF">root.val):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 这里需要用到深拷贝，否则tmp数组被加入到re中之后，仍然会被改变</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.re.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(copy.</span><span style="color: #61AFEF">deepcopy</span><span style="color: #ABB2BF">(tmp))</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归左右子树</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(root.left, </span><span style="color: #56B6C2">sum-</span><span style="color: #ABB2BF">root.val, tmp)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(root.right, </span><span style="color: #56B6C2">sum-</span><span style="color: #ABB2BF">root.val, tmp)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 出递归，删去末尾节点，以便递归另外一个方向</span></span><span class="line"><span style="color: #ABB2BF">        tmp.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># BFS</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution2</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pathSum</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">root</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">ssum</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root):</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># path数组保存根节点到当前节点的路径值</span></span><span class="line"><span style="color: #ABB2BF">        path </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [root.val]</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [[root, path]]</span></span><span class="line"><span style="color: #ABB2BF">        re </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> tmp:</span></span><span class="line"><span style="color: #ABB2BF">            node, path </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> node.left </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> node.right </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">sum</span><span style="color: #ABB2BF">(path) </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> ssum:</span></span><span class="line"><span style="color: #ABB2BF">                re.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(path)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> node.left:</span></span><span class="line"><span style="color: #ABB2BF">                tmp.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">([node.left, path</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">[node.left.val]])</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> node.right:</span></span><span class="line"><span style="color: #ABB2BF">                tmp.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">([node.right, path</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">[node.right.val]])</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> re</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><h4 id="DFS-递归-1"><a href="#DFS-递归-1" class="headerlink" title="DFS/递归"></a>DFS/递归</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #7F848E; font-style: italic"> TreeNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">sum</span><span style="color: #7F848E; font-style: italic"> int整型 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> int整型vector&lt;vector&lt;&gt;&gt;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; &gt; </span><span style="color: #61AFEF">pathSum</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">sum</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">vector</span><span style="color: #C678DD">&lt;int&gt;&gt;</span><span style="color: #ABB2BF"> result;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(root,sum, result, tmp);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> result;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">sum</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">re</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #E06C75; font-style: italic">tmp</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(root </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> ;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> sum </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">re</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(tmp);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">, sum</span><span style="color: #56B6C2">-</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">, re, tmp);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">findPath</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">, sum</span><span style="color: #56B6C2">-</span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">, re, tmp);</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        //tmp.pop_back(); // tmp数组传引用的话需要pop_back()</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——删除倒数第k个节点</title>
      <link href="/2020/04/17/yi-dao-bian-cheng-ti-shan-chu-dao-shu-di-k-ge-jie-dian/"/>
      <url>/2020/04/17/yi-dao-bian-cheng-ti-shan-chu-dao-shu-di-k-ge-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，删除链表的倒数第n个节点并返回链表的头指针，给出的链表为:1-&gt;2-&gt;3-&gt;4-&gt;5, n= 2。 删除了链表的倒数第n个节点之后,链表变为1-&gt;2-&gt;3-&gt;5。（保证n为有效值）</p><p>删除一个节点，可以找出其前一个节点，然后将其next指针指向需要删除的节点的后一个节点。或者也可以找到要删除的节点，将其数据域设置为其后一个节点的值，然后next指针指向要删除的节点的后两个节点。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># class ListNode:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#     def __init__(self, x):</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.val = x</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.next = None</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">#</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># @param head ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># @param n int整型 </span></span><span class="line"><span style="color: #7F848E; font-style: italic"># @return ListNode类</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">removeNthFromEnd</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">n</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head): </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 找到倒数第n个节点的前一个节点，也就是倒数第n+1个节点</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">findNthNode</span><span style="color: #ABB2BF">(head, n</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> node:</span></span><span class="line"><span style="color: #ABB2BF">            node.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> node.next.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            head </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 寻找倒数第n个节点，不存在则返回None</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">findNthNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">n</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        firstP, secondP </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head, head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(firstP </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> n):</span></span><span class="line"><span style="color: #ABB2BF">            n</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            firstP </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> firstP.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># fristP指针刚好不存在，而n已经等于0，也就是说倒数第n个正好是头节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> firstP </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">==</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># firstP不存在且不足n个节点，则说明没有倒数第n个节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> firstP):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(firstP):</span></span><span class="line"><span style="color: #ABB2BF">            firstP  </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">firstP.next</span></span><span class="line"><span style="color: #ABB2BF">            secondP </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> secondP.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> secondP</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>由于本题说明n为有效值，则可以稍微简单一点，不考虑n大于链表长度的情况：</p><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #7F848E; font-style: italic"> int整型 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> ListNode类</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">removeNthFromEnd</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> fast </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> slow </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(head</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(n</span><span style="color: #C678DD">&gt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> fast</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            fast </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">fast</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            n</span><span style="color: #C678DD">-=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 要删除的为head节点，即链表长度为n</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(fast</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 链表长度小于n</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">fast</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            fast</span><span style="color: #C678DD">=</span><span style="color: #E5C07B">fast</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            slow</span><span style="color: #C678DD">=</span><span style="color: #E5C07B">slow</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">slow</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">slow</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激活函数与评价指标</title>
      <link href="/2020/04/01/ji-huo-han-shu-yu-ping-jie-zhi-biao/"/>
      <url>/2020/04/01/ji-huo-han-shu-yu-ping-jie-zhi-biao/</url>
      
        <content type="html"><![CDATA[<p>本文记录了神经网络中常用的几个激活函数以及它们的导数；深度学习模型常用的一些评价指标以及它们的数学公式。</p><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>下图为一个简单的多层感知机：</p><p><img src="https://z3.ax1x.com/2021/03/24/6qFHFe.jpg" style="zoom:25%;" /></p><p>如果没有激活函数，那么神经网络的权重、偏置全是线性的<strong>仿射变换（affine transformation）</strong>:</p><p><img src="https://z3.ax1x.com/2021/03/24/6qFIeK.png" style="zoom:45%;" /></p><p>也就是说，如果没有激活函数，那么无论是多少层的感知机，效果都和一层一样，输出只是输入的线性变换。无法解决任何一个简单的非线性问题，而现实需要解决的问题几乎不会是线性问题。</p><p>因此，激活函数是用来加入非线性因素的，因为线性模型的表达能力不够。</p><p>神经网络的<strong>激活函数（activation function）</strong>可以扭曲翻转特征空间，使特征空间映射到高维，在高维特征空间中寻找线性的边界，即寻找一个超平面，实现边界的分割。</p><p>常见的激活函数有3种：</p><p><img src="https://z3.ax1x.com/2021/03/24/6qFbJH.png" style="zoom:50%;" /></p><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><p><img src="https://z3.ax1x.com/2021/03/24/6qFqWd.png" alt = 'sigmoid函数，红色为其梯度' style="zoom:70%;" /></p><p>sigmoid将输入挤压进0到1区间（这和概率的取值范围一致），这在二分类任务中很常见。</p><h3 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h3><p>在多分类任务中，输出层经常加入softmax函数，完成多分类的目的。</p><p>假设我们有一个有n个元素的数组$V_n$，$V_i$表示V中的第i个元素，那么这个元素的softmax值就是</p><script type="math/tex; mode=display">S_i = \frac{e^i}{\sum_{j = 1}^{n}e^j}</script><p>softmax将多个输出限定在[0,1]之间，并且满足概率之和为1，通过softmax可以将信号呈指数的加大或者减少，突出想要增强的信息。</p><p>在多分类任务中，为了配合softmax激活函数，损失函数采用交叉熵损失去评估真实标签与预测值之间分布的差异。</p><p>交叉熵损失公式为：</p><script type="math/tex; mode=display">Loss = -\sum_{i}y^i\ln{a^i}\quad(y^i表示i类上的真实值，a^i表示i类上的预测值)</script><p>看起来比较复杂，而实际上，由于多分类一般使用one-hot编码，标签中除去正确的一类，其他都为0。</p><p>比如样本属于第j类，则只有$y^j$有值，且为1，其他都为0。因此，交叉熵损失可以简化为：</p><script type="math/tex; mode=display">Loss = -y^j\ln{a^j} \quad \Rightarrow \quad Loss = -\ln{a^j}</script><h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p><img src="https://z3.ax1x.com/2021/03/24/6qFOSA.png" style="zoom:67%;" /></p><p>tanh的形状和sigmoid类似，只不过tanh将“挤压”输入至区间(-1, 1)。因此，中心为零，（某种程度上）激活值已经是下一层的正态分布输入。</p><p>至于梯度，它有一个大得多的峰值1.0（同样位于z = 0处），但梯度下降得更快，当|z|的值到达3时就已经接近零了。这是所谓<strong>梯度消失（vanishing gradients）</strong>问题背后的原因，会导致网络的训练进展变慢。现在一般不用这个激活函数了。</p><h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a><strong>ReLU</strong></h3><p>它是目前通常使用的激励函数。ReLU解决了了sigmoid、tanh中常见的梯度消失问题，同时也是计算梯度<strong>最快</strong>的激励函数。</p><p><img src="relu.png" style="zoom:67%;" /></p><p>它并不会把输入映射到某一区间——它只是<strong>保留正值</strong>，并将所有<strong>负值转化为零</strong>。</p><p>使用ReLU的积极方面是它的梯度要么是1（正值），要么是0（负值）——<strong>再也没有梯度消失了！</strong>这一模式使网络<strong>更快收敛</strong>。</p><p>在代码中，只需要一个<code>if else</code>即可实现，比其他的激活函数运算快得多。</p><p>另一方面，负值时梯度为0导致所谓的<strong>“死亡神经元”</strong>问题，也就是输入持续为负的神经元激活值总是为零。</p><p>因此，出现了<strong>Leaky ReLU</strong>函数，$f(x) = max(0.01x, x)$，这样在小于0的时候也有一个梯度。</p><p>理论上来讲，Leaky ReLU有ReLU的所有优点，外加不会有Dead ReLU问题，但是在实际操作当中，并没有完全证明Leaky ReLU总是好于ReLU。</p><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>目前建模任务目标有几大类：分类、回归、聚类等，不同的目标有不同的模型评价方式。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>分类任务评价指标有精确率、召回率、准确率、F-Score、ROC-AUC 、混淆矩阵</p><p>精确率与召回率多用于二分类问题。<br>精确率（Precision）指的是模型预测为正的样本中有多少是真正的正样本；<br>召回率（Recall）指的是所有正样本有多少被模型判为正样本，即正样本有多少被正确找出，也被称为灵敏度（sensitive）。</p><p>我们先通过韦恩图理解一下精确率与召回率：</p><p>设模型预测出的正样本prediction集合为A，真正的正样本truth集合为B，则有如下韦恩图：</p><p><img src="https://z3.ax1x.com/2021/03/24/6qFXQI.png" style="zoom:50%;" /></p><p><strong>精确率</strong>：</p><script type="math/tex; mode=display">precision(A,B) = \begin{vmatrix} A \bigcap B\end{vmatrix} \div |A|</script><p><strong>召回率</strong>：</p><script type="math/tex; mode=display">recall(A,B) = \begin{vmatrix} A \bigcap B\end{vmatrix} \div |B|</script><p>即两个正样本的交集部分分别与预测值的正样本、真实值的正样本的比值。</p><p>接下来通过混淆矩阵理解精确率与召回率：</p><p><strong>混淆矩阵</strong></p><p><img src="https://z3.ax1x.com/2021/03/24/6qFToD.png" style="zoom:120%;" /></p><p>True Positive(真正，TP)：将正类预测为正类数；</p><p>True Negative(真负，TN)：将负类预测为负类数；</p><p>False Positive(假正，FP)：将负类预测为正类数$\rightarrow$误报 (Type I error)；</p><p>False Negative(假负，FN)：将正类预测为负类数$\rightarrow$漏报 (Type II error)。</p><p>因此，精确率和召回率也可以用混淆矩阵表示：</p><script type="math/tex; mode=display">precision = \frac {TP}{TP+FP}</script><script type="math/tex; mode=display">recall = \frac{TP}{TP+FN}</script><p>本质上，用混淆矩阵表示的精确率和召回率，和用韦恩图计算出来的是一样的。</p><p><strong>准确率</strong></p><p>即预测正确的样本占所有样本的比例：</p><script type="math/tex; mode=display">accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script><p><strong>F-Score</strong></p><p>综合考虑Precision和Recall，是Precision和Recall加权调和平均：</p><script type="math/tex; mode=display">F = \frac{(\alpha^2+1)*P*R}{\alpha^2*(P+R)}</script><p>当$\alpha = 1$时，就是常见的$F1\ score$，也就是</p><script type="math/tex; mode=display">F1 = \frac{2*P*R}{P+R}</script><p><strong>ROC曲线</strong><br>ROC（Receiver Operating Characteristic）曲线是以假正率（FP_rate，简称FPR）和真正率（TP_rate，简称TPR）为轴的曲线，ROC曲线下面的面积我们叫做AUC（area under curve）：<br><img src="https://z3.ax1x.com/2021/03/24/6qFodO.png" style="zoom:60%;" /></p><p>其中 $TPR = \frac{TP}{TP + FN}（与recall的公式一样）, \quad FPR = \frac{FP}{FP+TN}$</p><p>$TPR$ 的含义是原始正样本中，被正确预测为正的比例；</p><p>$FPR$ 的含义是原始负样本中，被错误识别为正的比例。</p><p><strong>ROC曲线绘制过程：</strong></p><p>二分类任务，样本个数为N，激活函数为sigmoid，则输出值区间为（0，1），我们会设置一个阈值（threshold），假设高于阈值的预测为正类，低于阈值的预测为负类。</p><p>当阈值为1时，所有的输出都低于阈值，即所有样本都被认为是负类。那么TPR，也就是正样本中被识别为正样本的比例为0。而FPR，即负样本被识别为正样本的比例也为0。对应ROC曲线中的（0，0）。</p><p>当阈值为0时，所有的输出都高于阈值，即所有样本都被认为是正类。那么TPR，也就是正样本中被识别为正样本的比例为1。而FPR，即负样本被识别为正样本的比例也为1。对应ROC曲线中的（1，1）。</p><p>当我们不断调节阈值，就可以得到N组由（FPR，TPR）组成的点，将这些点相邻地连接起来，就得到了ROC曲线。而这个曲线下的面积就是AUC。</p><p>在预测值为随机值的情况下，ROC曲线对应上图中的蓝色虚线，$AUC=0.5$。</p><p>所以一个有意义的模型的AUC一定是大于0.5的，越接近0.5说明模型越接近于随机猜测。当然如果$AUC<0.5$，我们可以通过规定高于阈值为负类，低于阈值为正类，使得ROC曲线以虚线为对称轴对称到$AUC>0.5$。</p><p>而如果曲线经过左上角的（0，1）点，则表示我们可以找到一个阈值，使得模型可以完美预测所有样本。</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归任务评价指标有RMSE(平方根误差)、MAE（平均绝对误差）、MSE(平均平方误差)</p><script type="math/tex; mode=display">MAE(y_i,\hat{y_i}) = \frac{1}{N} \sum_{i=1}^{N}|y_i - \hat{y_i}|</script><script type="math/tex; mode=display">MSE(y_i,\hat{y_i}) = \frac{1}{N} \sum_{i=1}^{N} (y_i - \hat{y_i})^2</script><script type="math/tex; mode=display">其中，y_i为第i个样本的真实值，\hat{y_i}为第i个样本的预测值。</script><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p>聚类任务评价指标有兰德指数、互信息、轮廓系数</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo加速计划</title>
      <link href="/2020/03/30/hexo-jia-su-ji-hua/"/>
      <url>/2020/03/30/hexo-jia-su-ji-hua/</url>
      
        <content type="html"><![CDATA[<p>前段时间，朋友和我说访问我的博客页面速度很慢，加载要很久。我纳闷，不对啊，不久前还测试过呢，速度蛮快的啊。又清除了缓存测试了一遍，发现还是很快就可以加载。最后一对比，发现原来我加载快是因为我设置了代理，而没有设置代理的国内其他用户访问的速度就很不稳定。</p><p><img src="https://z3.ax1x.com/2021/03/26/6vWsBt.jpg" alt='加速前加载时间' style="zoom:40%;" /></p><p>而因为github服务器在国外，国内访问速度很不稳定，导致部署在GitHub Page上的hexo页面加载很慢，就会严重影响访问体验。经过多次测试，发现白天的时候，访问速度非常慢，大约30s才能加载一篇博客，而图片更多的首页则要接近一分钟。而到了晚上12点之后，访问速度会有所提升。</p><p>总而言之，为了加快博客访问速度，对Hexo的加速计划已经是势在必行了。</p><p>根据上面的加载时间图，发现影响加载时间的文件主要是img文件和js文件，因此加速计划也主要针对这些文件。</p><p>首先，我们可以大致理一下思路，分析以下哪些方法可以加快网页加载速度。</p><ol><li>压缩 <code>js/css/html/images</code> 等文件。</li><li>采用图床。</li><li>CDN 加速，这个通常要收费。</li><li>国内走 Coding.net。</li><li>直接把网页挂载到自己的服务器上。</li></ol><h3 id="加速方法"><a href="#加速方法" class="headerlink" title="加速方法"></a>加速方法</h3><h4 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h4><p>hexo可以用 <code>hexo-neat</code> 或 <code>hexo-all-minifier</code> 等插件把一些静态文件进行压缩，然后上传至GitHub。</p><p>这种方法也有一些缺点，首先很多文件的压缩效果并不是很小，其次网页加载速度慢的原因主要是因为GitHub服务器通信速度慢，从上图可以看出即使有些图片比较小，加载速度仍然很慢。另外，压缩文件会使得每次执行<code>hexo g</code>的时间变长。</p><p>所以这个方法不太理想。</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><p>这个方法对于解决图片问题非常棒，很多大型网站都是使用的这种方法。但是同样也有一些不足之处。</p><p>首先，国内很多图床需要绑定域名，并且必须是备案之后的域名，而我的服务器已经到期，为了图床专门去租一个服务器，然后去办理域名备案。这样对于只为了加速hexo来说未免过于复杂。</p><p>其次图床开始使用之后，会产生很大的依赖性，一旦图床挂掉，那么所有博客中的图片都需要重新替换，非常麻烦。</p><p>考虑到图床的优点，建议大家找一个稳定的图床。</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN（Content Delivery Network，内容分发网络），通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。</p><p>简单来说，就是将网站进行备份，放在不同的服务器，不同的用户请求网站，就会转到自己访问最快的服务器。</p><p>CDN的效果是很棒的，但是一般来说要收费，这里用到的是一个免费的CDN——<a href="https://www.jsdelivr.com/">jsDelivr</a>。</p><p>jsdelivr+github是一个非常棒的组合，jsdelivr的首页就有介绍如何使用GitHub的资源。</p><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><p>把博客迁移到coding.net，就和部署在GitHub上一样，对于国内访问，coding有很大的优势。不过迁移到coding还需要重新配置hexo和域名等，稍有点麻烦，并且在coding部署的页面需要在页面中声明由coding提供支持。</p><p>之前在网上看到由方法可以同时部署在coding和GitHub上，并且实现分流，国内自动解析到coding，而其他用户会自动访问到GitHub。不过也有人说这种方法会导致coding不稳定，这里我也没有尝试过，只是提供一个思路，感兴趣的朋友可以去试试。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>这个应该是最终极的方案了，购买国内的服务器或者自己组件一个服务器，可以保证国内访问速度很快。缺点嘛就是贵。</p><h5 id="1-租用VPS"><a href="#1-租用VPS" class="headerlink" title="1. 租用VPS"></a>1. 租用VPS</h5><p>我看了七牛云、阿里云、腾讯云，其中最便宜的大约在一年200-300（年付价），性能稍微好一点的就要在400以上了。如果能接受这价格，再加上每年购买域名的价格以及配置服务器的过程，那么这个方案是最一劳永逸的了。</p><h5 id="2-自建服务器"><a href="#2-自建服务器" class="headerlink" title="2.自建服务器"></a>2.自建服务器</h5><p>有自己的电脑，并且可以做到稳定开机，那么可以用自己的电脑作为一个私人服务器。首先需要在自己的电脑上安装一个虚拟机，在虚拟机中配置好服务器与网络，然后使用自己家里的路由器做内网穿透，这样就可以借助运营商提供的宽带作为服务器接入互联网的入口。</p><p>不过要小心的是，如果被运营商发现，IP会被封。尽量不要使用80端口和443端口。</p><h3 id="选定方案"><a href="#选定方案" class="headerlink" title="选定方案"></a>选定方案</h3><p>首先，压缩文件对于网络影响不大，排除。其次，搬迁到coding工程量较大，暂定。服务器方案成本较高，待定。</p><p>最终方案为CDN加图床。</p><h4 id="CDN-1"><a href="#CDN-1" class="headerlink" title="CDN"></a>CDN</h4><p>CDN选用<a href="https://www.jsdelivr.com/">jsDelivr</a>，效果不错并且免费。jsDelivr也有一个缺点，在CDN中缓存的文件很难更新，因为对外不提供清除缓存的接口，修改文件之后只能等到它自己检查文件更新。测试下来，css文件和js文件大概要1-2天时间才会更新，所以推荐长期不会变动的数据放在上面。针对缓存问题，jsDelivr有了一个接口，用来清除缓存，但是测试下来完全没用，后来查了之后发现需要发邮件去申请这个权限。</p><p>下面简单记录以下jsdelivr的使用方法：</p><p>以我托管博客的 GitHub 仓库为例，地址是 <code>https://github.com/skyfaker/skyfaker.github.io</code>，那它里面的资源可以直接以 <code>https://cdn.jsdelivr.net/gh/skyfaker/skyfaker.github.io/</code> + <code>仓库里的文件路径</code> 来访问。</p><p>比如说，仓库中有个文件为<code>medias/banner/1.jpg</code>。</p><p>而使用CDN之后，地址为：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span></span></code></pre></div></div></figure><p>对于上面图片的地址为：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">https://cdn.jsdelivr.net/gh/skyfaker/skyfaker.github.io/medias/banner/1.jpg</span></span></code></pre></div></div></figure><p>By the way，原本图片在网络中的地址为<code>https://github.com/skyfaker/skyfaker.github.io/blob/master/medias/banner/1.jpg?raw=true</code></p><p>也是可以用上面这个地址直接引用的。</p><p>另外，还有一些其他高级用法，比如指定tag和release：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</span></span></code></pre></div></div></figure><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>针对我的matery主题，虽然主页面图片很多，但所有的图片都是固定的，也就是说长期不会变动的，这个很适合放在jsdelivr上面。同样的，js文件和css文件也可以这样操作。</p><p>修改页面图片主要包括2处，最上面的大图和每一个博客卡片封面的小图。</p><p>大图地址为<code>hexo\themes\matery\layout\_partial\bg-cover-content.ejs</code>:</p><p><img src="https://z3.ax1x.com/2021/03/26/6vWrnI.jpg" style="zoom:45%;" /></p><p>只要在原始路径前加上<code>https://cdn.jsdelivr.net/gh/skyfaker/skyfaker.github.io/</code>即可。</p><p>卡片封面图为<code>hexo\themes\matery\layout\_partial\index.ejs</code>:</p><p><img src="https://z3.ax1x.com/2021/03/26/6vW0cd.jpg" style="zoom:60%;" /></p><p>js文件和css文件修改同理，找到对应的地方，把引用本地文件改为引用jsdelivr中CDN的地址即可。</p><p><img src="https://z3.ax1x.com/2021/03/26/6vWBjA.jpg" style="zoom:50%;" /></p><h4 id="图床-1"><a href="#图床-1" class="headerlink" title="图床"></a>图床</h4><p>一般而言，写博客比较多的作者会打开 <code>post_asset_folder</code> 选项，便于管理博客资源文件：</p><blockquote><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></blockquote><p>开启这个选项之后，每篇博客有一个自己的同名文件夹，用来放置图片文件，在网页中是以相对路径的方式引用图片。并且该路径与博客的名称相关。</p><p>这对于使用jsdelivr却并不方便，因为每一篇文章的图片根目录都不相同路径，我们很难去在某一处统一设置所有图片的根目录。再加上jsdelivr需要引用GitHub上的资源，这就意味着我们必须先把图片文件上传到GitHub，再引用经过jsdelivr加速后的新地址。</p><p>并且由于jsdelivr并不能实时更新，博客图片需要更改需要几天之后才能看到变化。</p><p>因此，为了实时性和加载性能，决定把一些图片较多的博客土拍你搬移到图床上。这里还是建立如果要使用图床，一定要选择一个有保障的、能够持久运营的。</p><p>图床的使用就简单多了，先把图片上传到图床，图床生成图片链接，就像引用网络图片一样引用这个链接即可。</p><h3 id="加速效果"><a href="#加速效果" class="headerlink" title="加速效果"></a>加速效果</h3><p>同样关闭代理，清除缓存，在使用jsdelivr之后，主页基本可以做到秒开：</p><p><img src="https://z3.ax1x.com/2021/03/26/6vWyHP.png" style="zoom:40%;" /></p><p>使用了图床之后，博客文章页也达到了差不多的效果，终于又可以愉快地写博客了。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo加速 </tag>
            
            <tag> jsDelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——合并K个有序链表</title>
      <link href="/2020/03/24/yi-dao-bian-cheng-ti-he-bing-k-ge-you-xu-lian-biao/"/>
      <url>/2020/03/24/yi-dao-bian-cheng-ti-he-bing-k-ge-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述与分析"><a href="#题目描述与分析" class="headerlink" title="题目描述与分析"></a>题目描述与分析</h2><p>合并 k 个已排序的链表并将其作为一个已排序的链表返回。这与之前遇到的合并两个有序链表为同类型的题目。</p><p>这里提供两种方法：</p><ol><li>很显然，合并多个有序链表是合并两个有序链表的拓展情况，因此，可以用合并两个链表的方法，依次两两合并，使得链表最终为1。合并过程类似归并排序的归并过程。</li><li>设置一个大小为K的最小堆，堆中的节点为K个链表的头节点，每次取出最小值（堆顶），然后将这个最小值的下一个节点加入链表（如果有的话），直到堆为空。</li></ol><p>一般数据结构堆的实现方式采用优先队列，队列中的元素有一个优先值，每次pop元素的时候，会取出优先值最小的元素。加入新元素的时候也会重新排序。</p><p>优先队列中元素排列顺序采用堆的层次遍历，由于堆中的父节点均小于子节点，这在优先队列中的表现形式为第一个元素（堆顶）小于第二个元素（左子）和第三个元素（右子）。第K个元素小于第2K和第2K+1个元素。（这里指的是第几个元素，由于很多编程语言中队列首元素从0开始，左右孩子节点计算起来略有不同）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 迭代，两两合并</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeKLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">lists</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> lists:</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 每次取队首两个链表合并，合并之后加入到队尾</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(lists)</span><span style="color: #56B6C2">&gt;</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            first_link </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> lists.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            second_link </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> lists.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            merged_link </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(first_link, second_link)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 返回值不是None则加入到队尾</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> merged_link:</span></span><span class="line"><span style="color: #ABB2BF">                lists.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(merged_link)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> lists:</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> lists[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 两两链表合并</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">link1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">link2</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> link1) </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> link2):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(link1 </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> link2):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> link1.val </span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF">link2.val:</span></span><span class="line"><span style="color: #ABB2BF">                tmp.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> link1</span></span><span class="line"><span style="color: #ABB2BF">                link1 </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> link1.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                tmp.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> link2</span></span><span class="line"><span style="color: #ABB2BF">                link2 </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> link2.next</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp.next</span></span><span class="line"><span style="color: #ABB2BF">        tmp.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> link1 </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> link1 </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> link2</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root.next</span></span></code></pre></div></div></figure><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeKLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">lists</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        queue </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [link </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> link </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> lists </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> link]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> queue:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 这里用有序数组替代了最小堆</span></span><span class="line"><span style="color: #ABB2BF">        queue.</span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">key</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">lambda</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66; font-style: italic">x</span><span style="color: #ABB2BF">:x.val)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 建立一个虚拟首节点</span></span><span class="line"><span style="color: #ABB2BF">        root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> queue:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 取最小值，加入到有序链表</span></span><span class="line"><span style="color: #ABB2BF">            tmp.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> queue.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> tmp.next:</span></span><span class="line"><span style="color: #ABB2BF">                queue.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(tmp.next)</span></span><span class="line"><span style="color: #ABB2BF">                queue.</span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">key</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">lambda</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66; font-style: italic">x</span><span style="color: #ABB2BF">:x.val)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root.next</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><h4 id="归并-1"><a href="#归并-1" class="headerlink" title="归并"></a>归并</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">mergeKLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">lists</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">nullptr</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(root, </span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 合并两个有序链表，返回新链表的头节点 </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l2</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l1</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l2</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(l1</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> l2</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l1 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">tmp </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">                l1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l1 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">tmp </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">                l2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l1</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">tmp </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">root </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">mergeKLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">lists</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #61AFEF">L</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;</span><span style="color: #ABB2BF">L;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">ListNode </span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> v;</span></span><span class="line"><span style="color: #ABB2BF">         </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;i</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">n;i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">lists</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 建堆</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">make_heap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(),</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">(),cmp);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">            // 取堆中最小元素</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">pop_heap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(),</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">(),cmp);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop_back</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">push_heap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(),</span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">(),cmp);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">L</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">static</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">cmp</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">L1</span><span style="color: #ABB2BF">,</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">L2</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">L1 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">L2 </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——寻找环的入口节点</title>
      <link href="/2020/03/02/yi-dao-bian-cheng-ti-xun-zhao-huan-de-ru-kou-jie-dian/"/>
      <url>/2020/03/02/yi-dao-bian-cheng-ti-xun-zhao-huan-de-ru-kou-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述与分析"><a href="#题目描述与分析" class="headerlink" title="题目描述与分析"></a>题目描述与分析</h2><p>对于一个给定的链表，返回环的入口节点，如果没有环，返回null，给出不利用额外空间的解法</p><p>这一题是之前判断链表是否有环的进阶版本，不仅要判断存不存在环，还要找出环的入口节点。</p><p><img src="1.png" style="zoom:38%;" /></p><p>如上图，环的两种形式，则分别返回节点3和节点1.</p><p>借助之前的判断是否存在环的函数（用快慢指针实现），我们可以得知是否存在环，以及存在环的情况下，快慢指针的相遇节点。寻找到环的入口节点需要借助这个相遇节点。</p><p><img src="2.png" alt="带环链表模拟图"></p><p>如上图，X为链表头节点，Y为环的入口，Z为相遇节点。a,b,c分别为沿着链表方向，X与Y，Y与Z，Z与Y之间的节点数。</p><p>由于快慢指针相遇到Z点，可知慢指针行进距离为 $a+b$，又由于快指针的速度是慢指针的2倍，所以快指针的行进距离为 $2*(a+b)$。 并且由于快指针最终也停在了Z点（假设绕环n次），则可知 $2*(a+b)= a + b + k*n$ ，即 $a+b = k*n$ 。</p><p>现在我们已经获得了两个节点X，Z的位置了，从这两个节点到入口节点Y的路程分别为 a 和 $k*n -b$ ，并且a = $k*n - b$。</p><p>所以，可以通过设置一个指针从X开始，另外一个指针从Z，同时以相同的速度前进，当他们相遇时，正好在入口节点上。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">detectCycle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head.next:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 判断是否存在环</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">find_circle</span><span style="color: #ABB2BF">(head)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> node:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 存在环，则设置一个从头节点开始的慢指针，两个慢指针再次相遇时即为换的入口</span></span><span class="line"><span style="color: #ABB2BF">        s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(s</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">node):</span></span><span class="line"><span style="color: #ABB2BF">            s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> s.next</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> node.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> node</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">#  判断是否存在环，存在则返回快慢指针相遇的节点</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find_circle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        f </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(f </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> f.next):</span></span><span class="line"><span style="color: #ABB2BF">            s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> s.next</span></span><span class="line"><span style="color: #ABB2BF">            f </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> f.next.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> s</span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF">f:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> s</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">detectCycle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(head</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 判断是否存在环</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">node </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find_circle</span><span style="color: #ABB2BF">(head);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(node</span><span style="color: #C678DD">==</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 设置一个从头节点开始的慢指针，两个慢指针再次相遇时即为换的入口</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(s</span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF">node){</span></span><span class="line"><span style="color: #ABB2BF">            s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> node;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 判断是否存在环，存在则返回快慢指针相遇的节点</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">find_circle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> f </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(f</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">f</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            f </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">f</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(s</span><span style="color: #C678DD">==</span><span style="color: #ABB2BF">f) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理——形态学</title>
      <link href="/2020/02/17/shu-zi-tu-xiang-chu-li-xing-tai-xue/"/>
      <url>/2020/02/17/shu-zi-tu-xiang-chu-li-xing-tai-xue/</url>
      
        <content type="html"><![CDATA[<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><h3 id="二值图"><a href="#二值图" class="headerlink" title="二值图"></a>二值图</h3><p>解释：二值图像是指仅仅包括黑色和白色两种颜色的图像，计算机将白色像素点处理为“1”，黑色像素点处理为“0”</p><p><img src="erzhi.jpg" alt="二值图" style="zoom:40%;" /></p><h3 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h3><p>计算机会将灰度处理为256个灰度级，用数值区间[0，255]来表示。其中，数值“255”表示为纯白色，数值“0”表示为纯黑色，其余数值表示从纯白到纯黑的数值。</p><p><img src="https://z3.ax1x.com/2021/03/24/6qpYmF.jpg" alt="灰度图" style="zoom:50%;" /></p><p>我们常看到的图片都是8位图片，即图片有$2^8 = 256$个灰度级，图片位数越高，灰度级也就越大，图片的细腻程度也会越高。一般来说8位的图片，人眼一般看不出灰度变化，而低于8位，则图片灰度变化时会产生明显的分界面。</p><h3 id="彩色图"><a href="#彩色图" class="headerlink" title="彩色图"></a>彩色图</h3><p>前面的二值图和灰度图，图片深度为1，而我们平时看见最多的为RGB彩色图，它的深度为3。</p><p><img src="https://z3.ax1x.com/2021/03/24/6qptw4.png" style="zoom:50%;" /></p><p>上面的图片就是彩色点，每一个点都表示一种颜色，而这个颜色是由三种颜色R、G、B混合而成的。依次，我们看到的彩色图片的每一个像素点，都是由三种颜色组成的，我们也可以把这三种颜色分离出来。如下图：</p><p><img src="https://z3.ax1x.com/2021/03/24/6qpNTJ.png" alt="三通道分离" style="zoom:50%;" /></p><h2 id="空间变换"><a href="#空间变换" class="headerlink" title="空间变换"></a>空间变换</h2><p>由于每一个像素点都有自己的空间位置，并且图片就是由像素点表现出来的，那么我们可以通过改变像素点的位置来使得图片产生相应的变换，这就是图片空间变换。</p><p>空间变换对应矩阵的仿射变换，是指一个坐标通过函数变换的新的坐标位置。<br>从数学上来讲， 就是一个向量空间进行一次线形变换并加上平移向量， 从而变换到另外一个向量空间的过程。<br>向量空间m : $m=(x,y)$<br>向量空间n : $n=(x′,y′)$<br>向量空间从m到n的变换 $n=A∗m+b$<br>    即:</p><script type="math/tex; mode=display">\begin{cases}x' = A_{00} * x + A_{01} * y + b_0\\x' = A_{00} * x + A_{01} * y + b_0\\\end{cases}</script><p>将上述的A和b组合在一起就组成了仿射矩阵M：</p><script type="math/tex; mode=display">M = \begin{bmatrix}{A_{00}}&{A_{01}}&{b_{0}}\\{A_{10}}&{A_{11}}&{b_{1}}\\\end{bmatrix}</script><h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>平移变换是最简单的空间变换，目标物体的每一个像素点的相对位置不变，绝对位置发生相同的变化。</p><p>平移之后的坐标可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}{x'}\\{y'}\end{bmatrix} =\begin{bmatrix}{1}&{0}\\{0}&{1}\end{bmatrix}  \begin{bmatrix}{b_1}\\{b_2}\end{bmatrix} =\gg \begin{cases} x' = x + b_1 \\ y' = y + b_2 \end{cases}</script><h3 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h3><p>将图片横坐标放大（或缩小）$S_x$倍，纵坐标放大（或缩小）$S_y$倍，变换矩阵和逆矩阵分别为：</p><script type="math/tex; mode=display">M = \begin{bmatrix} {S_x}&{0}&{0}\\{0}&{S_y}&{0} \end{bmatrix} \\ M^{-1} = \begin{bmatrix} {\frac{1}{S_x}}&{0}&{0}\\{0}&{\frac{1}{S_y}}&{0} \end{bmatrix}</script><h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>图像绕原点逆时针旋转$\alpha$角，其变换矩阵及逆矩阵（顺时针旋转）为：</p><script type="math/tex; mode=display">M = \begin{bmatrix} {cos\alpha}&{sin\alpha}&{0}\\{-sin\alpha}&{cos\alpha}&{0} \end{bmatrix} \\ M^{-1} = \begin{bmatrix} {cos(-\alpha)}&{sin(-\alpha)}&{0}\\{-sin(-\alpha)}&{cos(-\alpha)}&{0} \end{bmatrix}</script><h2 id="形态学变换"><a href="#形态学变换" class="headerlink" title="形态学变换"></a>形态学变换</h2><p>数学形态学（Mathematical morphology） 是一门建立在格论和拓扑学基础之上的图像分析学科，是数学形态学图像处理的基本理论。其基本的运算包括：腐蚀和膨胀、开运算和闭运算、骨架抽取、击中击不中变换、形态学梯度、Top-hat变换、颗粒分析等。</p><p>主要的作用有<strong>形态学滤波、连通域分割、连通域拼接、提取图像轮廓、突出图像亮斑或者暗斑等。</strong></p><h3 id="腐蚀（erode）"><a href="#腐蚀（erode）" class="headerlink" title="腐蚀（erode）"></a>腐蚀（erode）</h3><p>腐蚀在于消除一些孤立点, 消除一些边界点. 使边界向内收缩. 我们可以用腐蚀来消除无意义的小点。</p><p>首先需要确定一个核 kernel ， 明确核的尺寸（一般为方阵）与核取值。例如我们确定好这个核的尺寸为3<em>3 。用这个核函数与其覆盖区域的<strong>二值图像</strong>做<em>*与（and）</em></em>操作，如果都为1，将覆盖区域的中心点像素设置为1，否则为0。</p><p><img src="https://z3.ax1x.com/2021/03/24/6qpGOU.png" style="zoom:60%;" /></p><p>使用的核函数越大，则腐蚀效果越明显。</p><h3 id="膨胀（dilate）"><a href="#膨胀（dilate）" class="headerlink" title="膨胀（dilate）"></a>膨胀（dilate）</h3><p>膨胀与腐蚀其实刚好是一对相反的操作。膨胀是将与物体接触的所有背景点合并到该物体中，使边界向外部扩张的过程。可以用来填补物体中的空洞。</p><p>用核函数与其覆盖的二值图像区域做<strong>或 (or)</strong>操作。如果周边与其自身任意一个点为1，则覆盖区域的中心点像素设置为1, 否则为0。</p><p><img src="https://z3.ax1x.com/2021/03/24/6qp8yT.png" style="zoom:60%;" /></p><p>同样的，核函数越大，则膨胀的效果越强。</p><p>腐蚀和膨胀都是在二值图片的基础上操作，针对的是二值图中的1，也就是亮点。所以腐蚀之后，图片整体亮度变暗，而膨胀之后整体亮度提高。</p><h3 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h3><p>开运算（opening） 等于对图像先进行腐蚀（erode） 然后进行膨胀（dilate）。</p><p>开运算其主要作用与腐蚀相似，但与腐蚀操作相比，具有可以基本保持目标原有大小不变的优点。</p><p><img src="opening.jpg" style="zoom:67%;" /></p><p>开运算先腐蚀再膨胀，主要目标大小可以保持不变，而其中较小的亮点噪声就会再腐蚀过程中被消除，而在膨胀过程中，主要目标大小会被复原，而消除的亮点则不再复原。</p><h3 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h3><p>闭运算（closing） 是先对图像进行膨胀, 然后进行腐蚀操作.<br>闭运算用来填充物体内细小空洞、连接邻近物体、平滑其边界的同时并不明显改变其面积。</p><p><img src="closing.jpg" style="zoom:67%;" /></p><p>闭运算可以消除图像中的黑点。</p><h3 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h3><p>形态学梯度 = 图像膨胀 - 图像腐蚀，从而获取到图像的边缘。</p><p><img src="grad.jpg" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 形态学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——合成有序链表</title>
      <link href="/2020/02/08/yi-dao-bian-cheng-ti-he-cheng-you-xu-lian-biao/"/>
      <url>/2020/02/08/yi-dao-bian-cheng-ti-he-cheng-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述与分析"><a href="#题目描述与分析" class="headerlink" title="题目描述与分析"></a>题目描述与分析</h2><p>将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的，且合并后新链表依然有序。</p><p>这一题和反转链表一样，属于链表的基础操作之一。</p><p>同样有递归和迭代两种方式实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>首先找出两个链表（链表1和链表2）头节点中较小的一个（假设为链表1），作为新链表的头节点，然后递归链表1头节点的后一个节点和链表2.</p><h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 递归</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">l1</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">l2</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 存在空链表，直接返回另一个</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l1 </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l2):</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1 </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l2 </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> l2</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 链表1小，递归链表1后一个节点和链表2.</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l1.val </span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF"> l2.val):</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1</span></span><span class="line"><span style="color: #ABB2BF">            root.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(l1.next, l2)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 反之，递归链表1和链表2的后一个节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l2</span></span><span class="line"><span style="color: #ABB2BF">            root.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(l1, l2.next)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span></code></pre></div></div></figure><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 递归</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">l1</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">l2</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> ListNode类</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 存在空链表，则返回另一个链表</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l1 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> or l2 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (l1 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> l2 </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> l1; </span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">        } </span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // l1小，则新节点为l1，并递归l1的下一个节点和l2</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">, l2);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // l2小，则新节点为l2，并递归l1和l2的下一个节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(l1, </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>依次遍历两个链表，小的加入到新链表。</p><h4 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 迭代</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">l1</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">l2</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 存在空链表</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l1 </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l2):</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1 </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> l2 </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> l2</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 设置root指针指向l1,l2中较小的节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> l1.val</span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF">l2.val:</span></span><span class="line"><span style="color: #ABB2BF">            a, b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1.next, l2</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            a, b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l1, l2.next</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> l2</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 遍历节点，小的加到新链表后面</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(a </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> b):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> a.val</span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF">b.val:</span></span><span class="line"><span style="color: #ABB2BF">                curr.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a</span></span><span class="line"><span style="color: #ABB2BF">                </span></span><span class="line"><span style="color: #ABB2BF">                a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                curr.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> b</span></span><span class="line"><span style="color: #ABB2BF">                b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> b.next</span></span><span class="line"><span style="color: #ABB2BF">            curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> curr.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 没有遍历完的链表直接接到后面</span></span><span class="line"><span style="color: #ABB2BF">        curr.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> a </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> b</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span></code></pre></div></div></figure><h4 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 迭代</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">l1</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">l2</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> ListNode类</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeTwoLists</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 存在空链表，则返回另一个链表</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(l1 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> or l2 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (l1 </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> l2 </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> l1; </span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">        } </span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 新链表的头节点指向两个链表中较小的一个</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">            l1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">            root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">            l2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 迭代，依次比较剩余两个链表的头节点大小，小的加入到新链表</span></span><span class="line"><span style="color: #ABB2BF">        ListNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(l1</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> l2</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l1;</span></span><span class="line"><span style="color: #ABB2BF">                l1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">                l2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 其中一个链表迭代结束，则另一个的剩余部分直接接到后面</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (l1</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> l1 </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> l2;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 简明教程与命令</title>
      <link href="/2020/01/30/git-jian-ming-jiao-cheng-yu-ming-ling/"/>
      <url>/2020/01/30/git-jian-ming-jiao-cheng-yu-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="git-简明教程与命令"><a href="#git-简明教程与命令" class="headerlink" title="git 简明教程与命令"></a>git 简明教程与命令</h2><h3 id="What-is-git"><a href="#What-is-git" class="headerlink" title="What is git"></a>What is git</h3><p>Git是目前世界上最先进的分布式版本控制系统，可以极大便利我们的项目管理与文件版本管理。</p><p>git的架构如下图所示：</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9MHe.jpg" alt="git架构图" style="zoom:40%;" /></p><p>从架构图可以看出，git整体分为4部分。</p><p>从左向右看：</p><ol><li>本地仓库，也就是图中的workspace，顾名思义，这是我们的工作区，即操作文件的地方，</li><li>index，这其实是在.git文件夹下的一个子文件夹，内部存储了 <code>git add</code>后的文件，被称为stage，可以称之为暂存区，</li><li>repository，也就是本地的git仓库，一般称为版本库，</li><li>remote，远程仓库，比如著名的github，或者自己搭建的git服务器等。</li></ol><h3 id="1-本地仓库"><a href="#1-本地仓库" class="headerlink" title="1. 本地仓库"></a>1. 本地仓库</h3><p>本地的部分为左边三部分：工作区，暂存区和版本库。（也有人将暂存区和版本库合称为版本库，个人还是倾向于分开）。 </p><h4 id="1-1-版本保存"><a href="#1-1-版本保存" class="headerlink" title="1.1 版本保存"></a>1.1 版本保存</h4><p><strong>版本保存指的是将修改后的工作区保存至暂存区，再保存至版本库。</strong></p><p>当我们编辑修改好代码之后，首先要执行 <code>git add</code> 命令，这一步将会把我们的修改保存到暂存区。执行完这一步之后，我们修改后的代码就相当于有了一个副本，已经可以做到回退了。</p><p>但是，这个副本目前还是处于暂存区，要真正持久化保存需要执行 <code>git commit -m &#39;your commit comment&#39;</code>，这样，修改后的内容就会作为一个新的版本（<strong>官方称为提交对象</strong>）保存到仓库的当前分支。并且<strong>只有加入到暂存区之后才能被保存到版本库。</strong></p><p>由上述可以看出，保存新版本的过程为：修改后的文件通过 <code>git add</code> 提交到暂存区，再通过  <code>git commit</code>提交到版本库持久化保存。</p><p>如下图所示：（蓝色表示已存为版本库，绿色表示处于暂存区还没有存为版本库，红色表示修改后还没有存入暂存区）</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9Z1x.png" alt="初始状态" style="zoom:55%;" /></p><p>上图的A、B、C、D、E表示不同的文件状态。</p><p>首先，我们在工作区修改了文件，会处于上图的working状态，工作区中的文件是最新的版本，其中A，B，C都已经 <code>git add</code>  和 <code>git commit</code>，即这些步骤已经存在了版本库中。D执行了 <code>git add</code> 但还没有执行 <code>git commit</code>，即只存在了暂存区还没有存入版本库。而E还没有执行 <code>git add</code>，即最新的改动尚未被git所暂存 。</p><h4 id="1-2-版本回退"><a href="#1-2-版本回退" class="headerlink" title="1.2 版本回退"></a>1.2 版本回退</h4><p><strong>版本回退指的是从暂存区或者版本库回退先前的版本到工作区。</strong></p><p>版本回退一般使用 <code>git checkout</code> 、<code>git reset</code> 和<code>git revert</code>命令。</p><h5 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h5><p>在<code>Git</code>里面，<code>checkout</code>用于切换分支或者恢复工作树的文件。checkout命令实际上是用来改变HEAD的指向。不会对版本库中节点做改变。 </p><p>使用方式如下：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">checkout</span><span style="color: #ABB2BF"> [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;</span></span></code></pre></div></div></figure><p>这个命令很灵活，既可以带一个<code>commit</code>号，又可以带着一个路径。可以用来恢复分支，恢复单个文件或者恢复整个文件夹。</p><p>当你想要丢弃某个文件的改动的时候，一般使用这个命令。</p><ol><li><h6 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a><strong>恢复文件</strong></h6></li></ol><p>对于上图的初始状态，（假设工作区文件为test.txt）我们执行 <code>git checkout --test.txt</code> 就可以将状态E删除，把文件恢复到最近一次 <code>git add</code> 或者 <code>git commit</code> 状态，如下图所示：</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9AhR.png" alt="after checkout" style="zoom:55%;" /></p><p>执行完上述命令，工作区变成了和暂存区一样的状态。</p><p>又或者，你想要让工作区回到指定的C状态或者B状态（穿越回过去），可以使用 <code>git checkout &lt;B commitId&gt; -- test.txt</code> 就可以让暂存区和工作区都回到B状态，如下图所示：</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9V91.png" alt="after checkout B" style="zoom:55%;" /></p><p>此时，工作区、暂存区都变成了同样的B状态，并且，这个命令不会影响到其他文件。更很神奇的是，版本库中原有的commit节点不会发生任何变化，也就是说，<code>git checkout &lt;B commitId&gt; -- test.txt</code> 命令只是让<strong>test.txt文件</strong>在<strong>工作区和暂存区</strong>回到了B节点的状态，对于版本库不会有变化。</p><p>可以用 <code>git diff</code> 和 <code>git diff --cached</code> 分别比较工作区与暂存区、暂存区与版本库的状态。</p><p>不过要注意的是，<code>git checkout</code>命令会使用版本库覆盖暂存区，所以没有被追踪的E状态和暂存区中的D状态会丢失。所以建议使用这个命令回到过去状态之前，把目前的暂存区提交到版本库。</p><p>如果，执行完之后你又后悔了，想回到C的状态，可以使用 <code>git log</code> 查看C的commitID（关闭窗口再打开也还在），然后使用 <code>git checkout &lt;C commitId&gt; -- test.txt</code> 就可以回到C状态。</p><ol><li><h6 id="恢复提交对象"><a href="#恢复提交对象" class="headerlink" title="恢复提交对象"></a><strong>恢复提交对象</strong></h6></li></ol><p>当然，<code>git checkout &lt;B commitId&gt;</code> 这种去掉文件名的形式也是可以的，实现的效果为恢复所有的文件到B状态。</p><p>使用后会显示一段提示，如下图：</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9unO.jpg" alt='初始状态' style="zoom:60%;" /></p><p>这里的 <code>detached Head</code> 被翻译为游离指针，接下来的操作都是在这个指针所指向的节点上，如果你在这时对文件做出了更改，那么可能在你想要回到之前的分支时会遭到阻拦。</p><p>比如，上图是从master分支checkout过来的，在文件改变之后想要checkout回到master时，可能回不去了，这时，就可以像上述建议一样把这个修改后的节点通过 <code>git branch -c &lt;new-Branch-Name&gt;</code> 来生成一个新的分支，之后再合并这个分支到master中。</p><p>以上的表现形式看来，<code>git checkout</code> 像是平行时空，可以在不同不互相干扰的平行时空之间切换。因为这个命令主要是用来切换分支，具体用法如下。</p><ol><li><h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a><strong>切换分支</strong></h6></li></ol><p>很简单的命令<code>git checkout &lt;branchName&gt;</code> 就可以切换到对应的分支。</p><p>在那之前，你可以用<code>git branch</code> 命令查看你有哪些分支。</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。</p><p>执行 <code>git branch testing</code> 之后：</p><p><img src='https://z3.ax1x.com/2021/03/24/6q9J3t.png' alt='新建testing分支' style='zoom:50%'/></p><p>这会在当前所在的提交对象上创建一个指针，需要注意的是，这个命令只是新建分支，并不会切换到这个新建的分支上。</p><p>git中有一个名为 <code>HEAD</code> 的特殊指针，用来指示当前处于哪个分支，当前我们仍然在master分支上。</p><p><img src='https://z3.ax1x.com/2021/03/24/6q9lAH.png' alt='' style='zoom:50%'/></p><p>所以上述命令执行完之后，完整的指针如上图。</p><p>使用<code>git checkout testing</code> 就可以切换到testing分支上了。</p><p><img src='https://z3.ax1x.com/2021/03/24/6q91Nd.png' alt='' style='zoom:50%'/></p><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p>这个命令是git里面少有的会删除版本库节点的命令，要小心使用。</p><p><code>git reset</code> 的命令使用方法如下：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> [ </span><span style="color: #98C379">–-soft</span><span style="color: #ABB2BF"> | </span><span style="color: #61AFEF">–-mixed</span><span style="color: #ABB2BF"> | </span><span style="color: #61AFEF">–-hard]</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #98C379">commitI</span><span style="color: #ABB2BF">D&gt;</span></span></code></pre></div></div></figure><p><code>git reset &lt;commitID&gt;</code> 的意思就是把HEAD所处的分支指向commitID，但是同时它也会改变某些commit。</p><p><code>git reset</code> 命令比较特殊的一点是有三个可选参数：soft, mixed, hard</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">soft就是只动repo</span></span><span class="line"><span style="color: #abb2bf">mixed就是动repo还有staging(这个是默认参数)</span></span><span class="line"><span style="color: #abb2bf">hard就是动repo还有staging还有working</span></span></code></pre></div></div></figure><p>同样以上面的图示举例：</p><p>假设现在处于初始状态：</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9Z1x.png" style="zoom:55%;" /></p><ol><li>执行 <code>git reset --soft &lt;B commit&gt;</code> 命令之后，版本库回到了B状态，而暂存区和工作区的状态不变，实际结果如下图：</li></ol><p><img src="https://z3.ax1x.com/2021/03/24/6q9kN9.png" style="zoom:55%;" /></p><p>需要注意的是，此时C状态的commit会被删除，也就是一旦回到了过去，未来的节点就会被删除，当然，实际上使用 <code>git reflog</code> 仍然是可以找到C的commit，然后借助C的commit Id回到C状态的。</p><ol><li>对于初始状态，执行 <code>git reset --mixed &lt;B commit&gt;</code> 之后，版本库和暂存区都回到了B状态：</li></ol><p><img src="https://z3.ax1x.com/2021/03/24/6q9FAJ.png" style="zoom:55%;" /></p><p>注意，虽然这时候你仍然可以回到C状态，但是暂存区中的D状态是会丢失的。</p><ol><li>对于初始状态，执行 <code>git reset --hard &lt;B commit&gt;</code> 之后，版本库、暂存区、工作区全部都回到了B状态（PS: 版本库中的C状态实际上也是可以找回来的，只是执行reset命令之后不再显示出来。）：</li></ol><p><img src="https://z3.ax1x.com/2021/03/24/6q9ec6.png" style="zoom:55%;" /></p><p>这看起来和<code>git checkout &lt;B commitId&gt;</code> 效果一样，实际上有很大的不同。举个例子：</p><p><img src='https://z3.ax1x.com/2021/03/24/6q9mjK.png' style='zoom:75%' /></p><p>左边为初始状态，右上为执行reset命令，右下为执行checkout命令。</p><p>checkout命令只是将Head指针指向另外一个分支的分支指针，并不会对commit对象进行操作，而reset是将HEAD连同所对应的分支指向新的commit。</p><p>大概区别就是一个是切换到平行时空，一个是使当前时空变成和平行时空一样的状态。</p><p>需要特别注意的是，处于远程仓库的分支<strong>严格禁止</strong>使用 <code>git reset</code> 命令，因为有些人会以远程仓库的版本作为开发的基础，使用reset命令会破坏这些基础，造成某些意想不到的问题。</p><h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>现在基本上推荐使用 <code>git revert</code> 替换 <code>git reset</code>。</p><p>那么他们的区别在哪里呢？</p><p><img src="https://z3.ax1x.com/2021/03/24/6q934A.png" alt="reset" style="zoom:25%;" /></p><p>很明显， <code>reset</code> 之后回退到之前的状态。该状态之后的节点丢弃了。</p><p><img src="https://z3.ax1x.com/2021/03/24/6q9G9I.png" alt="revert" style="zoom:25%;" /></p><p><code>revert</code> 命令通过新建一个commit来撤销一次commit所做的修改，是一种安全的方式，并没有修改commit history。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。git的精髓就在于，有一个网站，管理众多远程仓库，他就是git hub。</p><p>正如我们在第一张图git架构图中看到的，本地的版本库还可以推送到远程仓库，这样，就可以协作开发一个项目。</p><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 </p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：这样你可以在命令行中使用你所设置的 <code>shortname</code> 来代替整个 URL。</p><p>比如，现在我们添加一个GitHub中的仓库，并把它命名为origin:</p><p><img src='https://z3.ax1x.com/2021/03/24/6q9KBD.jpg' alt='添加远程仓库' style='zoom:60%'/></p><p>原本，本地这个文件夹没有任何远程仓库，在我们使用  <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 命令之后，就添加了一个名为origin的远程仓库。现在，这个远程仓库中的master分支就可以用 <code>origin/master</code> 表示。</p><h4 id="PUSH代码到远程仓库"><a href="#PUSH代码到远程仓库" class="headerlink" title="PUSH代码到远程仓库"></a>PUSH代码到远程仓库</h4><p>上面，我们已经关联了一个远程仓库，并且命名为origin。</p><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。使用 <code>-u</code>参数，会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>之后，就可以通过 <code>git push origin master</code> 推送到远程了。</p><p><code>git push origin 分支名 --force</code>可以强制使用本地仓库覆盖远程仓库，但是要非常小心。</p><h4 id="PULL代码到本地"><a href="#PULL代码到本地" class="headerlink" title="PULL代码到本地"></a>PULL代码到本地</h4><p>有些时候，会先在GitHub建立仓库，或者从GitHub拉取最新的代码，这时候需要用到<code>git pull</code>命令。</p><p>假如需要从已经关联的origin仓库拉取，如果你很有自信，可以直接拉取：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">//查询当前远程的版本</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remote</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-v</span></span><span class="line"><span style="color: #61AFEF">//直接拉取并合并最新代码</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pull</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">master</span><span style="color: #ABB2BF"> [示例1：拉取远端origin/master分支并合并到当前分支]</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pull</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">dev</span><span style="color: #ABB2BF"> [示例2：拉取远端origin/dev分支并合并到当前分支]</span></span></code></pre></div></div></figure><p>一般情况下，<strong>推荐</strong><code>git fetch + merge</code>手动合并：</p><figure class="shiki bash"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">//查询当前远程的版本</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remote</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-v</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">fetch</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">master</span><span style="color: #ABB2BF">  [示例1：获取远端的origin/master分支]</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">fetch</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">dev</span><span style="color: #ABB2BF"> [示例2：获取远端的origin/dev分支]</span></span><span class="line"><span style="color: #61AFEF">//查看版本差异</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">log</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-p</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">master..origin/master</span><span style="color: #ABB2BF"> [示例1：查看本地master与远端origin/master的版本差异]</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">log</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-p</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">dev..origin/dev</span><span style="color: #ABB2BF">   [示例2：查看本地dev与远端origin/dev的版本差异]</span></span><span class="line"><span style="color: #61AFEF">//合并最新代码到本地分支</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">merge</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin/master</span><span style="color: #ABB2BF">  [示例1：合并远端分支origin/master到当前分支]</span></span><span class="line"><span style="color: #61AFEF">$</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">merge</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin/dev</span><span style="color: #ABB2BF"> [示例2：合并远端分支origin/dev到当前分支]</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 工具方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——判断二叉树是否对称</title>
      <link href="/2019/12/28/yi-dao-bian-cheng-ti-pan-duan-er-cha-shu-shi-fou-dui-cheng/"/>
      <url>/2019/12/28/yi-dao-bian-cheng-ti-pan-duan-er-cha-shu-shi-fou-dui-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，判断它是否是自身的镜像（即：二叉树是否为轴对称）</p><p>例如：下面这棵二叉树是对称的<br><img src="1.png" alt = '对称二叉树' style="zoom:50%;" /></p><p>而下面这棵二叉树不对称。<br><img src="2.png" alt='不对称' style="zoom:50%;" /></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>看上图，很明显对二叉树的对称有了概念。</p><p>可以用递归或者迭代的方式：</p><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><p>如上图对称二叉树的第二行，根节点1的左子树2和右子树2的值相等，并且左子树2的左子树3和右子树2的右子树3相等。</p><p>所以递归公式为：<code>checkout(root1.left, root2.right) and checkout(root1.right, root2.left)</code></p><p>即左子树的左子树应该等于右子树的右子树，并且左子树的右子树等于右子树的左子树。</p><p>递归过程实际上类似为左子树前序遍历（中、左、右），右子树反向前序遍历（中、右、左），然后判断这两个遍历过程是否相等。</p><h4 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 递归</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isSymmetric</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">root</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">checkout</span><span style="color: #ABB2BF">(root.left, root.right)</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">checkout</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">root1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">root2</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 左右对应位置的节点都为空，对称</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root1 </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root2):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 有一个节点为空，则不对称</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root1 </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root2):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 节点值不等，不对称</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF">(root1.val</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">root2.val):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 继续递归</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">checkout</span><span style="color: #ABB2BF">(root1.left, root2.right) </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">checkout</span><span style="color: #ABB2BF">(root1.right, root2.left)</span></span></code></pre></div></div></figure><h4 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 递归</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #7F848E; font-style: italic"> TreeNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> bool布尔型</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isSymmetric</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">root){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">check</span><span style="color: #ABB2BF">(root, root);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">check</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">root1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">root2</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">root1 </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">root2) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">root1 </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">root2) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">root2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">val</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">check</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">root2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">check</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">root1</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">root2</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure><h3 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h3><p>类似于BFS，逐层遍历节点入栈（或者队列），只不过入栈的顺序与层次遍历不太一样。</p><p>栈中元素为：<code>[左子树，右子树] -&gt;  [左子树的左子树，右子树的右子树，左子树的右子树，右子树的左子树]</code></p><p>这样，只要比较栈中的成对的两个元素，直到栈为空。</p><h4 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 迭代</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution2</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isSymmetric</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">root</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root) </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.left </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.right): </span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.left </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> root.right:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        stack </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [root.left, root.right]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(stack):</span></span><span class="line"><span style="color: #ABB2BF">            right_node </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> stack.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">            left_node </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> stack.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 左右节点均为空</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> left_node </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> right_node):</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">continue</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 左右节点均存在且相等，则继续加入到栈</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (left_node </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> right_node) </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> (left_node.val </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> right_node.val):</span></span><span class="line"><span style="color: #ABB2BF">                stack.</span><span style="color: #61AFEF">extend</span><span style="color: #ABB2BF">([left_node.left, right_node.right, left_node.right, right_node.left])</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 左右节点只有一个存在或者左右节点的值不等</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——判断链表是否有环</title>
      <link href="/2019/12/11/yi-dao-bian-cheng-ti-pan-duan-lian-biao-shi-fou-you-huan/"/>
      <url>/2019/12/11/yi-dao-bian-cheng-ti-pan-duan-lian-biao-shi-fou-you-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断给定的一个链表中是否有环。如果有环则返回true，否则返回false。需要给出空间复杂度为O(1)的解法。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这一题困难之处在于解法的空间复杂度需要满足O(1)。</p><p><img src = './1.png' style = 'zoom:50%'/></p><p>上图就是链表存在环的情况，画这个图的目的是表明，有环就2种情况，一是开始不是环，后面部分组成环。二是整个链表就是一个循环单链表。不会存在开始有环而链表尾不属于环的情况。</p><p>而单链表有环的本质是链表中存在链表节点出现了2次。</p><p>最简单的解法，是遍历链表，将链表的节点元素加入到一个哈希表中，哈希表发生冲突则表明有2个节点重复，即为有环。对于python来说，可以把链表元素加入到集合（ <code>set</code> ）中，判断是否重复出现。</p><p>当然，这种解法的空间复杂度为 <code>O(n)</code>，不满足题目要求。</p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>在来链表操作中，如果需要满足空间复杂度为 <code>O（1）</code> ，则常用到快慢指针，比如一个指针快而一个指针慢，或者一个指针先走一个后走。</p><p>本地设置2个指针，一个慢指针每次遍历一个节点，另外一个快指针每次遍历2个节点，如果存在环，则快指针先进入环，等到慢指针进入环后，快指针将与慢指针相遇。</p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 思路比较简单，不再注释，详细见上述介绍</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># class ListNode:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#     def __init__(self, x):</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.val = x</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.next = None</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hasCycle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        slow_p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> fast_p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(fast_p </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> fast_p.next):</span></span><span class="line"><span style="color: #ABB2BF">            fast_p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> fast_p.next.next</span></span><span class="line"><span style="color: #ABB2BF">            slow_p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> slow_p.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> fast_p </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> slow_p:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span></code></pre></div></div></figure><h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">/**</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> * Definition for singly-linked list.</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> * struct ListNode {</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> *     int val;</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> *     ListNode *next;</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> * };</span></span><span class="line"><span style="color: #7F848E; font-style: italic"> */</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">hasCycle</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">head) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> slow_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> fast_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(fast_p </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">fast_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            fast_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">fast_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            slow_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">slow_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(fast_p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> slow_p){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——按组翻转链表</title>
      <link href="/2019/10/26/yi-dao-bian-cheng-ti-an-zu-fan-zhuan-lian-biao/"/>
      <url>/2019/10/26/yi-dao-bian-cheng-ti-an-zu-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将给出的链表中的节点每 <strong><code>k</code></strong>个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是  <strong><code>k</code></strong> 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>例如：</p><p>给定的链表是1→2→3→4→5 </p><p>对于 k=2, 你应该返回 2→1→4→3→5</p><p>对于 k=3, 你应该返回 3→2→1→4→5</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这一题难就难在k个一组，并且多余的部分不翻转。</p><p>针对于上述的问题，我们需要逐段翻转，翻转之后在正确地连接起来，而剩余部分不翻转。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>使用递归方法解决，会比循环容易理解一些。通过递归的返回值将每一段的翻转链表连接起来。</p><p>通过设置类成员变量决定递归次数，保证剩余部分不会被翻转。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>设置一个长度为 <code>k</code> 的栈，逐个出栈就可以实现翻转，如果栈未满而链表已空则这一段链表不翻转。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF"> , </span><span style="color: #D19A66; font-style: italic">k</span><span style="color: #ABB2BF"> ):</span></span><span class="line"><span style="color: #ABB2BF">        length </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">        curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> curr:</span></span><span class="line"><span style="color: #ABB2BF">            length</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> curr.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 建立类成员变量，用来控制递归次数，把链表每k个作为一组（剩余的不分组），每组单独翻转，通过递归使新的组连接在一起</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.num </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> length</span><span style="color: #56B6C2">//</span><span style="color: #ABB2BF">k</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 调用递归函数</span></span><span class="line"><span style="color: #ABB2BF">        root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reverseChain</span><span style="color: #ABB2BF">(head, k)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseChain</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">k</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归结束</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head: </span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归次数达到组数</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.num </span><span style="color: #56B6C2">==</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.num </span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 翻转链表</span></span><span class="line"><span style="color: #ABB2BF">        p, c </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head, head.next</span></span><span class="line"><span style="color: #ABB2BF">        i </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">k </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> c):</span></span><span class="line"><span style="color: #ABB2BF">            i</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            q </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> c.next</span></span><span class="line"><span style="color: #ABB2BF">            c.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> p </span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> c </span></span><span class="line"><span style="color: #ABB2BF">            c </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> q </span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> q:</span></span><span class="line"><span style="color: #ABB2BF">                q </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> q.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归，原链表的head节点变成新链表的尾节点，尾节点指向递归返回节点</span></span><span class="line"><span style="color: #ABB2BF">        head.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reverseChain</span><span style="color: #ABB2BF">(c, k)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> p </span><span style="color: #7F848E; font-style: italic"># 递归函数返回反转之后的链表首节点</span></span></code></pre></div></div></figure><p>上述代码，首先遍历链表，计算长度，之后根据长度和k计算出需要翻转的段数，使用一个类成员变量控制类中的递归函数的递归次数。之后就可以调用递归函数了。</p><p>递归函数的过程为，遍历链表，每k个节点翻转一次，返回这一段链表反转之后的首节点。而原链表的首节点变成了新链表的尾节点，让这个尾节点指向递归返回值即可。</p><p>举个例子：原链表1-&gt;2-&gt;3-&gt;4-&gt;5, k=2, 那么翻转后的链表应该是2-&gt;1-&gt;4-&gt;3-&gt;5</p><p>首先，获取链表长度5，5//2=2即为需要划分的段数，剩余部分不处理。接下来，开始处理链表，此时未处理的链表头节点为1，从1开始取长度为2的链表进行翻转，此时翻转后的链表头节点为2，尾节点为1。递归函数返回节点2，而原链表的头节点即翻转后的尾节点1指向后续链表的递归返回值。</p><p><img src = './1.png' alt = '第一次递归过程' style='zoom:40%'/></p><p>第一次递归后，原始链表变成上述链表，之后继续递归即可。</p><p>或者，也可以不使用类成员变量。在遍历链表的过程中确定需要翻转的范围，不满足长度则不翻转。</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution2</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">k</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> head:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"><span style="color: #ABB2BF">        curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 找出长度为k的一段链表</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(k</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            curr </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> curr.next</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic"># 剩余部分不够k个，直接返回不翻转</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> curr:</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># tmp为剩余一段链表的头节点</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> curr.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># new_head为翻转后的头节点</span></span><span class="line"><span style="color: #ABB2BF">        new_head </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reverse</span><span style="color: #ABB2BF">(head, curr)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># head变成了翻转后的尾节点，则尾节点指向递归后的返回值</span></span><span class="line"><span style="color: #ABB2BF">        head.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(tmp, k)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归返回值为翻转后的头节点</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> new_head</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverse</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">tail</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        p, c </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> head, head.next</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(p</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">tail):</span></span><span class="line"><span style="color: #ABB2BF">            q </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> c.next</span></span><span class="line"><span style="color: #ABB2BF">            c.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> p</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> c</span></span><span class="line"><span style="color: #ABB2BF">            c </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> q</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> p</span></span></code></pre></div></div></figure><p>可以使用以下测试代码，测试翻转结果：</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ListNode</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">__init__</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">x</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.val </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> x</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 测试</span></span><span class="line"><span style="color: #ABB2BF">a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">c </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">d </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">ListNode</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">a.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> b</span></span><span class="line"><span style="color: #ABB2BF">b.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> c</span></span><span class="line"><span style="color: #ABB2BF">c.next </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> d</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Solution2</span><span style="color: #ABB2BF">()</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">new_root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> s.</span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(a, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> new_root:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(new_root.val, </span><span style="color: #E06C75; font-style: italic">end</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> new_root.next:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39; -&gt; &#39;</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">end</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    new_root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> new_root.next</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    /**</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #7F848E; font-style: italic"> ListNode类 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@param</span><span style="color: #7F848E; font-style: italic"> </span><span style="color: #E06C75; font-style: italic">k</span><span style="color: #7F848E; font-style: italic"> int整型 </span></span><span class="line"><span style="color: #7F848E; font-style: italic">     * </span><span style="color: #C678DD; font-style: italic">@return</span><span style="color: #7F848E; font-style: italic"> ListNode类</span></span><span class="line"><span style="color: #7F848E; font-style: italic">     */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">k</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">head){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> k; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tail </span><span style="color: #ABB2BF">-&gt; </span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">tail){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> next_chain </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> reversed_head </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseChain</span><span style="color: #ABB2BF">(head, tail);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseKGroup</span><span style="color: #ABB2BF">(next_chain, k);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> reversed_head;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reverseChain</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">head</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">ListNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">tail</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> c </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        ListNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(p</span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF">tail){</span></span><span class="line"><span style="color: #ABB2BF">            q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">c</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">c</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> c;</span></span><span class="line"><span style="color: #ABB2BF">            c </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure><p>c++代码的思想与python第二种方法的思想一致，详细见python代码的注释，不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三元组损失模型</title>
      <link href="/2019/08/22/san-yuan-zu-sun-shi-mo-xing/"/>
      <url>/2019/08/22/san-yuan-zu-sun-shi-mo-xing/</url>
      
        <content type="html"><![CDATA[<ul><li><h5 id="论文素材提供：珍珍"><a href="#论文素材提供：珍珍" class="headerlink" title="论文素材提供：珍珍"></a>论文素材提供：珍珍</h5></li></ul><h2 id="三元组损失概述"><a href="#三元组损失概述" class="headerlink" title="三元组损失概述"></a>三元组损失概述</h2><p>三元组损失（Triplet loss）函数是当前应用较为广泛的一种损失函数，最早由Google研究团队在论文《FaceNet：A Unified Embedding for Face Recognition》所提出，常用在人脸识别任务中。目的是做到非同类极相似样本的区分，比如说兄弟二人的区分。</p><p>所以，Triplet loss的优势在于细节区分，即当两个输入相似时，Triplet loss能够更好地对细节进行建模，相当于加入了两个输入差异性差异的度量，学习到输入的更好表示，从而在上述两个任务中有出色的表现。</p><p><img src="https://z3.ax1x.com/2021/03/23/6HtwrT.png" alt="Triplet loss优化过程" style="zoom:80%;" /><br>如上图所示，三元组图片输入到具有相同权重的特征提取网络。得到的特征向量再经过运算得到三元组损失（TripletLoss）。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>它的基本思想是：对于设定的三元组(Anchor, Positive, Negative) （Anchor和Positive为同类的不同样本，Anchor与Negative为异类样本），Triplet loss试图学习到一个特征空间，使得在该空间中相同类别的基准样本（Anchor）与 正样本（Positive）距离更近，不同类别的 Anchor 与负样本（Negative）距离更远。其思想与图像识别任务的目标很契合，即给定训练图集和测试图集，判断两张图片是否属于同一类标签。<br><img src="https://z3.ax1x.com/2021/03/23/6Ht0qU.png" alt="三元组优化思路"></p><p>Triplet loss本质上是属于度量学习（Metric Learning）的范围，其借鉴了度量学习中的经典大间隔最近邻（Large Margin Nearest Neighbors，LMNN）算法。以Triplet loss为训练准则的深度神经网络模型既兼顾了度量学习的朴素性，又拥有神经网络优秀的非线性建模能力，能够在极大程度上简化并且控制模型训练过程。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p><strong>基于Triplet loss的神经网络模型可以很好的对细节进行区分</strong>，尤其是在图像分类任务中，当两个输入很相似的时候，Triplet loss对这两个差异性较小的输入向量可以学习到更好的表示，从而在分类任务中表现出色。</p><p>相比其他分类损失函数，Triplet loss通常能在训练中学习到更好的细微的特征feature，更特别的是Triplet loss能够根据模型训练的需要设定一定的阈值。<br>带Triplet loss的网络结构在进行训练的时候一般都会设置一个阈值margin，设计者可以通过改变margin的值来控制正负样本的距离。同时通过设定指定的阈值，可以在特征进行归一化后，用来判断是否为同一个标签。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>虽然Triplet loss很有效，但也有缺点：三元组的选取导致数据的分布并不一定均匀，所以在模型训练过程表现很不稳定，而且收敛慢，需要根据结果不断调节参数，而且Triplet loss比分类损失更容易过拟合。</p><p>所以，大多数情况下，我们会把这种方法放在模型的预训练过程中，或者和softmax函数（分类损失）结合在一起使用。</p><h3 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h3><p>Triplet loss 由一个三元组<a, p, n>构成，需要三张图片作为输入，如上一段中的图片所示，其中a: anchor 表示基准样本，p: positive 表示与anchor相同类别但不同的正样本，n: negative 表示与基准样本不同类别的负样本。利用生成的每个triplet，模型就能够创建出对应的positive pair <a, p>和negative pair <a, n>。</p><p>Triplet loss的目的是，在一定的距离（margin）上，将positive pair和negative pair分开,通过优化保证嵌入空间（Embedding Space）中类别相同的样本点之间距离足够近，而类别不同的样本点间距离足够远，即基准样本与负样本的距离要远远大于基准样本与正样本间的距离。</p><p>则Triplet loss的思想用欧氏距离形式化表示为：</p><script type="math/tex; mode=display">L = max \lbrace d(a, p)-d(a, n) + margin\ ,\  0 \ \rbrace</script><p>对于阈值margin的设置需要注意选择合适大小的值，理论上来说，较大的margin能够增强模型对不同类样本的区分度，但是如果在训练初期就将margin设置得比较大，则可能会增加模型训练的难度，进而出现网络不收敛的情况。在模型训练初期先使用一个较小的值对网络进行初始化训练，之后再根据测试的结果对margin的值进行适当的增大或缩小，这样可以在保证网络收敛的同时让模型也能拥有一个较好的性能。<br>在这里设样本为 $x$，$f(x)$为映射函数，整个训练集的大小为N，则每个triplet的输入<a, p, n>，对应的Triplet loss形式化表示就可以写作：</p><script type="math/tex; mode=display">\frac{1}{N} \{\quad \sum_i^N[|f(x_i^a) - f(x_i^p)|^2 - |f(x_i^a) - f(x_i^n)|^2 + \alpha]_+\quad\}</script><p>式中$|f(x_i^a) - f(x_i^p)|^2$表示的是2-范数的平方，其作用是计算欧几里得空间的长度或者向量的模，具体的展开形式为：<strong><script type="math/tex">|\ast|^2 = |v_k|^2</script></strong><br>$v_k$表示的是向量，该式常用于机器学习的正则化中。<br>式中$ [\ast]+ $为合页损失（Hing loss）函数，表示与0取最大值，若式子小于 0,则说明此时的triplet满足损失值的要求，不同类别样本间的距离要远远大于相同类别样本间的距离，由于这样的triplet对神经网络的反向传播和参数更新没有提供帮助，因此将其损失值置为 0。至此我们可以看出，其实Triplet loss的整体优化目标就是一个最小化损失值的问题。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在图像任务中，Triplet loss经常用作样本点在欧氏空间上的距离向量表示，它可以极大地提升深度特征的判别能力。为了使训练更加迅速有效，需要注意设计好训练策略，只选择合适的triplet进行训练，因为一个数据集的triplet组合非常多，全部进行训练的话会大大降低效率。</p><p>基于我们对Triplet loss的定义，一般而言，会将triplet分为三类，如图所示：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HtdMV.png" alt="三类基准样本、正样本和负样本之间的距离关系" style="zoom:67%;" /></p><p>1、<strong>easy triplets （简单三元组）</strong>: 指在未经过训练的情况下，Triplet loss值已经为0的三元组，此时网络不需要训练学习就满足损失函数的要求。简单的用欧式距离表示为：$d(a, n)$&gt;$d(a, p)$+ margin；</p><p>2、<strong>semi-hard triplets（一般三元组）</strong>: 指负样本与基准样本间的距离大于正样本与基准样本间的距离，但Triplet loss值还没有达到0，此时网络通过恰当的学习可以不断降低损失值。用欧式距离表示为：$d(a, p)$&lt;$d(a, n)$ &lt;$d(a, p)$+margin；</p><p>3、<strong>hard triplets（困难三元组）</strong>: 指负样本与基准样本间的距离小于正样本与基准样本间的距离，这是网络最难学习的样本组，此时的损失值会出现较大的震荡。用欧式距离表示为：$d(a, n)$ &lt;$d(a, p)$。</p><p>由于简单三元组的损失值为0，如果训练网络只能学习到简单的triplets，会导致网络的泛化能力受到限制，网络没有学习到任何特征，对训练任务并没有帮助。因此当一个训练批次中包含大量的easy triplets时，会导致训练网络的收敛速度大大降低。</p><p>  而一般三元组非常适合网络的前期训练，能够帮助训练网络的收敛，并且同时可以得到大量比较有效的统计信息。</p><p>  困难三元组则在网络训练后期起到很好的学习作用，能够帮助提升网络的性能。让网络学习一些很难的样本特征，可以大大提高训练网络的分类能力，尤其是对难以判断的样本的判别能力。</p><p>  因此，在网络的训练中，我们需要注意结合一般三元组和困难三元组，充分利用两者进行训练学习不仅能够加快网络的收敛，同时可以在很大程度上提升网络模型的识别性能。</p><p>但Triplet loss有一个缺点是，当数据集比较大时，训练的triplet数量也会随之变得十分庞大，此时会造成训练任务变得很艰难。而且如果采用随机选取三元组的训练策略，有可能很多次模型从训练集中挑选的三张图片，恰好是比较简单的三元组，计算出的损失值会很不稳定，从而导致模型很难学习到图片的主要特征。因此我们在使用Triplet loss函数时，要注意选取的训练集不宜过大，还要<strong>设计好训练策略</strong>来选择恰当的triplet。</p><h3 id="三元组选取策略"><a href="#三元组选取策略" class="headerlink" title="三元组选取策略"></a>三元组选取策略</h3><p>许多类似的人脸识别、匹配工作都是在大数据集上实现的，这就要求对数据的高效利用。然而大多数样本在训练中后期不再有梯度贡献，例如含有margin的损失函数（triplet loss、softpn等），多数样本很容易满足于这个margin，此时损失函数中的loss不再发生变化，导致训练停滞阻塞。在极多identities（类别极多）的数据集中不能足够有效的挖掘困难样本，这就容易陷入局部极小，无法继续更新。</p><p>所以如何有效的进行困难样本挖掘（OHEM）成为了关键，困难样本应该包括同类（匹配样本）中距离较大的和非同类（非匹配样本）中距离较小的样本。</p><script type="math/tex; mode=display">\frac{1}{N} \{\quad \sum_i^N[|f(x_i^a) - f(x_i^p)|^2 - |f(x_i^a) - f(x_i^n)|^2 + \alpha]_+\quad\}</script><p>对于上述的公式，实际上并没有体现困难挖掘，所以随机选取的样本并不能保证是困难样本，恰恰相反，这样选取的三元组实际上大部分为简单样本。</p><p>并且在大量图片样本下使用triplet loss也并非容易，如何有效的在large-scale情况下高效优化？使用triplet会发现数据量激增，可组合的三元组变多，如果要遍历所有组合是不现实的，或者极其低效 。</p><p>主要有两种方法，一是将triplet loss转为softmax loss（<strong>triplet net一文中，将triplet loss结合了softmax的输出与mse</strong>），另一种是<strong>batch OHNM</strong>。</p><p>直接考虑<strong>在所有的样本空间来sample一个batch</strong>，如果这个batch中有不满足margin的就认为是困难样本。然而这样做并不能保证采样时正好选取了很多很<strong>相似</strong>的样本，而且（a,p,n）图像组一经选取就已经固定，不会再有其他的组合，所以效率较低。所以寻找相似的个体（类别）是提高triplet net的核心关键。</p><p>对于含有10个个体（人）的人脸数据，难以区分的肯定是那些长的很像的个体（比如甲与乙为兄弟二人）。之前的困难挖掘是首先在这些打散的<strong>整体空间</strong>中<strong>随机</strong>设置（a,p,n）三元组然后成批去训练，分错的作为困难样本。这就使得你这些三元组都已经<strong>固定</strong>了，困难样本不一定是真的困难，除非运气好使得三元组中有很多甲、乙中的样本。所以一个想法是首先对于所有样本进行聚类，观察哪些样本比较接近，（甲和乙长得像肯定聚类结果很接近），那么我就在聚好类的<strong>子空间</strong>中选取(a,p)二元组组成batch，n在这个batch中来选取，那么这个负样本n就会是真正的困难样本。</p><p><a href="https://arxiv.org/abs/1709.02940">How to Train Triplet Networks with 100K Identities?</a></p><p>上面这篇论文讨论了如何在大量类别上高效训练三元组网络。感兴趣的可以去看看。</p><h3 id="1-随机选取"><a href="#1-随机选取" class="headerlink" title="1.随机选取"></a>1.随机选取</h3><p>T代表全体样本空间，所以这里的三元组都是<strong>直接从总体样本中</strong>选择的，这也是我们大多数人的做法。</p><p><img src="https://z3.ax1x.com/2021/03/23/6HtUx0.png" alt="随机选取训练流程"></p><p>看上面这个图示，红色为anchor，浅绿色为positive，天蓝色为negative，深蓝色为hard negative。</p><p>这个方法中所有的匹配对和negative都是在<strong>整体样本</strong>中选取。可见，大多数negative是远离positive匹配对的，尽管训练的时候negative也会被分到一个batch中，但是真正困难的negative很难被选择到。</p><p><strong>总结：在打散的整体样本空间随机选择三元组，并不是最好的选择方式，只是最方便而已。</strong></p><h3 id="2-Triplet-with-Batch-OHNM"><a href="#2-Triplet-with-Batch-OHNM" class="headerlink" title="2.Triplet with Batch OHNM"></a>2.Triplet with Batch OHNM</h3><p><img src="https://z3.ax1x.com/2021/03/23/6HttGn.png" alt="batch OHEM损失计算流程"></p><p>这个方法是为了在一个batch中尽可能挖掘困难样本，这时negative并非在<strong>整体样本</strong>中选取而是在一个batch中选择。</p><p>看上图公式的第三行，a和p$\in$T，表示从全体样本中选取，x$\in$B，表示x从batch中选取。</p><p>再看第二行，x与$x^a$属于不同类别，一个batch中，这样的x有数个，把每个x都与$x^a$计算相似度，取相似度最小的一个x为$x^n$，再用这个$x^n$与之前的$x^a$和$x^p$计算三元组损失。</p><p>就是说只在全体样本中选取一个batch的三元组，这些样本输入到网络，输出的特征进行比较，训练时在这一个batch的特征中再选择negative来训练。<strong>这实际上是有选择地选取negative样本</strong>。从全局搜索变成了局部有选择搜索，所以搜到的困难样本可能性更大。</p><p>举个例子：<br>设batch_size = 4，那么会有&lt;$x_1^a$,$x_1^p$,$x_1$&gt;, &lt;$x_2^a$,$x_2^p$,$x_2$&gt;, &lt;$x_3^a$,$x_3^p$,$x_3$&gt;, &lt;$x_4^a$,$x_4^p$,$x_4$&gt;共4个三元组，<br>然而，这些三元组并不是接下来用来计算三元组损失的三元组。</p><p>因为这12个样本均要先输入到网络中，得到他们编码后的特征，然后第一组的$x_1^a$与$x_1$、$x_2$、$x_3$、$x_3$分别计算相似度，其中最相似的一个作为第一组的$x_1^n$，其他组的negative通过同样的计算得到。</p><p>最终，<strong>可能</strong>用来计算损失的三元组变成了&lt;$x_1^a$,$x_1^p$,$x_2$&gt;, &lt;$x_2^a$,$x_2^p$,$x_2$&gt;, &lt;$x_3^a$,$x_3^p$,$x_1$&gt;, &lt;$x_4^a$,$x_4^p$,$x_3$&gt;，这样，我们就在一个batch内组合得到了最能实现困难样本挖掘的三元组。</p><p><img src="https://z3.ax1x.com/2021/03/23/6HtN2q.png" alt="batch OHEM过程"></p><p>首先是<strong>匹配对组成batch</strong>经过网络得到距离后，根据距离判断相似度，再重新组成<strong>三元组batch</strong>，输入到损失函数来优化。</p><p>有一点值得注意，某些情况下，直接选择与anchor<strong>最近</strong>的negative作为困难样本，可能会导致poor training，模型难以训练，应该选择比较近邻的样本。 通俗来说，就是特别相似的三张图反而无法训练，因为它们本来就模糊属于一个类，这样反而造成一种“错误标记”的训练样本，让模型原本训练得比较稳定的权重大幅度改变，反而不利于准确训练。</p><p><strong>总结：在打散的整体样本空间随机选择二元组，在batch中选取合适的negative组成三元组，来计算三元组损失。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像分类 </tag>
            
            <tag> 三元组损失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法实现与比较——Python版</title>
      <link href="/2019/07/07/sort-algorithms-with-python/"/>
      <url>/2019/07/07/sort-algorithms-with-python/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文用Python实现列几种排序算法（冒泡排序、选择排序、插入排序、二分插入排序、快速排序、优化快速排序，并比较了他们在随机数组上的排序效率。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><div class="table-container"><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\times$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>折半插入排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td>$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td>$\times$</td></tr></tbody></table></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>本次几个算法均没有返回值，直接对原数组进行操作。</li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> time </span><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> numpy </span><span style="color: #C678DD">as</span><span style="color: #ABB2BF"> np</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">timer</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">fc</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">f</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">x</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        before </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">time</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">fc</span><span style="color: #ABB2BF">(x)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&quot;time: &quot;</span><span style="color: #ABB2BF">,</span><span style="color: #61AFEF">time</span><span style="color: #ABB2BF">()</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">before)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> f</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 冒泡排序</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">bubble_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># assert type(ls) == list, &quot;参数类型不为List&quot;</span></span><span class="line"><span style="color: #ABB2BF">    j </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> j</span><span style="color: #56B6C2">&gt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">        flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 如果某一次遍历过程没有发生元素交换，则已经有序，后续不需要再执行了</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(j):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[i]</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">ls[i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]:</span></span><span class="line"><span style="color: #ABB2BF">                flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">                ls[i], ls[i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">], ls[i]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> flag:</span><span style="color: #C678DD">return</span></span><span class="line"><span style="color: #ABB2BF">        j</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span></code></pre></div></div></figure><p>1-9行，实现了一个装饰器，用来给算法计时。</p><p>11-23行，实现了一个冒泡排序算法，并稍微做了一点优化，一旦每一轮遍历没有改变元素顺序，则表示数组已经有序，后续的循环不需要再执行了。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 选择排序</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">choose_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)):</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i]</span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> i</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[j]</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">tmp:</span></span><span class="line"><span style="color: #ABB2BF">                pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> j</span></span><span class="line"><span style="color: #ABB2BF">                tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[j]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> i</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">pos:</span></span><span class="line"><span style="color: #ABB2BF">            ls[i], ls[pos] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[pos], ls[i]</span></span></code></pre></div></div></figure><p>选择排序的思路也很简单，虽然时间复杂度和冒泡排序一样为$O（n^2）$,但是随机情况下，速度大约比冒泡快一倍。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 插入排序，在近似有序的数组上表现最优</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[i]</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">ls[i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]:</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i]</span></span><span class="line"><span style="color: #ABB2BF">            j </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> j</span><span style="color: #56B6C2">&gt;=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> tmp </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> ls[j]:</span></span><span class="line"><span style="color: #ABB2BF">                ls[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[j]</span></span><span class="line"><span style="color: #ABB2BF">                j</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            ls[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp</span></span></code></pre></div></div></figure><p>插入排序类似于人打扑克牌时对牌进行的排序。速度上比冒泡略快，比选择排序略慢。</p><p>在近似有序的数组上，插入排序的表现是最好的。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 二分插入排序</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">binary_insert_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)):</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i]</span></span><span class="line"><span style="color: #ABB2BF">        low </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        high </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> low </span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF"> high:</span></span><span class="line"><span style="color: #ABB2BF">            middle </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">int</span><span style="color: #ABB2BF">((low </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> high) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> tmp </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> ls[middle]:</span></span><span class="line"><span style="color: #ABB2BF">                low </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> middle</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">                high </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> middle</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(i, low, </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            ls[j] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[j</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">        ls[low] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp</span></span></code></pre></div></div></figure><p>折半插入排序也叫二分插入排序，使用二分法来寻找插入的位置。在随机情况和最差情况下，表现比普通插入排序好得多，但在近似有序的数组上，表现不如普通插入排序。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 快速排序, 为了使用装饰器，多做了一层封装</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quick_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">partition</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">low</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">high</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> low</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[low]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(low</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, high</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[i] </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> tmp:</span></span><span class="line"><span style="color: #ABB2BF">                pos</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> pos</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">i:</span></span><span class="line"><span style="color: #ABB2BF">                    ls[pos], ls[i] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i], ls[pos]</span></span><span class="line"><span style="color: #ABB2BF">        ls[pos], ls[low] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[low], ls[pos] </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> pos</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">left</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">right</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> left </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> right:</span></span><span class="line"><span style="color: #ABB2BF">            pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">partition</span><span style="color: #ABB2BF">(left, right)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(left, pos</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,right)</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p>快速排序无愧于它的名字，数据量大的时候效率很高，在大多数计算机上，快速排序表现得都比其他几个排序方法要好。</p><p>但是，我们也得清楚快速排序的缺点。</p><ol><li>快速排序是一个递归算法，需要借助递归栈存储每一层递归调用的指针和参数。所以需要$O(logn)$—$O(n)$ 的空间复杂度。</li><li>快速排序的趟数取决于的递归树的深度。倘若每次快排都可以把数组划分为2个大小相同的数组，递归树的深度可以达到最小$O(logn)$，而对于有序数组，递归树退化为单枝树，递归树的深度达到 $O(n)$，排序时速度退化到简单排序的水平。不仅需要大量的存储空间，还会有“爆栈”的风险。</li><li>数据量小的时候，不适用与快速排序，可以选插入排序。研究表明，数组长度为5—25的时候，使用插入排序要比快速排序至少快10%。</li></ol><h3 id="优化后的快速排序"><a href="#优化后的快速排序" class="headerlink" title="优化后的快速排序"></a>优化后的快速排序</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 插入排序优化后的快速排序，解决快排在小数据量的排序效率低下问题</span></span><span class="line"><span style="color: #61AFEF">@timer</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quick_sort_insert</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">ls</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 插入排序</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert_sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">low</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">high</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(low</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, high):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[i] </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> ls[i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]:</span></span><span class="line"><span style="color: #ABB2BF">                tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i]</span></span><span class="line"><span style="color: #ABB2BF">                j </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> j</span><span style="color: #56B6C2">&gt;=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> tmp </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> ls[j]:</span></span><span class="line"><span style="color: #ABB2BF">                    ls[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[j]</span></span><span class="line"><span style="color: #ABB2BF">                    j</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">                ls[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> tmp</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">partition</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">low</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">high</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> low</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[low]</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(low</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, high</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ls[i] </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> tmp:</span></span><span class="line"><span style="color: #ABB2BF">                pos</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> pos</span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF">i:</span></span><span class="line"><span style="color: #ABB2BF">                    ls[pos], ls[i] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[i], ls[pos]</span></span><span class="line"><span style="color: #ABB2BF">        ls[pos], ls[low] </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ls[low], ls[pos] </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> pos</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">left</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">right</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> left </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> right</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            pos </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">partition</span><span style="color: #ABB2BF">(left, right)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(left, pos</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(pos</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,right)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">insert_sort</span><span style="color: #ABB2BF">(left, right</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">sort</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(ls)</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p>当数组或者子数组的长度在20以下，使用直接插入排序代替快速排序。另外，我们也可以从数组中随机选择一个数作为基准，而不是总是使用数组的第一个元素作为基准，这样可以避免在近似有序情况下，快速排序的退化问题。</p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>测试方法，随机生成一个长度为1W的数组</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 利用numpy，从0到5W生成一个长度1W的数组</span></span><span class="line"><span style="color: #ABB2BF">ls </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> np.random.</span><span style="color: #61AFEF">randint</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">50000</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">10000</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p>比较上述几种排序方法的运行时间：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">冒泡排序：31.1s</span></span><span class="line"><span style="color: #abb2bf">选择排序：15.5s</span></span><span class="line"><span style="color: #abb2bf">插入排序：22.6s</span></span><span class="line"><span style="color: #abb2bf">折半插入排序：11.8s</span></span><span class="line"><span style="color: #abb2bf">快速排序：0.221s</span></span><span class="line"><span style="color: #abb2bf">插入排序优化后的快速排序：0.177s</span></span></code></pre></div></div></figure><p><strong>By the way, python自带的list.sort()也是原地排序，对上述数组的排序时间为：0.000996s,比优化后的快速排序还要快百倍，这么快也有可能是因为这个内置方法是用C语言写出来的。</strong></p><p><strong>list.sort()使用的排序方法为Timsort算法，速度非常快，缺点是空间复杂度为 $O(n)$ ，比较耗费内存。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib 可视化</title>
      <link href="/2019/05/20/matplotlib-hui-zhi-san-dian-tu/"/>
      <url>/2019/05/20/matplotlib-hui-zhi-san-dian-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="matplotlib绘制散点图"><a href="#matplotlib绘制散点图" class="headerlink" title="matplotlib绘制散点图"></a>matplotlib绘制散点图</h2><p>上一篇文章，我们通过自编码器，将高维的特征压缩至二维和三维，这样就可以实现可视化效果。</p><ul><li>前排提醒：本文中代码为部分关键代码，全部代码请移步该项目的GitHub：<a href="https://github.com/skyfaker/Autoencoder">Autoencoder实现降维与可视化</a></li></ul><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 压缩特征维度至2维</span></span><span class="line"><span style="color: #ABB2BF">encoding_dim </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">3</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># this is our input placeholder</span></span><span class="line"><span style="color: #ABB2BF">input_img </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Input</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">shape</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">,))</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 编码层</span></span><span class="line"><span style="color: #ABB2BF">encoded </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">128</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;relu&#39;</span><span style="color: #ABB2BF">)(input_img)</span></span><span class="line"><span style="color: #ABB2BF">encoded </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">64</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;relu&#39;</span><span style="color: #ABB2BF">)(encoded)</span></span><span class="line"><span style="color: #ABB2BF">encoded </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;relu&#39;</span><span style="color: #ABB2BF">)(encoded)</span></span><span class="line"><span style="color: #ABB2BF">encoder_output </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(encoding_dim)(encoded)</span></span></code></pre></div></div></figure><p>如上面的代码，我们利用全连接神经网络实现了降维，降至二维。</p><p>我们训练好自编码器模型后，从中获取编码模型，接下来我们会用这个编码模型对测试数据进行编码。</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># predict &amp; plotting</span></span><span class="line"><span style="color: #ABB2BF">encoded_imgs </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> encoder.</span><span style="color: #61AFEF">predict</span><span style="color: #ABB2BF">(x_test)</span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">figure</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">figsize</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">12</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">9</span><span style="color: #ABB2BF">)) </span><span style="color: #7F848E; font-style: italic"># 设置窗口大小</span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">scatter</span><span style="color: #ABB2BF">(encoded_imgs[:, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">], encoded_imgs[:, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">], </span><span style="color: #E06C75; font-style: italic">c</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">y_test) </span><span style="color: #7F848E; font-style: italic"># 绘制散点图</span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">colorbar</span><span style="color: #ABB2BF">() </span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">show</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure><p>x_test的初始shape为（10000， 784），10000表示10000张图，784为每张图片的像素点数目（28*28）。经过编码器压缩之后<code>encoder.predict()</code> 变成了（10000，2）</p><p>再利用matplotlib的散点图绘制出只有二个特征的特征向量。</p><p>具体效果如图：</p><p><img src="2d.jpg" alt="二维的可视化效果"></p><p>可以看出，自编码器的降维效果也是不错的。</p><p>同样的，我们在把特征压缩到三维的时候，可以画出一个三维的散点图。绘制过程稍有点不同。</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># predict &amp; plotting</span></span><span class="line"><span style="color: #ABB2BF">encoded_imgs </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> encoder3D.</span><span style="color: #61AFEF">predict</span><span style="color: #ABB2BF">(x_test)</span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">figure</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">figsize</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">12</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">9</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">ax1 </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> plt.</span><span style="color: #61AFEF">axes</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">projection</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;3d&#39;</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">ax1.</span><span style="color: #61AFEF">scatter3D</span><span style="color: #ABB2BF">(encoded_imgs[:, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">], encoded_imgs[:, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">],encoded_imgs[:, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">], </span><span style="color: #E06C75; font-style: italic">c</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">y_test)</span></span><span class="line"><span style="color: #ABB2BF">plt.</span><span style="color: #61AFEF">show</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure><p><img src="3d.jpg" alt="二维的可视化效果"></p><ul><li>下面记录一下散点图的用法</li></ul><p>文档地址：<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html#matplotlib.pyplot.scatter">scatter文档</a></p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">matplotlib.pyplot.</span><span style="color: #61AFEF">scatter</span><span style="color: #ABB2BF">(x, y, </span><span style="color: #E06C75; font-style: italic">s</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">c</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">marker</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">cmap</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">norm</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">vmin</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">vmax</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">alpha</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">linewidths</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">verts</span><span style="color: #56B6C2">=&lt;</span><span style="color: #ABB2BF">deprecated parameter</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">edgecolors</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">, \</span><span style="color: #FFFFFF">*, plotnonfinite=False, data=None, \*\*kwargs)</span></span></code></pre></div></div></figure><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">scatter</span><span style="color: #ABB2BF">(x, y, 点的大小, 颜色，标记) </span><span style="color: #7F848E; font-style: italic"># 这是最主要的几个用法</span></span></code></pre></div></div></figure><p>点的形状属性由marker控制，默认为。， c 控制点的颜色， norm 控制亮度</p>]]></content>
      
      
      <categories>
          
          <category> 工具方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络——自编码器（Autoencoder）</title>
      <link href="/2019/04/16/autoencoder/"/>
      <url>/2019/04/16/autoencoder/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络（neural-network）的应用——自编码器（Autoencoder）"><a href="#神经网络（neural-network）的应用——自编码器（Autoencoder）" class="headerlink" title="神经网络（neural network）的应用——自编码器（Autoencoder）"></a>神经网络（neural network）的应用——自编码器（Autoencoder）</h2><h3 id="1-自编码器简介"><a href="#1-自编码器简介" class="headerlink" title="1. 自编码器简介"></a>1. 自编码器简介</h3><p>自编码器（Autoencoder，AE），是一种利用反向传播算法使得输出值等于输入值的神经网络，它先将输入压缩成潜在空间表征，然后通过这种表征来重构输出。</p><p>简单来说，就是可以自动实现编码与解码操作过程的网络模型，并且它的输入 <strong>x</strong> 与标签 <strong>y</strong> 相同，我们通过最小化标签  <strong>y</strong> 与输出 <strong>r</strong> 之间的误差，来优化自编码器模型。</p><p>因此，自编码器由两部分组成：</p><p><strong>编码器</strong>：这部分能将输入压缩成潜在空间表征，可以用编码函数 <strong>h</strong> =f(x)表示。</p><p><strong>解码器</strong>：这部分能重构来自潜在空间表征的输入，可以用解码函数 <strong>r</strong> =g(h)表示。</p><p><img src="https://z3.ax1x.com/2021/03/23/6HN70U.jpg" alt=""></p><p>整个自编码器可以用函数g(f(x)) =  <strong>r</strong> 来描述，其中输出r与原始输入 <strong>x</strong> 相近。</p><p>自编码器原理和各种变换的原理相似，都是将原始特征空间通过编码映射到一个新的编码空间，再由编码空间通过解码映射到解码空间。而当编码变换与解码变换符合某种条件时，解码空间和原始特征空间可以近似一致。</p><p>就像大名鼎鼎的傅里叶变换，通过它，可以把原始时域信号变换为频域信号，并且，频域信号可以通过反变换变换为时域信号。之所以要变换为频域信号，是为了获取原始信号在频域上的特征。同样的，对于自编码器的编码变换，也是为了获取不同角度，不同维度的特征（类似于SVM的核函数）。</p><p>按照Hinton的说法，自编码器的隐含层如果只有一层，其原理类似主成分分析（PCA），如果多个隐含层，每个隐含层都是受限玻尔兹曼机神经网。训练时，相当于先对每两层间进行无监督学习，将整个网络达到理想的初始化分布，最后再通过反向传播算法的有监督学习调整模型权重，这样可以解决网络过深带来的梯度弥散问题。</p><h3 id="2-自编码器的用途"><a href="#2-自编码器的用途" class="headerlink" title="2. 自编码器的用途"></a>2. 自编码器的用途</h3><p>数据可视化，数据降噪和降维被认为是自编码器的几个主要的实际应用。使用适当的维度和稀疏性约束，自编码器可以得到比PCA或其他类似技术更好的数据投影。</p><p>在自编码器中，中间的隐藏表达的维度往往维度比较低，因此可以被用作数据压缩，或者是特征降维。</p><p>不过自编码器原本不是专门用来做数据压缩的，它的作用就是可以作为很多神经网络的预训练，帮助提高模型的准确率。神经网络模型的训练需要大量具有标签的样本，而这样的数据通常是比较少的，更多的是无标签样本，而自编码器自监督的特性可以充分利用这些无标签样本，提前学习到有用的特征。接下来，把自编码器的编码器接入神经网络，进行训练。</p><h4 id="2-1-降维与可视化"><a href="#2-1-降维与可视化" class="headerlink" title="2.1 降维与可视化"></a>2.1 降维与可视化</h4><p>很明显，如果自编码器的只是单纯的将输入复制到输出中，那么它没有用处。所以实际上，我们希望通过训练自编码器将输入映射到 <strong>h</strong> 中，并且使表示函数 <strong>h</strong> 获得原始数据中有用的特征和属性，在这一过程中，输入到 <strong>h</strong> 的映射可以自动的帮助我们筛选特征，降低特征维度。</p><p>而想要让自编码器筛选有用特征，一种方法是约束 <strong>h</strong> 的维度小于 <strong>x</strong> ，在这种情况下，自编码器被称为欠完备（undercomplete）。通过训练不完整的表示，我们迫使自编码器学习训练数据的最有代表性（显著的）的特征。如果给自编码器的容量过大，则它可以复制 <strong>x</strong> 而不去提取关于数据分布的有用信息。</p><p>利用上述的方法，就达到了降维的作用。而当隐藏表达的维度降至三维或者二维时，就可以实现数据的可视化。</p><p>自编码器通过数据自动学习。这意味着在特定类型的输入中，自编码器可以表现出良好的结果，并且不需要任何新的结构，只需适当的训练数据即可。这种结构单一、无需标签的网络使用起来异常简单，并且常常会有不错的表现，所以使用地很广泛。</p><p>下面，看个例子，mnist数据集的二维可视化：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HNH7F.jpg" alt="二维可视化效果"></p><p>上图就是mnist数据集经过降维至二维后的可视化效果图。不同颜色的点代表不同的数字。</p><p>同样的，我们也可以降维到三维，形成空间可视化图：</p><p><img src="https://z3.ax1x.com/2021/03/23/6HNTmT.jpg" alt="三维可视化效果"></p><p>不过，它也不是没有缺点，首先，自编码器是数据相关的，是在给定的一组数据上进行训练的，因此它将得到与所用训练集数据相似的压缩结果，在这样的数据上表现优异，但就其通用性来说，效果并不好。比如在图像压缩领域，效果比不上JPEG这样的通用压缩技术。</p><h3 id="3-常见的自编码器与代码示例"><a href="#3-常见的自编码器与代码示例" class="headerlink" title="3. 常见的自编码器与代码示例"></a>3. 常见的自编码器与代码示例</h3><h4 id="3-1-简单自编码器和深度自编码器"><a href="#3-1-简单自编码器和深度自编码器" class="headerlink" title="3.1 简单自编码器和深度自编码器"></a>3.1 简单自编码器和深度自编码器</h4><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> keras.layers </span><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> Input, Dense</span></span><span class="line"><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> keras.models </span><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> Model</span></span><span class="line"><span style="color: #C678DD">from</span><span style="color: #ABB2BF"> keras.datasets </span><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> mnist</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> numpy </span><span style="color: #C678DD">as</span><span style="color: #ABB2BF"> np</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">encoding_dim</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">32</span></span><span class="line"><span style="color: #ABB2BF">input_img </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Input</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">shape</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">,))</span></span><span class="line"><span style="color: #ABB2BF">encoded </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(encoding_dim, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;relu&#39;</span><span style="color: #ABB2BF">)(input_img)</span></span><span class="line"><span style="color: #ABB2BF">decoded </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;sigmoid&#39;</span><span style="color: #ABB2BF">)(encoded)</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">autoencoder </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Model</span><span style="color: #ABB2BF">(input_img, decoded)</span></span><span class="line"><span style="color: #ABB2BF">encoder </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Model</span><span style="color: #ABB2BF">(input_img, encoded)</span></span></code></pre></div></div></figure><p>上面这种就是自编码器是最简单的形式，其中encoder是编码器，autoencoder是整个自编码器。</p><p>在这种形式中，基本上encoder的神经元个数都要少于输入的维度，因此Encoder在这里起到了降维的功能。</p><p>把<code>encoding_dim=32</code>换成<code>encoding_dim=2</code>或者<code>encoding_dim=3</code>就可以满足上图的可视化数据要求。</p><h4 id="3-2-稀疏自编码器"><a href="#3-2-稀疏自编码器" class="headerlink" title="3.2 稀疏自编码器"></a>3.2 稀疏自编码器</h4><p>除强加一个比输入更低维度的隐藏层外，还有其他一些方法可以限制自编码器的重构。包含正则化项的自编码器不需要通过保持编码器和解码器的浅层和程序的小体量来限制模型容量，而是使用损失函数来鼓励模型取得除了将输入复制到其输出之外的其他属性。在实践中，我们通常会使用稀疏自编码器。</p><p>简而言之，稀疏自编码器就是加入了正则项的自编码器，大部分参数置为0 ，这样做可以会使我们的自编码器学习数据的稀疏表示。</p><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">input_size </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">784</span></span><span class="line"><span style="color: #ABB2BF">hidden_size </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">64</span></span><span class="line"><span style="color: #ABB2BF">output_size </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">784</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Input</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">shape</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">(input_size,))</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># Encoder</span></span><span class="line"><span style="color: #ABB2BF">h </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(hidden_size, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;relu&#39;</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">activity_regularizer</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">regularizers.</span><span style="color: #61AFEF">l1</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10e-5</span><span style="color: #ABB2BF">))(x)</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># Decoder</span></span><span class="line"><span style="color: #ABB2BF">r </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Dense</span><span style="color: #ABB2BF">(output_size, </span><span style="color: #E06C75; font-style: italic">activation</span><span style="color: #56B6C2">=</span><span style="color: #98C379">&#39;sigmoid&#39;</span><span style="color: #ABB2BF">)(h)</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">autoencoder </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Model</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">input</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">x, </span><span style="color: #E06C75; font-style: italic">output</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">r)</span></span><span class="line"><span style="color: #ABB2BF">encoder </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Model</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">input</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">x, </span><span style="color: #E06C75; font-style: italic">output</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">h)</span></span></code></pre></div></div></figure><p>在的隐藏层中，我们添加了一个l1激活值正则化矩阵（activity regularizer），它将在优化阶段对损失函数施加一个惩罚，与普通的自编码器相比，现在的表示方式更加稀疏。</p><h4 id="3-3-卷积自编码器、变分自编码器（VAE）等"><a href="#3-3-卷积自编码器、变分自编码器（VAE）等" class="headerlink" title="3.3 卷积自编码器、变分自编码器（VAE）等"></a>3.3 卷积自编码器、变分自编码器（VAE）等</h4><p>如果输入的是图像，使用卷积神经网络（CNN）作为编码器和解码器是很有意义的。在实际使用中，应用于图像的自动编码器始终是卷积自动编码器 ，因为它们的性能要好得多。</p><p>编码器将由Conv2D和MaxPooling2D层组成（最大池化用于下采样，以减小图像维度，降维），而解码器将由Conv2D和UpSampling2D（增加图像维度，升维）层组成。</p><p>而VAE是一类重要的生成模型（generative model），广泛地用于生成图像，而大名鼎鼎的GAN就是对抗生成模型。原理和实现都比较复杂，用于以后研究。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>自编码器结构并不复杂，数学推导也很简单，有助于对于神经网络的理解。并且面对很多工业问题，比如说有大量的无标注数据，而有标签数据很少的情况下，可以利用自编码器进行预训练。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoEncoder </tag>
            
            <tag> 全连接神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue初见——如何运行一个Vue项目</title>
      <link href="/2019/03/16/how-to-run-a-vue/"/>
      <url>/2019/03/16/how-to-run-a-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="如何运行一个Vue项目"><a href="#如何运行一个Vue项目" class="headerlink" title="如何运行一个Vue项目"></a>如何运行一个Vue项目</h1><p>一开始刚接手项目内的vue.js，或者在GitHub上找到vue.js的开源项目，会发现不知如何运行这个项目。通过查阅网上教程，成功搭建好项目环境，同时对前段工程化有了朦朦胧胧的认知，因此将环境搭建过程分享给大家。</p><h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1. 环境安装"></a>1. 环境安装</h2><p>首先，列出来我们需要的东西：</p><figure class="shiki"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">node.js环境（npm包管理器）</span></span><span class="line"><span style="color: #abb2bf">vue-cli 脚手架构建工具</span></span><span class="line"><span style="color: #abb2bf">cnpm  npm的淘宝镜像</span></span></code></pre></div></div></figure><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>从node.js官网下载并安装node，安装过程很简单，一路“下一步”就可以了（傻瓜式安装）。<br>安装完成之后，打开命令行工具，输入 <code>node -v</code>，如下图，如果出现相应的版本号，则说明安装成功。</p><p><img src="image-20200216144352886.png" alt="image-20200216144352886"></p><p>npm包管理器直接集成在node中的，所以，不需要额外安装，输入 <code>npm -v</code>就会如下图所示，显示出npm的版本信息。</p><p><img src="image-20200216144500107.png" alt="image-20200216144500107"></p><p>由于有些npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候非常慢，甚至会失败，所有我还需要npm的国内镜像—-cnpm。</p><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>在命令行中输入 <code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code>，然后等待，安装完成。</p><h3 id="安装webpack（可选）"><a href="#安装webpack（可选）" class="headerlink" title="安装webpack（可选）"></a>安装webpack（可选）</h3><p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。</p><p><code>npm install webpack -g</code></p><h3 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h3><p>在命令行中运行命令 <code>cnpm install -g vue-cli</code> ，然后等待安装完成。(这里使用cnpm来替代npm，以加快速度)</p><h2 id="2-运行项目"><a href="#2-运行项目" class="headerlink" title="2. 运行项目"></a>2. 运行项目</h2><h3 id="从项目的根目录打开cmd"><a href="#从项目的根目录打开cmd" class="headerlink" title="从项目的根目录打开cmd"></a>从项目的根目录打开cmd</h3><p><img src="image-20200216145451354.png" alt="image-20200216145451354"></p><p><img src="image-20200216145519142.png" alt="image-20200216145519142"></p><h3 id="进入项目之后安装依赖"><a href="#进入项目之后安装依赖" class="headerlink" title="进入项目之后安装依赖"></a>进入项目之后安装依赖</h3><p><code>npm install</code>安装项目依赖</p><p>安装完成之后项目里面多了一个文件夹</p><p><img src="image-20200216145948586.png" alt="image-20200216145948586"></p><p>然后运行<code>npm run dev</code></p><p><img src="image-20200216151319536.png" alt="image-20200216151319536"></p><p>复制地址到浏览器就可以打开了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——两个栈实现队列</title>
      <link href="/2019/03/10/yi-dao-bian-cheng-ti-yong-liang-ge-zhan-shi-xian-dui-lie/"/>
      <url>/2019/03/10/yi-dao-bian-cheng-ti-yong-liang-ge-zhan-shi-xian-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>栈的特点是先进后出，队列为先进先出。</p><p>队列的功能只有2个，队尾进，队首出。</p><p>队尾进：这一功能和栈一致。</p><p>队首出：队列中第一个出队元素，在栈中为栈底元素。在栈中，要想取到栈底元素，必须所有元素出栈。而这些元素，只需要输出最后一个，其他的仍然需要保存。所以，我们可以把一个栈的元素依次取出，存入另一个栈。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个栈A，B，A用来接收入队的元素，B用来模拟出队的操作。</p><p>入队时，元素压入栈A，出队时，从栈B的栈顶弹出，如果B中没有元素，则依次取出A的元素压入栈B，再模拟出队操作。</p><p>比如：栈A = [1,2,3,4]，栈B = [ ]。</p><p>模拟入队操作时，元素直接压入栈A。</p><p>模拟出队操作，则需要取出第一个元素1，这时，需要把栈A中元素转到栈B。</p><p>栈A = [ ]，栈B = [ 4, 3, 2, 1]。然后再取出栈B的最后一个元素1。</p><p>下一次出队操作，再次从栈B取出栈顶元素。如果栈B为空，则将栈A所有的元素取出，压入栈B，再执行栈B的弹出栈顶操作。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># -*- coding:utf-8 -*-</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">__init__</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">node</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_a.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(node)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># return xx</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_b </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> []:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_a </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> []:</span><span style="color: #C678DD">return</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">list</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">reversed</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_a))</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_b.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.stack_b.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">node</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">stack2</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(node);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">stack1</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">()){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">stack2</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">()){</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">stack1</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">stack2</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">stack2</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">stack1</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">stack1</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    stack</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> stack1;</span></span><span class="line"><span style="color: #ABB2BF">    stack</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> stack2;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——重建二叉树</title>
      <link href="/2019/03/03/yi-dao-bian-cheng-ti-chong-jian-er-cha-shu/"/>
      <url>/2019/03/03/yi-dao-bian-cheng-ti-chong-jian-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>根据二叉树的前序遍历和中序遍历重建二叉树，或者计算后序遍历是二叉树的基础操作。</p><p>前序遍历是指先根节点，再左右子节点；中序遍历是指先左子节点，再根节点，最后右子节点；后续遍历是指先左右子节点，再根节点。</p><p>前序遍历和中序遍历可以唯一确定一棵二叉树，所以后序遍历的结果是唯一的。</p><p>一般遇到这样的问题，首选 <strong>递归</strong> 的方法。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于前序遍历是先根节点，后子节点，中序遍历为先左后跟。所以结合二者，对于前序遍历的结果，第一位必然是树的根，并且根据这个根，我们可以在中序遍历中找到左子树（根前面的元素）。</p><p>例如题目中的前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。</p><p>可知，前序遍历第一位为1，则1为树根，而在中序中1前面的都是左子树，所以左子树为4，7，2.</p><p>那么，我们就可以把前序和中序遍历划分为根，左子树，右子树。</p><p>前序：｛1 |2，4，7 | 3，5，6，8｝，中序：｛4，7，2 | 1 |5，3，8，6｝</p><p>接下来，只需要使用递归的方法，对左右子树做同样的操作，就可以重建二叉树了。</p><p>实际上，题目中的二叉树长这样：</p><p><img src="二叉树.png" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># -*- coding:utf-8 -*-</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># class TreeNode:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#     def __init__(self, x):</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.val = x</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.left = None</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.right = None</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 返回构造的TreeNode根节点</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">pre</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">tin</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 终止递归的条件</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(pre) </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 根节点为前序遍历的第一个节点</span></span><span class="line"><span style="color: #ABB2BF">        root </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">TreeNode</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 因为不含重复的数字，所以可以直接使用列表的index方法</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 这里需要注意对于原前序和中序列表的截取</span></span><span class="line"><span style="color: #ABB2BF">        root.left </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">:tin.</span><span style="color: #61AFEF">index</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">], tin[:tin.</span><span style="color: #61AFEF">index</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])])</span></span><span class="line"><span style="color: #ABB2BF">        root.right </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(pre[tin.</span><span style="color: #61AFEF">index</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">:], tin[tin.</span><span style="color: #61AFEF">index</span><span style="color: #ABB2BF">(pre[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">:])</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root</span></span></code></pre></div></div></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">TreeNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #E06C75; font-style: italic">pre</span><span style="color: #ABB2BF">,</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #E06C75; font-style: italic">vin</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> p_size </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p_size </span><span style="color: #C678DD">==</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> pre_left, pre_right, vin_left, vin_right;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> val </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        TreeNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">TreeNode</span><span style="color: #ABB2BF">(val);</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 寻找根节点在中序遍历中的位置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> p </span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(p; p </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> p_size; p</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vin</span><span style="color: #ABB2BF">[p] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> val)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 根据根节点在中序遍历中的位置，分为左子树和右子树</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> p_size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> p){ </span></span><span class="line"><span style="color: #7F848E; font-style: italic">                //左子树</span></span><span class="line"><span style="color: #7F848E; font-style: italic">                // 前序遍历的第一个元素是根节点，后面是左子树和右子树，所以从1开始</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">pre_left</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">[i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">vin_left</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vin</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(i </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> p){ </span></span><span class="line"><span style="color: #7F848E; font-style: italic">                //右子树</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">pre_right</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">pre</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">vin_right</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vin</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        // 递归左右子树</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(pre_left, vin_left);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">reConstructBinaryTree</span><span style="color: #ABB2BF">(pre_right, vin_right);</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——反向打印链表</title>
      <link href="/2019/02/24/yi-dao-bian-cheng-ti-fan-xiang-da-yin-lian-biao/"/>
      <url>/2019/02/24/yi-dao-bian-cheng-ti-fan-xiang-da-yin-lian-biao/</url>
      
        <content type="html"><![CDATA[<ul><li>前言：题目顺序 不严格按照剑指offer的题目顺序，有些过于简单的，涉及不到算法的，不适合用Python解决的题目，不会被记录。 </li></ul><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>本题目中的链表，特指的是单链表。</p><h4 id="单链表定义"><a href="#单链表定义" class="headerlink" title="单链表定义"></a>单链表定义</h4><p>线性表的链式存储结构的特点是用一组<strong>任意</strong>的存储单元存储线性表中的数据元素，这组存储单元可以存放在内存中未被占用的<strong>任意位置</strong>。</p><p><img src="单链表.png" alt="单链表结构图，来源于维基百科"></p><p><strong>数据域</strong>：存储数据元素信息的域，<strong>指针域</strong>：存储直接后继位置的域。指针域中存储的信息成为指针或链。</p><p>链表相比于顺序表，最大特点是某一个节点不仅保存当前节点的数据，还通过指针指示了上一个或者下一个节点的地址（单链表仅指向下一个节点）。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>但是因为链表中的元素在内存中是随机存储，并不像顺序表的顺序存储，所以链表不支持随机存取的方式，只能通过指针域的指针决定下一个搜索位置。</p><p>因此，对于单链表来说，按照链表顺序读取的方式，只支持从头结点（或者附加头结点）挨个读取到尾节点，想要逆向读取，需要用到 <strong>递归</strong> 的方法。</p><p>具体流程为：从头结点依次读取节点，如果节点的指针域不为空，即存在后继节点，则将该节点压入递归栈中，直到遇到没有后继节点的尾节点，将尾节点的数据域存入ArrayList中，在依次将栈中的节点弹出，并将弹出节点的数据域追加在ArrayList。</p><p>过程比较简单，就不画图演示了。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>逐个遍历节点，并且压入栈的时间复杂度为 $O(n)$ 。</p><p>弹出栈并且追加到ArrayList中的时间复杂度也为$O(n)$。</p><p>所以，总的时间复杂度为$O(n)$。</p><p>空间复杂度，因为需要用到递归栈来存储递归过程中的节点，故空间复杂度为$O(n)$。</p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><img src="双向循环链表节点.png" alt="双向循环链表节点图"></p><p><img src="双向循环链表.png" alt="双向循环链表结构图"></p><p>如果是双向循环链表的话，每个节点不仅指示下一个节点的地址，还指示了上一个节点的地址，则可以从尾节点反向依次查找，并且由于是循环链表，可以直接从头结点找到尾节点，而不需要把链表轮询一遍。</p><p>则时间复杂度为$O(n)$，空间复杂度为$O(1)$。查找的空间复杂大大降低，不过由于每个节点多了一个指针域，需要消耗更多的存储空间。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># -*- coding:utf-8 -*-</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 单链表节点的类定义</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># class ListNode:</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#     def __init__(self, x):</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.val = x  # 数据域</span></span><span class="line"><span style="color: #7F848E; font-style: italic">#         self.next = None  # 指针域</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">printListFromTailToHead</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">listNode</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> listNode </span><span style="color: #C678DD">is</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">None</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> []</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 递归运算，返回值用到了Python的特性，列表的+操作为将2个列表拼接在一起。</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">printListFromTailToHead</span><span style="color: #ABB2BF">(listNode.next) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> [listNode.val]</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道编程题——二维数组的查找</title>
      <link href="/2019/02/17/yi-dao-bian-cheng-ti-er-wei-shu-zu-zhong-de-cha-zhao/"/>
      <url>/2019/02/17/yi-dao-bian-cheng-ti-er-wei-shu-zu-zhong-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h3 id="逐个遍历"><a href="#逐个遍历" class="headerlink" title="逐个遍历"></a>逐个遍历</h3><p>这种题目思路不难，最直接的想法只需要挨个遍历即可。这个方法的问题在于，时间复杂度比较高。</p><h3 id="优化查找"><a href="#优化查找" class="headerlink" title="优化查找"></a>优化查找</h3><p>为了加快搜索速度，就需要用到题目中给的额外信息：<em>“每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序”</em> 。</p><p>我们会尝试着画出这个数组的矩阵形式，以下图为例：</p><p><img src="matrix.png" alt="矩阵A"></p><p>当我们对目标数进行查找的时候会有三种情况：</p><ul><li>当前数比目标数大，则目标数在当前数的左上角</li><li>当前数比目标数小，则目标数在当前数的右下角</li><li>当前数等于目标数，搜索结束</li></ul><p>所以我们对遍历的起点做了一点改变，我们不再是逐行再逐列搜索，而是从左下角（或者右上角）作为起点。</p><p>比如，设要搜索的整数为m，数组A的大小为n*n，我们从左下角开始，m先和左下角的<code>A[n-1][0]</code>做比较，如果m&gt;<code>A[n-1][0]</code>, 则m已经大于第一列的任何数，只需要右移一位，再和<code>A[n-1][1]</code>比较；如果m&lt;<code>A[n-1][0]</code>, 则m已经小于最后一行的任何数，只需要上移一位，再和<code>A[n-2][0]</code>比较。依次迭代，即可找到该整数，当没法上移或者右移且没有找到该数，则说明这个数不在二维数组中。</p><p>从右上角查找的过程也是类似的。</p><p><img src="matrix2.png" alt="查找过程"></p><p>以上面的矩阵A为例，设要查找的数为2.5，则查找过程如上图，最后无法继续移动，则查找结束，该数不存在。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p> 逐行挨个遍历的时间复杂度很简单，为 $O(n^2)$ 。</p><p>优化后的方法，比对的次数最多为2*n - 1，所以算法的复杂度为 $O(n)$。</p><p>从顺序查找的$O(n^2)$ 降低到$O(n)$，优化后时间复杂度为原来的的对数。可以联想到，长度为n的有序一维数组顺序查找，复杂度为$O(n)$，而使用二分法查找的时间复杂度为$O(log_2n)$，同样为原来的对数。</p><p>没错，因为二维数组内部存在了有序关系，所以实际上我们也是用到了二分法的思想。</p><p>具体二维数组的有序性可以参考下面的图：</p><p><img src="matrix_sort.png" alt="二维数组的有序性"></p><p>图中的红色框和蓝色框，表示从二维数组中抽取出来的两个一维数组。（这里采用的是先取列再取行的抽取方法，先取行再取列也是一样的）</p><p>很显然，这些一维数组都是递增有序的。</p><p>对于二维矩阵A，假设我们以左上角作为起点，开始查找，则开始的位置处于递增一维有序数组的开头，而当我们从左下角开始查找，开始的位置处于一维有序数组的中间位置，比对一次后，便可以排除最多n个元素。然后相应地移动到另外一个一维有序数组中进行比对。</p><p>比如上图的矩阵，m先与左下角的4比对，对应的一维有序数组为红色框的数组，m小于4,则比对位置移动至上一行的3，对应的一维有序数组为蓝色框的数组。在这一步过程中，排除掉了最后一行的n个元素。</p><p>相比之下，逐点比对，每一次比对只能排除掉一个元素。因此大大降低列时间复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="shiki python"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># -*- coding:utf-8 -*-</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># array 二维列表</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Find</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">target</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">array</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># write code here</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 从右上角开始查找</span></span><span class="line"><span style="color: #ABB2BF">        i </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">        j </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(array[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">])</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        row </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(array)  </span><span style="color: #7F848E; font-style: italic">#获取矩阵的shape</span></span><span class="line"><span style="color: #ABB2BF">        flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">False</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> i</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">row </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> j</span><span style="color: #56B6C2">&gt;=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> target</span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF">array[i][j]:</span></span><span class="line"><span style="color: #ABB2BF">                i</span><span style="color: #56B6C2">+=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF"> target</span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF">array[i][j]:</span></span><span class="line"><span style="color: #ABB2BF">                j</span><span style="color: #56B6C2">-=</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">elif</span><span style="color: #ABB2BF"> target </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> array[i][j]:</span></span><span class="line"><span style="color: #ABB2BF">                flag </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">break</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> flag</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2019/02/16/sort-algorithms/"/>
      <url>/2019/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><div class="table-container"><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th style="text-align:center">稳定性</th><th style="text-align:center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td style="text-align:center">$\checkmark$</td><td style="text-align:center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\checkmark$</td></tr></tbody></table></div><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><figure class="shiki cpp"><div class='codeblock'><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Solution</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">sortArray</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(nums);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 冒泡排序（超时）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">bubbleSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> i; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">j) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 选择排序（超时）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">selectSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> idx </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">j) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[idx]) {</span></span><span class="line"><span style="color: #ABB2BF">                    idx </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> j;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[idx]);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 插入排序（超时）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">insertSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i; j </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">j) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 快速排序（24 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">qSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">r</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (l </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> r) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> m </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> r; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[r]) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[m</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[m], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[r]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">qSort</span><span style="color: #ABB2BF">(nums, l, m</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">qSort</span><span style="color: #ABB2BF">(nums, m</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, r);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">qSort</span><span style="color: #ABB2BF">(nums, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 归并排序（192 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">mSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">r</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (l </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> r) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> {</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[l]};</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> m </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">(r</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">l)</span><span style="color: #56B6C2">/</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> lnums </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mSort</span><span style="color: #ABB2BF">(nums, l, m);</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> rnums </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mSort</span><span style="color: #ABB2BF">(nums, m</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, r);</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> res;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> m</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">l </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> r</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">m</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">lnums</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rnums</span><span style="color: #ABB2BF">[j]) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">lnums</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">            } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">rnums</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> m</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">l) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">lnums</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> r</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">m</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">rnums</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> res;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        nums </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mSort</span><span style="color: #ABB2BF">(nums, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 归并排序 + 非递归（80 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">mergeSortNR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> len </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; len </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; len </span><span style="color: #C678DD">&lt;&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> l </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; l </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">len; l </span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">len) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> m </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">len</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> r </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">min</span><span style="color: #ABB2BF">(n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, l</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">len</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> res;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l, j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> m</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> m </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> r) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j]) {</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                    }</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> m) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> r) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l; i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> r; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">[i</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">l];</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 希尔排序（40 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">shellSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> gap </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">/</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">; gap </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; gap </span><span style="color: #C678DD">/=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> gap; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i; j</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">gap </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">gap] </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j]; j </span><span style="color: #C678DD">-=</span><span style="color: #ABB2BF"> gap) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">gap], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[j]);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 计数排序（32 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">countSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">n) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> {};</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> minv </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #61AFEF">min_element</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxv </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #61AFEF">max_element</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> m </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> maxv</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">minv</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">count</span><span style="color: #ABB2BF">(m, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">minv]</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> res;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> m; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[i]; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">j) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">minv);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> res;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 基数排序（不适用于负数）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">radixSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxv </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #61AFEF">max_element</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxd </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (maxv </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            maxv </span><span style="color: #C678DD">/=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            maxd</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">count</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">rank</span><span style="color: #ABB2BF">(n, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> base </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (maxd </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">assign</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]</span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF">base)</span><span style="color: #56B6C2">%</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">]</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">rank</span><span style="color: #ABB2BF">[</span><span style="color: #C678DD">--</span><span style="color: #E5C07B">count</span><span style="color: #ABB2BF">[(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]</span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF">base)</span><span style="color: #56B6C2">%</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">]] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rank</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            maxd</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            base </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 桶排序 (20 ms)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">bucketSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxv </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #61AFEF">max_element</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> minv </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #61AFEF">min_element</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">begin</span><span style="color: #ABB2BF">(), </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> bs </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> m </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (maxv</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">minv)</span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF">bs</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        vector</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">bucket</span><span style="color: #ABB2BF">(m);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> n; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">bucket</span><span style="color: #ABB2BF">[(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]</span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF">minv)</span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF">bs].</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> idx </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> m; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> sz </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bucket</span><span style="color: #ABB2BF">[i].</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">bucket</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">bucket</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> sz; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">j) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[idx</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bucket</span><span style="color: #ABB2BF">[i][j];</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 堆排序（32 ms）</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">p</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">s</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> s) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> c1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> c2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> c </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (c2</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">s </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[c2]</span><span style="color: #C678DD">&gt;</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[c1]) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> c2 </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> c1;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[c] </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[p]) </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[c], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[p]);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> c;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt; </span><span style="color: #61AFEF">heapSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vector</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">nums</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> n </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">/</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(nums, i, n);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">swap</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">], </span><span style="color: #E5C07B">nums</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(nums, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, i);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> nums;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Blog</title>
      <link href="/2019/02/15/hello-world/"/>
      <url>/2019/02/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前也用过hexo框架生成的博客，当时部署在了国内的coding上面，速度会稳定一些，只是要在你的博客上给coding打个广告。</p><p>GitHub没有这个限制，but访问的时候，可能会遇到图片加载慢的问题。</p><p>其实如果有备案好的域名，也可以直接把静态文件放在七牛云、腾讯上面，还可以获得CDN加速的效果，免费的流量应该也够用。可惜我懒得备案，反正现在博客访问的人也不多，等到以后内容多了，可能又要搬家了吧，maybe。</p><p>放在GitHub上的静态文件，也有一些trick可以加速访问。这个放在TODO里面，以后研究一下吧。</p><p>That’s all！</p><p>Hello world again！</p>]]></content>
      
      
      <categories>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
